/**
\mainpage Akonadi, the KDE PIM storage framework

These pages are a combination of design and api documentation. If you are
looking for general information go to the Overview section.
For detailed information and/or api-dox on any of the packages go to the
package main page, either from the menu on the left or from the Building
blocks section below.


\section akonadi_overview Overview

- Design and Concepts
  - \ref akonadi_design_basic
  - \ref akonadi_design
  - \ref akonadi_design_communication
- \ref akonadi_usage
- <a href="http://pim.kde.org/akonadi">Website</a>
- <a href="http://techbase.kde.org/index.php?title=Projects/PIM/Akonadi">Wiki</a>
- \ref akonadi_todos

\section akonadi_building_blocks Building Blocks

- Domain-specific libraries:
  - <a href="../../kdepimlibs-apidocs/kabc/html/index.html">Contacts (KABC)</a>
  - <a href="../../kdepimlibs-apidocs/kmime/html/index.html">MIME Messages (KMime)</a>
  - <a href="../../kdepimlibs-apidocs/kcal/html/index.html">Events, todo items and journal entries (KCal)</a>
  - <a href="../../kdepimlibs-apidocs/akonadi/html/index.html">Core library (libakonadi)</a>

\authors Tobias KÃ¶nig <tokoe@kde.org>, Volker Krause <vkrause@kde.org>

\licenses \lgpl
*/



/**

\page akonadi_design_basic Basic Thoughts

To solve the \ref akonadi_history "problems of KDE 3" and make Akonadi ready for the requirements of the KDE 4 release
cycle, some considerations had been made which had a deep influence on the design:

\li <em>Functionality is spread over different processes.</em><br>
        This separation has the big advantage that if one process crashes because of
        a programming error it doesn't affect the other components. That results in
        robustness of the whole system. A disadvantage might be that there is an additional
        overhead due to inter-process communication.
\li <em>Communication protocol is split into data and control channel.</em><br>
        When doing communication between processes you have to differentiate between the type of data
        that is being transferred. For a large amount of data a high-performance
        protocol should be used and for control data a low-latency protocol.
        Matching both requirements in one protocol is mostly impossible and hard to
        achieve with currently available software.
\li <em>Separate logic from storage.</em><br>
        By separating the logic from the storage, the storage can be used to store data
        of any type. In this case, the storage is a kind of service, which is available for
        other components of the system. The logic is located in separated components and so
        3rd-party developers can extend the system by providing their own components.
\li <em>Keep communication asynchronous.</em><br>
        To allow a non-blocking GUI, all the communication with the back-end and within the
        back-end itself must be asynchronous. You can easily provide a synchronous convenience
        for the application developer; the back-end, however, must communicate asynchronously.

Keep these considerations in mind when you read \ref akonadi_design
*/

/**
\page akonadi_design Akonadi Design

The main components are:
- \ref akonadi_design_libakonadi (libakonadi)
- \ref akonadi_design_server
  - \ref akonadi_design_control
  - \ref akonadi_design_agents (resources)
  - \ref akonadi_design_storage

In the diagram below you can see a rough schematic view of Akonadi:

\image latex concept.eps "Akonadi Components" height=5cm
\image html concept.png "Akonadi Components"

For a more technical view go to \ref akonadi_overview_uml



\section akonadi_design_libakonadi The Client Library
Every client application can access the Akonadi service directly via the D-Bus and an IMAP-alike
protocol; however, for easier implementation and a better abstraction the library libakonadi is
provided, which handles all the low level stuff and provides a Qt based API for all the
functionality Akonadi provides.
libakonadi works on all kinds of data and knows nothing about the type of the data.
For the type specific tasks libkabc and libkcal should be used, which are positioned above
libakonadi, and perform the conversion from the raw storage format to convenient Qt/KDE objects.


\section akonadi_design_server Server
The Server is a process which provides an API to store arbitrary data over
an IMAP interface into a relational database. The advantage of IMAP is the mature state of the protocol
and its capability to handle large quantities of data.
Whenever items are added to or removed from the Storage, the Server will
emit a signal over its D-Bus interface to inform other components.
Also, as defined in the IMAP standard, a simple type of search is supported,
so you can query for all items of a special mime type or for email-specific fields.
For more complex search queries, another component, the SearchProvider, is included.

\subsection akonadi_design_agents Agents
Agents are processes which are controlled by the Akonadi server itself and which
are able to work on the cache of the Storage. In the current design there are two
types of Agents:

\li Autonomous Agents
\li Resources

Autonomous Agents are processes which only work on the cache of the Storage
and the user will (probably) never see them at work.

Resources are processes which load data from an external data source, store them
in the cache of the Storage and keep track of changes on both sides to keep
the external data source and the cache synchronized.

\subsection akonadi_design_control The Control
The Control process is the 'brain' of the system. It starts the Storage and Resource
processes and monitors them, so that if one of these processes crashes, it restarts them immediately.
Furthermore it provides a D-Bus API with the following functionality:

\li Managing Resources
\li Notifications when the state of Resources have changed

The Control should be started in the startkde script and terminated at the end of the session.

\subsection akonadi_design_storage Storage
The Storage is part of the Akonadi Server and is responsible for managing the cache of %Akonadi items.
In other words, create the database schema and perform read/write operations on the database.
*/

/**
\page akonadi_design_communication Communication Schemas

\section akonadi_design_communication_search Search

The sequence diagrams below show how general communication is done:

<div id='akonadi_client_search_small.png' onClick="document.getElementById('akonadi_client_search_small.png').style.display='none';document.getElementById(' akonadi_client_search.png').style.display='inline';" title="Click to enlarge" >
  \image html akonadi_client_search_small.png  "Akonadi Communication Schema"
 </div>
 <div id=' akonadi_client_search.png' onClick="document.getElementById(' akonadi_client_search.png').style.display='none';document.getElementById('akonadi_client_search_small.png').style.display='inline';" style="display:none" >
  \image html  akonadi_client_search.png  "Akonadi Communication Schema"
 </div>

\image latex akonadi_client_search.eps "Akonadi Communication Schema" height=5cm

The item search request is probably the call which is used most often
by the clients (components or applications). This call enables the client
to search for a list of items of a given mime type which match a
given search criterion.

In this case the client will contact the SearchProvider responsible for
the mime type, in order to retrieve the list of matching UIDs. The SearchProvider
already has a list of all available items of this mime type in its memory, so it
can search fast and use indices for optimization.

To communicate mime type constraints in FETCH and LIST and their responses the
IMAP flags mechanism is used. Unknown flags should be ignored by non-Akonadi
IMAP clients, which keeps compatibility with mutt and regular KMail.

Examples:
- List
\verbatim
0x8053c68 8 LIST "" "res1/foo/%"
0x8053c68 * LIST (\MimeTypes[text/calendar,directory/inode]) "/" "res1/foo/bar"
\endverbatim
- Fetch
\verbatim
0x8056310 7 UID FETCH 22 (UID RFC822.SIZE FLAGS BODY.PEEK[])
0x8056310 * 1 FETCH (FLAGS (\Seen \MimeTypes[message/rfc822]) RFC822 {2450} From: Till Adam To: ...
\endverbatim

\section akonadi_design_communication_agent Agent Handling
<div id=' akonadi_agent_handling_small.png' onClick="document.getElementById(' akonadi_agent_handling_small.png').style.display='none';document.getElementById(' akonadi_agent_handling.png').style.display='inline';" title="Click to enlarge" >
  \image html  akonadi_agent_handling_small.png  "Akonadi Agent Handling"
 </div>
 <div id=' akonadi_agent_handling.png' onClick="document.getElementById(' akonadi_agent_handling.png').style.display='none';document.getElementById(' akonadi_agent_handling_small.png').style.display='inline';" style="display:none" >
  \image html  akonadi_agent_handling.png  "Akonadi Agent Handling"
 </div>

\image latex akonadi_agent_handling.eps "Akonadi Agent Handling" height=4cm
*/

/**
\page akonadi_overview_uml Akonadi Overview

This overview does not show a complete class or collaboration diagram, it is rather meant to show the
big picture.

<div id=' akonadi_overview_uml_small.png' onClick="document.getElementById(' akonadi_overview_uml_small.png').style.display='none';document.getElementById(' akonadi_overview_uml.png').style.display='inline';" title="Click to enlarge" >
  \image html  akonadi_overview_uml_small.png  "Akonadi Overview"
 </div>
 <div id=' akonadi_overview_uml.png' onClick="document.getElementById(' akonadi_overview_uml.png').style.display='none';document.getElementById(' akonadi_overview_uml_small.png').style.display='inline';" style="display:none" >
  \image html  akonadi_overview_uml.png  "Akonadi Overview"
 </div>


*/


// DOXYGEN_NAME=kdepim-runtime
// DOXYGEN_ENABLE=YES
