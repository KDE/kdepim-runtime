commit ed1b57c7dbbbee2d7e385ae935f596764e8bd90d
Author: Montel Laurent <montel@kde.org>
Date:   Sun Sep 14 16:25:57 2014 +0200

    Port to KF5

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 89a555a..f89c661 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -1,26 +1,28 @@
 project(Libkolab)
 
-cmake_minimum_required(VERSION 2.6.4)
+cmake_minimum_required(VERSION 2.8.12 FATAL_ERROR)
+
+# where to look first for cmake modules, before ${CMAKE_ROOT}/Modules/ is checked
+
+find_package(ECM 1.3.0 CONFIG REQUIRED)
+set(CMAKE_MODULE_PATH "${Libkolab_SOURCE_DIR}/cmake/modules/" ${ECM_MODULE_PATH})
+include(GenerateExportHeader)
+include(ECMGenerateHeaders)
+include(ECMGeneratePriFile)
+include(ECMPackageConfigHelpers)
+include(ECMSetupVersion)
+include(FeatureSummary)
+include(KDEInstallDirs)
+include(KDECMakeSettings)
+include(KDEFrameworkCompilerSettings)
+
+set(QT_REQUIRED_VERSION "5.2.0")
 
 option( BUILD_TESTS "Build the tests" TRUE )
 option( PYTHON_BINDINGS "Build bindings for python" FALSE )
 option( PHP_BINDINGS "Build bindings for php" FALSE )
 option( USE_LIBCALENDARING "Use libcalendaring" FALSE )
 
-set(Libkolab_MODULE_DIR ${Libkolab_SOURCE_DIR}/cmake/modules)
-set(CMAKE_MODULE_PATH ${Libkolab_MODULE_DIR})
-
-# only available from cmake-2.8.0
-if(${CMAKE_MAJOR_VERSION} EQUAL 2 AND ${CMAKE_MINOR_VERSION} GREATER 7)
-    cmake_policy(SET CMP0012 NEW)
-endif()
-
-# only available from cmake-2.8.4
-if(${CMAKE_MAJOR_VERSION} EQUAL 2 AND ${CMAKE_MINOR_VERSION} GREATER 7 AND
-    ${CMAKE_PATCH_VERSION} GREATER 3)
-    cmake_policy(SET CMP0017 NEW)
-endif()
-
 # Versioning
 # x.y.z scheme
 # Development versions are only x.y
@@ -30,57 +32,40 @@ endif()
 # 0.1.0 (first release)
 # 0.1.1 (patch release for 0.1.0)
 # 0.2 (0.2 development version towards 0.2.0)
-set(Libkolab_VERSION_MAJOR 0)
-set(Libkolab_VERSION_MINOR 6)
 # Enable the full x.y.z version only for release versions
-#set(Libkolab_VERSION_PATCH 1)
-#set(Libkolab_VERSION ${Libkolab_VERSION_MAJOR}.${Libkolab_VERSION_MINOR}.${Libkolab_VERSION_PATCH} )
-set(Libkolab_VERSION ${Libkolab_VERSION_MAJOR}.${Libkolab_VERSION_MINOR} )
-set(Libkolab_VERSION_STRING ${CMAKE_PROJECT_NAME}-${Libkolab_VERSION})
 
 # set up install directories.
-set(LIB_INSTALL_DIR lib${LIB_SUFFIX} CACHE STRING "The directories where to install libraries to")
-set(INCLUDE_INSTALL_DIR include CACHE STRING "The directory where to install headers to")
-set(INCLUDE_INSTALL_DIR ${INCLUDE_INSTALL_DIR}/kolab)
-set(CMAKECONFIG_INSTALL_DIR ${LIB_INSTALL_DIR}/cmake/Libkolab )
 
-# Make relative paths absolute (needed later on)
-foreach(p LIB INCLUDE CMAKECONFIG)
-    set(var ${p}_INSTALL_DIR)
-    if(NOT IS_ABSOLUTE "${${var}}")
-        set(${var} "${CMAKE_INSTALL_PREFIX}/${${var}}")
-    endif()
-endforeach()
+set(CMAKECONFIG_INSTALL_DIR "${CMAKECONFIG_INSTALL_PREFIX}/KF5Kolab")
+
+set(KOLAB_VERSION "1.0.0")
+ecm_setup_version(${KOLAB_VERSION} VARIABLE_PREFIX KOLAB
+                        VERSION_HEADER "${CMAKE_CURRENT_BINARY_DIR}/src/kolab_version.h"
+                        PACKAGE_VERSION_FILE "${CMAKE_CURRENT_BINARY_DIR}/src/KF5KolabConfigVersion.cmake"
+                        SOVERSION 1
+)
+
 
-include(MacroLogFeature)
 
 # Do the building
 find_package(Libkolabxml 1.1 REQUIRED)
-macro_log_feature(Libkolabxml_FOUND "Libkolabxml" "Kolab XML Format 3 serializing library" "http://git.kolab.org/libkolabxml/" TRUE "1.0" "Required for reading/writing Kolab XML Objects")
-
-find_package(Qt4 4.6.0 REQUIRED)
+set_package_properties(Libkolabxml PROPERTIES DESCRIPTION "Kolab XML Format 3 serializing library" TYPE REQUIRED PURPOSE "Required for reading/writing Kolab XML Objects.")
 
 if (USE_LIBCALENDARING)
     find_package(Libcalendaring)
-    macro_log_feature(LIBCALENDARING_FOUND "Libcalendaring" "KDE Calendaring-Dependencies Library" "http://git.kolab.org/libcalendaring/" TRUE "" "Required if KDE libraries are not available.")
+    set_package_properties(Libcalendaring PROPERTIES DESCRIPTION "KDE Calendaring-Dependencies Librar" TYPE REQUIRED PURPOSE "Required if KDE libraries are not available.")
 else()
-    find_package(KDE4 4.8 REQUIRED)
-    find_package(KdepimLibs 4.8 REQUIRED)
+    set(KDEPIMLIBS_LIB_VERSION "4.71.0")
+    find_package(KF5Akonadi ${KDEPIMLIBS_LIB_VERSION} CONFIG REQUIRED)
+    find_package(KF5Abc ${KDEPIMLIBS_LIB_VERSION} CONFIG REQUIRED)
+    find_package(KF5PimUtils ${KDEPIMLIBS_LIB_VERSION} CONFIG REQUIRED)
+    find_package(KF5CalendarUtils ${KDEPIMLIBS_LIB_VERSION} CONFIG REQUIRED)
+    find_package(KF5Mime ${KDEPIMLIBS_LIB_VERSION} CONFIG REQUIRED)
+    find_package(KF5AkonadiNotes ${KDEPIMLIBS_LIB_VERSION} CONFIG REQUIRED)
 endif()
 
 find_package(SWIG)
 
-#Show summary of found libraries
-macro_display_feature_log()
-
-# add_definitions( -DKDEPIMLIBS_VERSION=((${KdepimLibs_VERSION_MAJOR}<<16)|(${KdepimLibs_VERSION_MINOR}<<8)|(${KDEPIMLIBS_VERSION_PATCH})) )
-add_definitions( -DKDEPIMLIBS_VERSION_MAJOR=${KdepimLibs_VERSION_MAJOR} )
-add_definitions( -DKDEPIMLIBS_VERSION_MINOR=${KdepimLibs_VERSION_MINOR} )
-add_definitions( -DKDEPIMLIBS_VERSION_PATCH=${KdepimLibs_VERSION_PATCH} )
-
-if("${KdepimLibs_VERSION}" VERSION_GREATER "4.8.40" OR USE_LIBCALENDARING)
-    add_definitions(-DKDEPIMLIBS_VERSION_DEVEL)
-endif()
 
 set( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wnon-virtual-dtor -Wno-long-long -ansi -Wundef -Wcast-align -Wchar-subscripts -Wall -W -Wpointer-arith -Wformat-security -fno-exceptions -DQT_NO_EXCEPTIONS -fno-common -Woverloaded-virtual -fno-threadsafe-statics -fvisibility=hidden -Werror=return-type -fvisibility-inlines-hidden -fexceptions -UQT_NO_EXCEPTIONS -fPIC -g" )
 # message("${CMAKE_CXX_FLAGS}")
@@ -91,123 +76,64 @@ if (USE_LIBCALENDARING)
     set( KDE_LIBRARIES ${Libcalendaring_LIBRARIES} )
     message("${Libcalendaring_INCLUDE_DIRS} ${Libcalendaring_LIBRARIES}")
 else()
-    set( KDE_INCLUDES ${KDEPIMLIBS_INCLUDE_DIRS} ${KDE4_INCLUDE_DIR})
     set( KDE_LIBRARIES
-        ${KDEPIMLIBS_KCALCORE_LIBS}
-        ${KDEPIMLIBS_KABC_LIBS}
-        ${KDEPIMLIBS_KMIME_LIBS}
-        ${KDEPIMLIBS_AKONADI_LIBS}
-        ${KDEPIMLIBS_AKONADI_NOTES_LIBS}
-        ${KDEPIMLIBS_KCALUTILS_LIBS}
-        ${KDEPIMLIBS_KPIMUTILS_LIBS}
-        ${KDE4_KDECORE_LIBRARY}
-        ${KDE4_KIO_LIBRARY}
+        KF5::CalendarCore
+        KF5::Abc
+        KF5::Mime
+        KF5::AkonadiCore
+        KF5::AkonadiNotes
+        KF5::CalendarUtils
+        KF5::PimUtils
+        KF5::KIOCore
         )
 endif()
 
 find_package(Boost REQUIRED)
 
-include_directories(    
-    ${QT_INCLUDES}
-    ${KDE_INCLUDES}
-    ${CMAKE_BINARY_DIR}
-    ${Boost_INCLUDE_DIRS}
-    ${CMAKE_CURRENT_SOURCE_DIR}/kolabformatV2
-    ${Libkolabxml_INCLUDES}
-    ./
-)
-
-configure_file(libkolab-version.h.cmake "${CMAKE_BINARY_DIR}/libkolab-version.h" @ONLY)
-
-add_subdirectory(kolabformatV2)
-add_subdirectory(conversion)
-add_subdirectory(calendaring)
-add_subdirectory(icalendar)
-add_subdirectory(freebusy)
-add_subdirectory(utils)
-
-QT4_WRAP_CPP(CALENDARING_MOC calendaring/event.h)
-# QT4_WRAP_CPP(CONVERSION_MOC conversion/qtevent.h conversion/qtduration.h)
-
-set(KOLAB_SRCS
-    kolabformat/kolabobject.cpp
-    kolabformat/xmlobject.cpp
-    kolabformat/formathelpers.cpp
-    kolabformat/errorhandler.cpp
-    kolabformat/v2helpers.cpp
-	kolabformat/mimeobject.cpp
-    mime/mimeutils.cpp
-    ${CONVERSION_SRCS}
-    ${kolabformatv2_SRCS}
-    ${CALENDARING_SRCS}
-    ${ICALENDAR_SRCS}
-    ${CALENDARING_MOC}
-    ${CONVERSION_MOC}
-    ${FREEBUSY_SRCS}
+ecm_configure_package_config_file(
+  "${CMAKE_CURRENT_SOURCE_DIR}/src/KF5KolabConfig.cmake.in"
+  "${CMAKE_CURRENT_BINARY_DIR}/src/KF5KolabConfig.cmake"
+  INSTALL_DESTINATION  ${CMAKECONFIG_INSTALL_DIR}
 )
 
-set(KOLAB_LINK_LIBRARIES
-    ${Libkolabxml_LIBRARIES}
-    ${QT_QTCORE_LIBRARY}
-    ${QT_QTXML_LIBRARY}
-    ${QT_QTGUI_LIBRARY}
-    ${KDE_LIBRARIES}
-)
-if(BUILD_TESTS)
-    #for tests only
-    enable_testing()
-    add_library(kolab_static STATIC ${KOLAB_SRCS})
-    target_link_libraries(kolab_static ${KOLAB_LINK_LIBRARIES})
-    add_subdirectory(tests)
-endif(BUILD_TESTS)
-
-add_library(kolab SHARED ${KOLAB_SRCS})
-target_link_libraries(kolab ${KOLAB_LINK_LIBRARIES})
-set_target_properties(kolab PROPERTIES VERSION ${Libkolab_VERSION}
-                                     SOVERSION ${Libkolab_VERSION_MAJOR} )
-
-install(TARGETS kolab EXPORT LibkolabExport 
-    RUNTIME DESTINATION ${BIN_INSTALL_DIR}
-    LIBRARY DESTINATION ${LIB_INSTALL_DIR}
-    ARCHIVE DESTINATION ${LIB_INSTALL_DIR}
+install(FILES
+  "${CMAKE_CURRENT_BINARY_DIR}/src/KF5KolabConfig.cmake"
+  "${CMAKE_CURRENT_BINARY_DIR}/src/KF5KolabConfigVersion.cmake"
+  DESTINATION "${CMAKECONFIG_INSTALL_DIR}"
+  COMPONENT Devel
 )
 
 install(FILES
-    kolab_export.h
-    kolabformat/kolabdefinitions.h
-    kolabformat/formathelpers.h
-    kolabformat/kolabobject.h
-    kolabformat/errorhandler.h
-    kolabformat/xmlobject.h
-    kolabformat/mimeobject.h
-    conversion/kcalconversion.h
-    conversion/kabcconversion.h
-    conversion/commonconversion.h
-    freebusy/freebusy.h
-    DESTINATION ${INCLUDE_INSTALL_DIR}
+   ${CMAKE_CURRENT_BINARY_DIR}/src/kolab_version.h
+   DESTINATION ${KF5_INCLUDE_INSTALL_DIR}
+   COMPONENT Devel
 )
 
-#Get the include directory relative to CMAKECONFIG_INSTALL_DIR
-file(RELATIVE_PATH REL_INCLUDE_DIR "${CMAKECONFIG_INSTALL_DIR}" "${INCLUDE_INSTALL_DIR}")
-#Assemble the full relative path. This will be used in the LibkolabConfig.cmake, which will be installed in CMAKECONFIG_INSTALL_DIR
-set(CONF_INCLUDE_DIRS "\${Libkolab_CMAKE_DIR}/${REL_INCLUDE_DIR}")
 
-install(EXPORT LibkolabExport DESTINATION ${CMAKECONFIG_INSTALL_DIR} FILE LibkolabTargets.cmake )
+install(EXPORT KF5KolabTargets DESTINATION "${CMAKECONFIG_INSTALL_DIR}" FILE KF5KolabTargets.cmake NAMESPACE KF5::)
 
-configure_file(${Libkolab_MODULE_DIR}/LibkolabConfig.cmake.in ${Libkolab_BINARY_DIR}/LibkolabConfig.cmake @ONLY )
-configure_file(${Libkolab_MODULE_DIR}/LibkolabConfigVersion.cmake.in ${Libkolab_BINARY_DIR}/LibkolabConfigVersion.cmake @ONLY )
-# Install these two files into the same directory as the generated exports-file.
-install(FILES ${Libkolab_BINARY_DIR}/LibkolabConfig.cmake ${Libkolab_BINARY_DIR}/LibkolabConfigVersion.cmake
-        DESTINATION ${CMAKECONFIG_INSTALL_DIR} )
 
 
-include(SWIGUtils)
-if(PYTHON_BINDINGS)
-    generatePythonBindings(shared shared.i)
-    add_subdirectory(kolabformat/python)
-endif(PYTHON_BINDINGS)
+set(KOLAB_LINK_LIBRARIES
+    ${Libkolabxml_LIBRARIES}
+    Qt5::Core
+    Qt5::Xml
+    Qt5::Gui
+)
+
+#REACTIVATE
+#if(BUILD_TESTS)
+#    #for tests only
+#    enable_testing()
+#    add_library(kolab_static STATIC ${KOLAB_SRCS})
+#    target_link_libraries(kolab_static ${KOLAB_LINK_LIBRARIES})
+#    add_subdirectory(tests)
+#endif(BUILD_TESTS)
+
+add_subdirectory(src)
+
+feature_summary(WHAT ALL
+                INCLUDE_QUIET_PACKAGES
+                FATAL_ON_MISSING_REQUIRED_PACKAGES
+)
 
-if(PHP_BINDINGS)
-    generatePHPBindings(kolabshared shared.i)
-    add_subdirectory(kolabformat/php)
-endif(PHP_BINDINGS)
diff --git a/calendaring/CMakeLists.txt b/calendaring/CMakeLists.txt
deleted file mode 100644
index 0cdbf08..0000000
--- a/calendaring/CMakeLists.txt
+++ /dev/null
@@ -1,15 +0,0 @@
-set (CALENDARING_SRCS
-    ${CMAKE_CURRENT_SOURCE_DIR}/calendaring.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/event.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/datetimeutils.cpp
-    PARENT_SCOPE)
-
-if(PYTHON_BINDINGS)
-    message("building python bindings")
-    add_subdirectory(python)
-endif(PYTHON_BINDINGS)
-
-if(PHP_BINDINGS)
-    message("building php bindings")
-    add_subdirectory(php)
-endif(PHP_BINDINGS)
diff --git a/calendaring/calendaring.cpp b/calendaring/calendaring.cpp
deleted file mode 100644
index 204353c..0000000
--- a/calendaring/calendaring.cpp
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "calendaring.h"
-
-#include <kcalcore/event.h>
-#include <kcalcore/todo.h>
-#include <Qt/qdebug.h>
-#include <kolabevent.h>
-
-#include "conversion/kcalconversion.h"
-#include "conversion/commonconversion.h"
-
-namespace Kolab {
-
-    namespace Calendaring {
-
-bool conflicts(const Kolab::Event &e1, const Kolab::Event &e2)
-{
-    KCalCore::Event::Ptr k1 = Kolab::Conversion::toKCalCore(e1);
-    KCalCore::Event::Ptr k2 = Kolab::Conversion::toKCalCore(e2);
-    if (k2->dtEnd().compare(k1->dtStart()) == KDateTime::Before) {
-        return false;
-    } else if (k1->dtEnd().compare(k2->dtStart()) == KDateTime::Before) {
-        return false;
-    }
-    return true;
-}
-
-std::vector< std::vector< Event > > getConflictingSets(const std::vector< Event > &events, const std::vector< Event > &events2)
-{
-    std::vector< std::vector< Kolab::Event > > ret;
-    for(std::size_t i = 0; i < events.size(); i++) {
-        std::vector<Kolab::Event> set;
-        const Kolab::Event &event = events.at(i);
-        set.push_back(event);
-        for(std::size_t q = i+1; q < events.size(); q++) {
-            const Kolab::Event &e2 = events.at(q);
-            if (conflicts(event, e2)) {
-                set.push_back(e2);
-            }
-        }
-        for(std::size_t m = 0; m < events2.size(); m++) {
-            const Kolab::Event &e2 = events2.at(m);
-            if (conflicts(event, e2)) {
-                set.push_back(e2);
-            }
-        }
-        if (set.size() > 1) {
-            ret.push_back(set);
-        }
-    }
-    return ret;
-}
-
-
-std::vector<Kolab::cDateTime> timeInInterval(const Kolab::Event &e, const Kolab::cDateTime &start, const Kolab::cDateTime &end)
-{
-    KCalCore::Event::Ptr k = Kolab::Conversion::toKCalCore(e);
-    KCalCore::DateTimeList list = k->recurrence()->timesInInterval(Kolab::Conversion::toDate(start), Kolab::Conversion::toDate(end));
-    std::vector<Kolab::cDateTime> dtList;
-    foreach(const KDateTime &dt, list) {
-        dtList.push_back(Kolab::Conversion::fromDate(dt));
-    }
-    return dtList;
-}
-
-Calendar::Calendar()
-:   mCalendar(new KCalCore::MemoryCalendar(Kolab::Conversion::getTimeSpec(true, std::string()))) //Always utc as it doesn't change anything anyways
-{
-}
-
-void Calendar::addEvent(const Kolab::Event &event)
-{
-    KCalCore::Event::Ptr k = Kolab::Conversion::toKCalCore(event);
-    if (!mCalendar->addEvent(k)) {
-        qWarning() << "failed to add event";
-    }
-}
-
-
-std::vector<Kolab::Event> Calendar::getEvents(const Kolab::cDateTime& start, const Kolab::cDateTime& end, bool sort)
-{
-    const KDateTime s = Kolab::Conversion::toDate(start);
-    const KDateTime e = Kolab::Conversion::toDate(end);
-    const KDateTime::Spec timeSpec = s.timeSpec();
-    KCalCore::Event::List list = mCalendar->events(s.date(), e.date(), timeSpec, true);
-    if (sort) {
-        list = mCalendar->sortEvents(list, KCalCore::EventSortStartDate, KCalCore::SortDirectionAscending);
-    }
-    std::vector<Kolab::Event> eventlist;
-    foreach (const KCalCore::Event::Ptr &event, list) {
-        //We have to filter the list by time
-        if (event->dtEnd().compare(s) != KDateTime::Before && e.compare(event->dtStart()) != KDateTime::Before) {
-            eventlist.push_back(Kolab::Conversion::fromKCalCore(*event));
-        }
-    }
-    return eventlist;
-}
-
-
-    } //Namespace
-} //Namespace
\ No newline at end of file
diff --git a/calendaring/calendaring.h b/calendaring/calendaring.h
deleted file mode 100644
index b48c1d6..0000000
--- a/calendaring/calendaring.h
+++ /dev/null
@@ -1,86 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef KOLABCALENDARING_H
-#define KOLABCALENDARING_H
-
-#ifndef SWIG
-#include "kolab_export.h"
-#else
-/* No export/import SWIG interface files */
-#define KOLAB_EXPORT
-#endif
-
-#include <kcalcore/event.h>
-#include <kcalcore/memorycalendar.h>
-#include <boost/scoped_ptr.hpp>
-#include <kolabevent.h>
-
-namespace Kolab {
-    namespace Calendaring {
-/**
- * Returns true if the events conflict (overlap)
- * Start and end date/time is inclusive.
- *
- * Does not take recurrences into account.
- */
-KOLAB_EXPORT bool conflicts(const Kolab::Event &, const Kolab::Event &);
-
-/**
- * Returns sets of the events which are directly conflicting with each other.
- * The same event may appear in multiple sets.
- * Non-conflicting events are not returned.
- * conflicts() is used for conflict detection.
- *
- * If the second list is given, each event from the first list is additionally checked against each event of the second set.
- * Conflicts within the second list are not detected.
- *
- * The checked event from the first list comes always first in the returned set.
- */
-KOLAB_EXPORT std::vector< std::vector<Kolab::Event> > getConflictingSets(const std::vector<Kolab::Event> &, const std::vector<Kolab::Event> & = std::vector<Kolab::Event>());
-
-/**
- * Returns the dates in which the event recurs within the specified timespan.
- */
-KOLAB_EXPORT std::vector<Kolab::cDateTime> timeInInterval(const Kolab::Event &, const Kolab::cDateTime &start, const Kolab::cDateTime &end);
-
-/**
- * In-Memory Calendar Cache
- */
-class KOLAB_EXPORT Calendar {
-public:
-    explicit Calendar();
-    /**
-     * Add an event to the in-memory calendar.
-     */
-    void addEvent(const Kolab::Event &);
-    /**
-     * Returns all events within the specified interval (start and end inclusive).
-     *
-     * @param sort controls if the resulting event set is sorted in ascending order according to the start date
-     */
-    std::vector<Kolab::Event> getEvents(const Kolab::cDateTime &start, const Kolab::cDateTime &end, bool sort);
-private:
-    Calendar(const Calendar &);
-    void operator=(const Calendar &);
-    boost::scoped_ptr<KCalCore::MemoryCalendar> mCalendar;
-};
-
-    }; //Namespace
-}; //Namespace
-
-#endif
diff --git a/calendaring/calendaring.i b/calendaring/calendaring.i
deleted file mode 100644
index fc935e4..0000000
--- a/calendaring/calendaring.i
+++ /dev/null
@@ -1,19 +0,0 @@
-%{
-    /* This macro ensures that return vectors remain a vector also in python and are not converted to tuples */
-    #define SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
-    
-    #include "../calendaring/calendaring.h"
-    #include "../calendaring/event.h"
-%}
-
-%include "std_string.i"
-%include "std_vector.i"
-
-%import(module="kolabformat") <kolabevent.h>
-%import "../shared.i"
-
-%rename(EventCal) Kolab::Calendaring::Event;
-%rename(KolabCalendar) Kolab::Calendaring::Calendar;
-
-%include "../calendaring/calendaring.h"
-%include "../calendaring/event.h"
diff --git a/calendaring/datetimeutils.cpp b/calendaring/datetimeutils.cpp
deleted file mode 100644
index d6ea077..0000000
--- a/calendaring/datetimeutils.cpp
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "datetimeutils.h"
-
-#include <qdebug.h>
-#include <ksystemtimezone.h>
-#include "conversion/commonconversion.h"
-
-namespace Kolab {
-    namespace DateTimeUtils {
-    KOLAB_EXPORT std::string getLocalTimezone()
-    {
-        const QString tz = KSystemTimeZones::local().name();
-        return tz.toStdString();
-    }
-
-    } //Namespace
-} //Namespace
diff --git a/calendaring/datetimeutils.h b/calendaring/datetimeutils.h
deleted file mode 100644
index 969f8bc..0000000
--- a/calendaring/datetimeutils.h
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef KOLABDATETIMEUTILS_H
-#define KOLABDATETIMEUTILS_H
-
-#ifndef SWIG
-#include "kolab_export.h"
-#else
-/* No export/import SWIG interface files */
-#define KOLAB_EXPORT
-#endif
-
-#include <string>
-
-namespace Kolab {
-    namespace DateTimeUtils {
-
-    KOLAB_EXPORT std::string getLocalTimezone();
-
-    }; //Namespace
-}; //Namespace
-
-#endif
diff --git a/calendaring/event.cpp b/calendaring/event.cpp
deleted file mode 100644
index 259a463..0000000
--- a/calendaring/event.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-
-#include "event.h"
-#include <icalendar/icalendar.h>
-#include <kolabformat/kolabobject.h>
-#include <conversion/kcalconversion.h>
-#include <conversion/commonconversion.h>
-
-#include <iostream>
-#include <kolabformat.h>
-#include <kolabevent_p.h>
-
-namespace Kolab {
-    namespace Calendaring {
-
-Event::Event()
-: Kolab::Event()
-{
-    setUid(Kolab::generateUID());
-}
-
-Event::Event(const Kolab::Event &e)
-: Kolab::Event(e)
-{
-}
-
-Event::~Event()
-{
-
-}
-
-
-bool Event::read(const std::string &string)
-{
-    const Kolab::Event &e = Kolab::readEvent(string, false);
-    if (Kolab::error()) {
-        return false;
-    }
-    Kolab::Event::operator=(e);
-    return true;
-}
-
-std::string Event::write() const
-{
-    return Kolab::writeEvent(*this);
-}
-
-bool Event::fromMime(const std::string &input)
-{
-    KMime::Message::Ptr msg = KMime::Message::Ptr(new KMime::Message);
-    msg->setContent( KMime::CRLFtoLF(Kolab::Conversion::fromStdString(input).toUtf8()) );
-    msg->parse();
-    msg->content(KMime::ContentIndex());
-    KolabObjectReader reader(msg);
-    if (reader.getType() != EventObject) {
-        std::cout << "not an event ";
-        return false;
-    }
-    const Kolab::Event &e = Kolab::Conversion::fromKCalCore(*reader.getEvent());
-    Kolab::Event::operator=(e);
-    return true;
-}
-
-std::string Event::toMime() const
-{
-    return std::string(QString(KolabObjectWriter::writeEvent(Kolab::Conversion::toKCalCore(*this))->encodedContent()).toUtf8().constData());
-}
-
-
-bool Event::fromICal(const std::string &input)
-{
-    std::vector<Kolab::Event> list = fromICalEvents(input);
-    if (list.size() != 1) {
-        std::cout << "invalid number of events: " << list.size();
-        return false;
-    }
-    Kolab::Event::operator=(list.at(0));
-    return true;
-}
-
-std::string Event::toICal() const
-{
-    std::vector<Kolab::Event> list;
-    list.push_back(*this);
-    return Kolab::toICal(list);
-}
-
-bool Event::fromIMip(const std::string &input)
-{
-    std::vector<Kolab::Event> list = mITipHandler.fromIMip(input);
-    if (list.size() != 1) {
-        std::cout << "invalid number of events: " << list.size();
-        return false;
-    }
-    Kolab::Event::operator=(list.at(0));
-    return true;
-}
-
-std::string Event::toIMip(ITipMethod method) const
-{
-    std::vector<Kolab::Event> list;
-    list.push_back(*this);
-    return mITipHandler.toIMip(*this, static_cast<ITipHandler::ITipMethod>(method), organizer().email());
-}
-
-Calendaring::Event::ITipMethod Event::getSchedulingMethod() const
-{
-    Q_ASSERT((int)iTIPPublish == (int)ITipHandler::iTIPPublish);
-    Q_ASSERT((int)iTIPNoMethod == (int)ITipHandler::iTIPNoMethod);
-    return static_cast<ITipMethod>(mITipHandler.method());
-}
-
-
-
-bool contains(const Kolab::ContactReference &delegatorRef, const std::vector <Kolab::ContactReference > &list)
-{
-    foreach (const Kolab::ContactReference &ref, list) {
-        if (delegatorRef.uid() == ref.uid() || delegatorRef.email() == ref.email() || delegatorRef.name() == ref.name()) {
-            return true;
-        }
-    }
-    return false;
-}
-
-void Event::delegate(const std::vector< Attendee >& delegators, const std::vector< Attendee >& delegatees)
-{
-
-    //First build a list of attendee references, and insert any missing attendees
-    std::vector<Kolab::Attendee*> delegateesRef;
-    foreach(const Attendee &a, delegatees) {
-        if (Attendee *attendee = getAttendee(a.contact())) {
-            delegateesRef.push_back(attendee);
-        } else {
-            d->attendees.push_back(a);
-            delegateesRef.push_back(&d->attendees.back());
-        }
-    }
-
-    std::vector<Kolab::Attendee*> delegatorsRef;
-    foreach(const Attendee& a, delegators) {
-        if (Attendee *attendee = getAttendee(a.contact())) {
-            delegatorsRef.push_back(attendee);
-        } else {
-            std::cout << "missing delegator";
-        }
-    }
-    
-    foreach (Attendee *delegatee, delegateesRef) {
-        std::vector <Kolab::ContactReference > delegatedFrom = delegatee->delegatedFrom();
-        foreach (Attendee *delegator, delegatorsRef) {
-
-            //Set the delegator on each delegatee
-            const ContactReference &delegatorRef = delegator->contact();
-            if (!contains(delegatorRef, delegatedFrom)) {
-                delegatedFrom.push_back(Kolab::ContactReference(Kolab::ContactReference::EmailReference, delegatorRef.email(), delegatorRef.name()));
-            }
-
-            //Set the delegatee on each delegator
-            std::vector <Kolab::ContactReference > delegatedTo = delegator->delegatedTo();
-            const ContactReference &delegaeeRef = delegatee->contact();
-            if (!contains(delegaeeRef, delegatedTo)) {
-                delegatedTo.push_back(Kolab::ContactReference(Kolab::ContactReference::EmailReference, delegaeeRef.email(), delegaeeRef.name()));
-            }
-            delegator->setDelegatedTo(delegatedTo);
-        }
-        delegatee->setDelegatedFrom(delegatedFrom);
-    }
-    
-}
-
-Attendee *Event::getAttendee(const ContactReference &ref)
-{
-    for(std::vector <Kolab::Attendee >::iterator it = d->attendees.begin();
-        it != d->attendees.end(); it++) {
-        if (it->contact().uid() == ref.uid() || it->contact().email() == ref.email() || it->contact().name() == ref.name()) {
-            return &*it;
-        }
-    }
-    return 0;
-}
-
-
-Attendee Event::getAttendee(const std::string &s)
-{
-    foreach(const Attendee &a, attendees()) {
-        if (a.contact().uid() == s || a.contact().email() == s || a.contact().name() == s) {
-            return a;
-        }
-    }
-    return Attendee();
-}
-
-cDateTime Calendaring::Event::getNextOccurence(const cDateTime &date)
-{
-    KCalCore::Event::Ptr event = Kolab::Conversion::toKCalCore(*this);
-    if (!event->recurs()) {
-        return cDateTime();
-    }
-    const KDateTime nextDate = event->recurrence()->getNextDateTime(Kolab::Conversion::toDate(date));
-    return Kolab::Conversion::fromDate(nextDate);
-}
-
-
-cDateTime Calendaring::Event::getOccurenceEndDate(const cDateTime &startDate)
-{
-    KCalCore::Event::Ptr event = Kolab::Conversion::toKCalCore(*this);
-    const KDateTime start = Kolab::Conversion::toDate(startDate);
-    return Kolab::Conversion::fromDate(event->endDateForStart(start));
-}
-
-cDateTime Calendaring::Event::getLastOccurrence() const
-{
-    KCalCore::Event::Ptr event = Kolab::Conversion::toKCalCore(*this);
-    if (!event->recurs()) {
-        return cDateTime();
-    }
-    const KDateTime endDate = event->recurrence()->endDateTime();
-    return Kolab::Conversion::fromDate(endDate);
-}
-
-
-    };
-};
diff --git a/calendaring/event.h b/calendaring/event.h
deleted file mode 100644
index e9b5ce4..0000000
--- a/calendaring/event.h
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-
-#ifndef EVENT_H
-#define EVENT_H
-#include <kolabevent.h>
-
-#ifndef SWIG
-#include "kolab_export.h"
-#include <icalendar/icalendar.h>
-#else
-/* No export/import SWIG interface files */
-#define KOLAB_EXPORT
-#endif
-
-namespace Kolab {
-    namespace Calendaring {
-
-class KOLAB_EXPORT Event: public Kolab::Event
-{
-public:
-    Event();
-    Event(const Kolab::Event &);
-    ~Event();
-
-    bool read(const std::string &);
-    /**
-     * Convert to kolab xml format.
-     */
-    std::string write() const;
-
-
-    bool fromMime(const std::string &);
-
-    /**
-     * Convert to kolab mime format.
-     */
-    std::string toMime() const;
-
-    enum ITipMethod {
-            iTIPPublish,       /**< Event, to-do, journal or freebusy posting */
-            iTIPRequest,       /**< Event, to-do or freebusy scheduling request */
-            iTIPReply,         /**< Event, to-do or freebusy reply to request */
-            iTIPAdd,           /**< Event, to-do or journal additional property request */
-            iTIPCancel,        /**< Event, to-do or journal cancellation notice */
-            iTIPRefresh,       /**< Event or to-do description update request */
-            iTIPCounter,       /**< Event or to-do submit counter proposal */
-            iTIPDeclineCounter,/**< Event or to-do decline a counter proposal */
-            iTIPNoMethod       /**< No method */
-        };
-    
-    bool fromICal(const std::string &);
-    std::string toICal() const;
-
-    bool fromIMip(const std::string &);
-    std::string toIMip(ITipMethod method) const;
-
-    /**
-     * Returns the scheduling method from the last fromIMip call
-     */
-    ITipMethod getSchedulingMethod() const;
-
-
-    /**
-     * Updates the delegators and delegatees of the event.
-     *
-     * Creates a new attendee for each missing delegatee (delegators are expected to be existing), and then updates each delegatee with the delegator (delegatedFrom).
-     * Delegators delegatedTo is updated accordingly.
-     * Existing attendees are tried to be found by uid/email/name (in this order).
-     *
-     */
-    void delegate(const std::vector<Kolab::Attendee> &delegators, const std::vector<Kolab::Attendee> &delegatees);
-
-    /**
-     * Get attendee by uid/email/name (in this order)
-     */
-    Kolab::Attendee getAttendee(const std::string &);
-
-    /**
-     * Returns the next occurence for a recurring event.
-     *
-     * If the start date of the event is passed in, the second occurence is returned (so it can be used in a for loop to loop through all occurences).
-     *
-     * If there is no next occurence or the event is not recurring at all an invalid cDateTime is returned.
-     */
-    Kolab::cDateTime getNextOccurence(const Kolab::cDateTime &);
-
-    /**
-     * Returns the corresponding end date-time for a specific occurence.
-     * @param start is the start date of the occurence.
-     */
-    Kolab::cDateTime getOccurenceEndDate(const Kolab::cDateTime &start);
-
-    /**
-     * Returns the last occurrence, or and invalid cDateTime if the event is not recurring or recurring idenfinitely.
-     */
-    Kolab::cDateTime getLastOccurrence() const;
-
-private:
-    Kolab::Attendee *getAttendee(const ContactReference &);
-    Kolab::ITipHandler mITipHandler;
-};
-
-    };
-};
-
-#endif // EVENT_H
diff --git a/calendaring/php/CMakeLists.txt b/calendaring/php/CMakeLists.txt
deleted file mode 100644
index 5fc92ec..0000000
--- a/calendaring/php/CMakeLists.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-#Generate PHP wrapper
-include_directories(../)
-include(SWIGUtils)
-generatePHPBindings(kolabcalendaring ../calendaring.i)
diff --git a/calendaring/php/test.php b/calendaring/php/test.php
deleted file mode 100644
index c31bc6f..0000000
--- a/calendaring/php/test.php
+++ /dev/null
@@ -1,236 +0,0 @@
-<?php
-//run using "php -d enable_dl=On extension=./kolabcalendaring.so test.php [--verbose]"
-
-include("kolabformat.php");
-include("kolabcalendaring.php");
-
-/////// Basic unit test facilities
-
-$errors = 0;
-$verbose = preg_match('/\s(--verbose|-v)\b/', join(' ', $_SERVER['argv']));
-
-function assertequal($got, $expect, $name) {
-	global $verbose, $errors;
-
-	if ($got == $expect) {
-		if ($verbose)
-			print "OK - $name\n";
-		return true;
-	}
-	else {
-		$errors++;
-		print "FAIL - $name\n";
-		print "-- Expected " . var_export($expect, true) . ", got " . var_export($got, true) . " --\n";
-		return false;
-	}
-}
-
-function asserttrue($arg, $name) {
-	return assertequal($arg, true, $name);
-}
-
-function assertfalse($arg, $name) {
-	return assertequal($arg, false, $name);
-}
-
-
-/////// Test EventCal recurrence
-
-$xml = <<<EOF
-<icalendar xmlns="urn:ietf:params:xml:ns:icalendar-2.0">
-  <vcalendar>
-    <properties>
-      <prodid>
-        <text>Libkolab-0.4 Libkolabxml-0.9</text>
-      </prodid>
-      <version>
-        <text>2.0</text>
-      </version>
-      <x-kolab-version>
-        <text>3.0dev1</text>
-      </x-kolab-version>
-    </properties>
-    <components>
-      <vevent>
-        <properties>
-          <uid>
-            <text>DDDEBE616DB7480A003725D1D7C4C2FE-8C02E7EEB49870A2</text>
-          </uid>
-          <created><date-time>2012-10-23T11:04:53Z</date-time></created>
-          <dtstamp><date-time>2012-10-23T13:04:53Z</date-time></dtstamp>
-          <sequence>
-            <integer>0</integer>
-          </sequence>
-          <class>
-            <text>PUBLIC</text>
-          </class>
-          <dtstart>
-            <parameters>
-              <tzid>
-                <text>/kolab.org/Europe/Paris</text>
-              </tzid>
-            </parameters>
-            <date-time>2012-10-23T14:00:00</date-time>
-          </dtstart>
-          <dtend>
-            <parameters>
-              <tzid>
-                <text>/kolab.org/Europe/Paris</text>
-              </tzid>
-            </parameters>
-            <date-time>2012-10-23T15:30:00</date-time>
-          </dtend>
-          <rrule>
-            <recur>
-              <freq>DAILY</freq>
-              <count>4</count>
-              <interval>2</interval>
-            </recur>
-          </rrule>
-          <summary>
-            <text>Recurring with libkolab</text>
-          </summary>
-        </properties>
-      </vevent>
-    </components>
-  </vcalendar>
-</icalendar>
-EOF;
-
-$rdates = <<<EOF
-<icalendar xmlns="urn:ietf:params:xml:ns:icalendar-2.0">
-  <vcalendar>
-    <properties>
-      <prodid>
-        <text>Roundcube-libkolab-0.9 Libkolabxml-1.1</text>
-      </prodid>
-      <version>
-        <text>2.0</text>
-      </version>
-      <x-kolab-version>
-        <text>3.1.0</text>
-      </x-kolab-version>
-    </properties>
-    <components>
-      <vevent>
-        <properties>
-          <uid>
-            <text>49961C572093EC3FC125799C004A200F-Lotus_Notes_Generated</text>
-          </uid>
-          <created>
-            <date-time>2014-02-28T12:57:42Z</date-time>
-          </created>
-          <dtstamp>
-            <date-time>2014-02-28T12:57:42Z</date-time>
-          </dtstamp>
-          <sequence>
-            <integer>0</integer>
-          </sequence>
-          <class>
-            <text>PUBLIC</text>
-          </class>
-          <dtstart>
-            <parameters>
-              <tzid>
-                <text>/kolab.org/Europe/Amsterdam</text>
-              </tzid>
-            </parameters>
-            <date-time>2012-03-30T04:00:00</date-time>
-          </dtstart>
-          <dtend>
-            <parameters>
-              <tzid>
-                <text>/kolab.org/Europe/Amsterdam</text>
-              </tzid>
-            </parameters>
-            <date-time>2012-03-30T20:00:00</date-time>
-          </dtend>
-          <transp>
-            <text>TRANSPARENT</text>
-          </transp>
-          <rdate>
-            <date>2012-03-30</date>
-            <date>2013-03-30</date>
-            <date>2014-03-30</date>
-            <date>2015-03-30</date>
-            <date>2016-03-30</date>
-            <date>2017-03-30</date>
-            <date>2018-03-30</date>
-            <date>2019-03-30</date>
-            <date>2020-03-30</date>
-            <date>2021-03-30</date>
-          </rdate>
-          <summary>
-            <text>Geburtstag Jane Doe (30.03.1969)</text>
-          </summary>
-        </properties>
-      </vevent>
-    </components>
-  </vcalendar>
-</icalendar>
-EOF;
-
-$e = kolabformat::readEvent($xml, false);
-$ec = new EventCal($e);
-
-$rstart = new cDateTime(2012,8,1, 0,0,0);
-# asserttrue($ec->getNextOccurence($rstart) instanceof cDateTime, "EventCal::getNextOccurence() returning cDateTime instance");
-
-$next = new cDateTime($ec->getNextOccurence($rstart));
-assertequal(
-	sprintf("%d-%d-%d %02d:%02d:%02d", $next->year(), $next->month(), $next->day(), $next->hour(), $next->minute(), $next->second()),
-	"2012-10-23 14:00:00",
-	"EventCal first recurrence"
-);
-
-$next = new cDateTime($ec->getNextOccurence($next));
-assertequal(
-	sprintf("%d-%d-%d %02d:%02d:%02d", $next->year(), $next->month(), $next->day(), $next->hour(), $next->minute(), $next->second()),
-	"2012-10-25 14:00:00",
-	"EventCal second recurrence"
-);
-
-$end = new cDateTime($ec->getOccurenceEndDate($next));
-assertequal(
-	sprintf("%d-%d-%d %02d:%02d:%02d", $end->year(), $end->month(), $end->day(), $end->hour(), $end->minute(), $end->second()),
-	"2012-10-25 15:30:00",
-	"EventCal::getOccurenceEndDate"
-);
-
-$last = new cDateTime($ec->getLastOccurrence());
-assertequal(
-	sprintf("%d-%d-%d %02d:%02d:%02d", $last->year(), $last->month(), $last->day(), $last->hour(), $last->minute(), $last->second()),
-	"2012-10-29 14:00:00",
-	"EventCal::getLastOccurence"
-);
-
-// test event with RDATE list
-
-$e = kolabformat::readEvent($rdates, false);
-$ec = new EventCal($e);
-
-$rstart = new cDateTime(2012,3,1, 0,0,0);
-$next = new cDateTime($ec->getNextOccurence($rstart));
-assertequal(
-	sprintf("%d-%02d-%02d %02d:%02d:%02d", $next->year(), $next->month(), $next->day(), $next->hour(), $next->minute(), $next->second()),
-	"2012-03-30 04:00:00",
-	"RDATE first recurrence"
-);
-
-$next = new cDateTime($ec->getNextOccurence($next));
-assertequal(
-	sprintf("%d-%02d-%02d %02d:%02d:%02d", $next->year(), $next->month(), $next->day(), $next->hour(), $next->minute(), $next->second()),
-	"2013-03-30 04:00:00",
-	"RDATE next recurrence"
-);
-
-$last = new cDateTime($ec->getLastOccurrence());
-assertequal(
-	sprintf("%d-%02d-%d %02d:%02d:%02d", $last->year(), $last->month(), $last->day(), $last->hour(), $last->minute(), $last->second()),
-	"2021-03-30 04:00:00",
-	"RDATE last occurence"
-);
-
-
-// terminate with error status
-exit($errors);
diff --git a/calendaring/python/CMakeLists.txt b/calendaring/python/CMakeLists.txt
deleted file mode 100644
index 2a49bea..0000000
--- a/calendaring/python/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-include_directories(../)
-include(SWIGUtils)
-generatePythonBindings(calendaring ../calendaring.i)
\ No newline at end of file
diff --git a/conversion/CMakeLists.txt b/conversion/CMakeLists.txt
deleted file mode 100644
index 683de63..0000000
--- a/conversion/CMakeLists.txt
+++ /dev/null
@@ -1,8 +0,0 @@
-
-set (CONVERSION_SRCS
-    ${CMAKE_CURRENT_SOURCE_DIR}/kcalconversion.cpp 
-    ${CMAKE_CURRENT_SOURCE_DIR}/kabcconversion.cpp 
-    ${CMAKE_CURRENT_SOURCE_DIR}/commonconversion.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/kolabconversion.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/timezoneconverter.cpp PARENT_SCOPE)
-
diff --git a/conversion/commonconversion.cpp b/conversion/commonconversion.cpp
deleted file mode 100644
index 7accd22..0000000
--- a/conversion/commonconversion.cpp
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "commonconversion.h"
-#include "timezoneconverter.h"
-#include <kolabformat/errorhandler.h>
-
-#include <iostream>
-#include <ksystemtimezone.h>
-#include <kdebug.h>
-#include <QUrl>
-
-namespace Kolab {
-    namespace Conversion {
-
-KDateTime::Spec getTimeSpec(bool isUtc, const std::string& timezone)
-{
-    if (isUtc) { //UTC
-        return KDateTime::Spec(KDateTime::UTC);
-    }
-    if (timezone.empty()) { //Floating
-        return  KDateTime::Spec(KDateTime::ClockTime);
-    }
-    //Timezone
-
-    //Convert non-olson timezones if necessary
-    const QString normalizedTz = TimezoneConverter::normalizeTimezone(QString::fromStdString(timezone));
-    KTimeZone tz = KSystemTimeZones::zone(normalizedTz); //Needs ktimezoned (timezone daemon running) http://api.kde.org/4.x-api/kdelibs-apidocs/kdecore/html/classKSystemTimeZones.html
-    if (!tz.isValid()) {
-        Warning() << "invalid timezone: " << QString::fromStdString(timezone) << ", assuming floating time";
-        if (!KSystemTimeZones::isTimeZoneDaemonAvailable()) {
-            Error() << "ktimezoned is not available and required for timezone interpretation";
-        }
-        return  KDateTime::Spec(KDateTime::ClockTime);
-    }
-    return KDateTime::Spec(tz);
-}
-
-KDateTime toDate(const Kolab::cDateTime &dt)
-{
-    KDateTime date;
-    if (!dt.isValid()) { //We rely on this codepath, so it's not an error
-        //         qDebug() << "invalid datetime converted";
-        return KDateTime();
-    }
-    if (dt.isDateOnly()) { //Date only
-        date.setDateOnly(true);
-        date.setDate(QDate(dt.year(), dt.month(), dt.day()));
-        date.setTimeSpec(KDateTime::Spec(KDateTime::ClockTime));
-    } else {
-        date.setDate(QDate(dt.year(), dt.month(), dt.day()));
-        date.setTime(QTime(dt.hour(), dt.minute(), dt.second()));
-        date.setTimeSpec(getTimeSpec(dt.isUTC(), dt.timezone()));
-    }
-    Q_ASSERT(date.timeSpec().isValid());
-    Q_ASSERT(date.isValid());
-    return date;
-}
-
-cDateTime fromDate(const KDateTime &dt)
-{
-    if (!dt.isValid()) {
-        //         qDebug() << "invalid datetime converted";
-        return cDateTime();
-    }
-    cDateTime date;
-    if (dt.isDateOnly()) { //Date only
-        const QDate &d = dt.date();
-        date.setDate(d.year(), d.month(), d.day());
-    } else {
-        const QDate &d = dt.date();
-        date.setDate(d.year(), d.month(), d.day());
-        const QTime &t = dt.time();
-        date.setTime(t.hour(), t.minute(), t.second());
-        if (dt.timeType() == KDateTime::UTC) { //UTC
-            date.setUTC(true);
-        } else if (dt.timeType() == KDateTime::OffsetFromUTC) {
-            const KDateTime utcDate = dt.toUtc();
-            const QDate &d = utcDate.date();
-            date.setDate(d.year(), d.month(), d.day());
-            const QTime &t = utcDate.time();
-            date.setTime(t.hour(), t.minute(), t.second());
-            date.setUTC(true);
-        } else if (dt.timeType() == KDateTime::TimeZone) { //Timezone
-            //TODO handle local timezone?
-            //Convert non-olson timezones if necessary
-            const QString timezone = TimezoneConverter::normalizeTimezone(dt.timeZone().name());
-            if (!timezone.isEmpty()) {
-                date.setTimezone(toStdString(timezone));
-            } else {
-                Warning() << "invalid timezone: " << dt.timeZone().name() << ", assuming floating time";
-                return date;
-            }
-        } else if (dt.timeType() != KDateTime::ClockTime) {
-            Error() << "invalid timespec, assuming floating time. Type: " << dt.timeType() << "dt: " << dt.toString();
-            return date;
-        }
-    }
-    Q_ASSERT(date.isValid());
-    return date;
-}
-
-QStringList toStringList(const std::vector<std::string> &l)
-{
-    QStringList list;
-    foreach(const std::string &s, l) {
-        list.append(Conversion::fromStdString(s));
-    }
-    return list;
-}
-
-std::vector<std::string> fromStringList(const QStringList &l)
-{
-    std::vector<std::string> list;
-    foreach(const QString &s, l) {
-        list.push_back(toStdString(s));
-    }
-    return list;
-}
-
-QUrl toMailto(const std::string &email, const std::string &name)
-{
-    std::string mailto;
-    if (!name.empty()) {
-        mailto.append(name);
-    }
-    mailto.append("<");
-    mailto.append(email);
-    mailto.append(">");
-    return QUrl(QString::fromStdString(std::string("mailto:")+mailto));
-}
-
-std::string fromMailto(const QUrl &mailtoUri, std::string &name)
-{
-    const std::string &decoded = toStdString(mailtoUri.toString());
-    if (decoded.substr(0, 7).compare("mailto:")) {
-        WARNING("no mailto address");
-        std::cout << decoded << std::endl;
-        return decoded;
-    }
-    std::size_t begin = decoded.find('<',7);
-    if (begin == std::string::npos) {
-        WARNING("no mailto address");
-        std::cout << decoded << std::endl;
-        return decoded;
-    }
-    std::size_t end = decoded.find('>', begin);
-    if (end == std::string::npos) {
-        WARNING("no mailto address");
-        std::cout << decoded << std::endl;
-        return decoded;
-    }
-    name = decoded.substr(7, begin-7);
-    const std::string &email = decoded.substr(begin+1, end-begin-1);
-    return email;
-}
-
-    }
-}
-
diff --git a/conversion/commonconversion.h b/conversion/commonconversion.h
deleted file mode 100644
index fd4c191..0000000
--- a/conversion/commonconversion.h
+++ /dev/null
@@ -1,55 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef KOLABCOMMONCONVERSION_H
-#define KOLABCOMMONCONVERSION_H
-
-#include "kolab_export.h"
-
-#include <kdatetime.h>
-#include <QStringList>
-#include <kolabcontainers.h>
-
-
-namespace Kolab {
-    namespace Conversion {
-        KOLAB_EXPORT KDateTime toDate(const Kolab::cDateTime &dt);
-        KOLAB_EXPORT cDateTime fromDate(const KDateTime &dt);
-        QStringList toStringList(const std::vector<std::string> &l);
-        std::vector<std::string> fromStringList(const QStringList &l);
-        /**
-         * Returns a UTC, Floating Time or Timezone
-         */
-        KDateTime::Spec getTimeSpec(bool isUtc, const std::string &timezone);
-
-        QUrl toMailto(const std::string &email, const std::string &name = std::string());
-        std::string fromMailto(const QUrl &mailtoUri, std::string &name);
-        
-        inline std::string toStdString(const QString &s)
-        {
-            return std::string(s.toUtf8().constData());
-        }
-
-        inline QString fromStdString(const std::string &s)
-        {
-            return QString::fromUtf8(s.c_str());
-        }
-
-    };
-};
-
-#endif
\ No newline at end of file
diff --git a/conversion/kabcconversion.cpp b/conversion/kabcconversion.cpp
deleted file mode 100644
index 76d9597..0000000
--- a/conversion/kabcconversion.cpp
+++ /dev/null
@@ -1,894 +0,0 @@
-/*
- * Copyright (C) 2011  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "kabcconversion.h"
-
-#include "commonconversion.h"
-#include <kdebug.h>
-#include <qbuffer.h>
-#include <qimagereader.h>
-#include "kolabformat/errorhandler.h"
-
-
-
-namespace Kolab {
-    namespace Conversion {
-        
-        //The following was copied from kdepim/libkleo/kleo/enum.h,.cpp
-        enum CryptoMessageFormat {
-            InlineOpenPGPFormat = 1,
-            OpenPGPMIMEFormat = 2,
-            SMIMEFormat = 4,
-            SMIMEOpaqueFormat = 8,
-            AnyOpenPGP = InlineOpenPGPFormat|OpenPGPMIMEFormat,
-            AnySMIME = SMIMEOpaqueFormat|SMIMEFormat,
-            AutoFormat = AnyOpenPGP|AnySMIME
-        };
-
-        enum EncryptionPreference {
-            UnknownPreference = 0,
-            NeverEncrypt = 1,
-            AlwaysEncrypt = 2,
-            AlwaysEncryptIfPossible = 3,
-            AlwaysAskForEncryption = 4,
-            AskWheneverPossible = 5,
-            MaxEncryptionPreference = AskWheneverPossible
-        };
-        
-        enum SigningPreference {
-            UnknownSigningPreference = 0,
-            NeverSign = 1,
-            AlwaysSign = 2,
-            AlwaysSignIfPossible = 3,
-            AlwaysAskForSigning = 4,
-            AskSigningWheneverPossible = 5,
-            MaxSigningPreference = AskSigningWheneverPossible
-        };
-        
-        static const struct {
-            CryptoMessageFormat format;
-            const char * displayName;
-            const char * configName;
-        } cryptoMessageFormats[] = {
-            { InlineOpenPGPFormat,
-            ("Inline OpenPGP (deprecated)"),
-            "inline openpgp" },
-            { OpenPGPMIMEFormat,
-            ("OpenPGP/MIME"),
-            "openpgp/mime" },
-            { SMIMEFormat,
-            ("S/MIME"),
-            "s/mime" },
-            { SMIMEOpaqueFormat,
-            ("S/MIME Opaque"),
-            "s/mime opaque" },
-        };
-        static const unsigned int numCryptoMessageFormats
-        = sizeof cryptoMessageFormats / sizeof *cryptoMessageFormats ;
-        
-        const char * cryptoMessageFormatToString( CryptoMessageFormat f ) {
-            if ( f == AutoFormat )
-                return "auto";
-            for ( unsigned int i = 0 ; i < numCryptoMessageFormats ; ++i )
-                if ( f == cryptoMessageFormats[i].format )
-                    return cryptoMessageFormats[i].configName;
-                return 0;
-        }
-        
-        QStringList cryptoMessageFormatsToStringList( unsigned int f ) {
-            QStringList result;
-            for ( unsigned int i = 0 ; i < numCryptoMessageFormats ; ++i )
-                if ( f & cryptoMessageFormats[i].format )
-                    result.push_back( cryptoMessageFormats[i].configName );
-                return result;
-        }
-        
-        
-        CryptoMessageFormat stringToCryptoMessageFormat( const QString & s ) {
-            const QString t = s.toLower();
-            for ( unsigned int i = 0 ; i < numCryptoMessageFormats ; ++i )
-                if ( t == cryptoMessageFormats[i].configName )
-                    return cryptoMessageFormats[i].format;
-                return AutoFormat;
-        }
-        
-        unsigned int stringListToCryptoMessageFormats( const QStringList & sl ) {
-            unsigned int result = 0;
-            for ( QStringList::const_iterator it = sl.begin() ; it != sl.end() ; ++it )
-                result |= stringToCryptoMessageFormat( *it );
-            return result;
-        }
-        
-        // For the config values used below, see also kaddressbook/editors/cryptowidget.cpp
-        
-        const char* encryptionPreferenceToString( EncryptionPreference pref )
-        {
-            switch( pref ) {
-                case UnknownPreference:
-                    return 0;
-                case NeverEncrypt:
-                    return "never";
-                case AlwaysEncrypt:
-                    return "always";
-                case AlwaysEncryptIfPossible:
-                    return "alwaysIfPossible";
-                case AlwaysAskForEncryption:
-                    return "askAlways";
-                case AskWheneverPossible:
-                    return "askWhenPossible";
-            }
-            return 0; // keep the compiler happy
-        }
-        
-        EncryptionPreference stringToEncryptionPreference( const QString& str )
-        {
-            if ( str == "never" )
-                return NeverEncrypt;
-            if ( str == "always" )
-                return AlwaysEncrypt;
-            if ( str == "alwaysIfPossible" )
-                return AlwaysEncryptIfPossible;
-            if ( str == "askAlways" )
-                return AlwaysAskForEncryption;
-            if ( str == "askWhenPossible" )
-                return AskWheneverPossible;
-            return UnknownPreference;
-        }
-        
-        const char* signingPreferenceToString( SigningPreference pref )
-        {
-            switch( pref ) {
-                case UnknownSigningPreference:
-                    return 0;
-                case NeverSign:
-                    return "never";
-                case AlwaysSign:
-                    return "always";
-                case AlwaysSignIfPossible:
-                    return "alwaysIfPossible";
-                case AlwaysAskForSigning:
-                    return "askAlways";
-                case AskSigningWheneverPossible:
-                    return "askWhenPossible";
-            }
-            return 0; // keep the compiler happy
-        }
-        
-        SigningPreference stringToSigningPreference( const QString& str )
-        {
-            if ( str == "never" )
-                return NeverSign;
-            if ( str == "always" )
-                return AlwaysSign;
-            if ( str == "alwaysIfPossible" )
-                return AlwaysSignIfPossible;
-            if ( str == "askAlways" )
-                return AlwaysAskForSigning;
-            if ( str == "askWhenPossible" )
-                return AskSigningWheneverPossible;
-            return UnknownSigningPreference;
-        }
-
-        
-        
-int fromAddressType(int kabcType, bool &pref)
-{
-    int type = 0;
-    if (kabcType & KABC::Address::Dom) {
-        Warning() << "domestic address is not supported";
-    } 
-    if (kabcType & KABC::Address::Intl) {
-        Warning() << "international address is not supported";
-    } 
-    if (kabcType & KABC::Address::Pref) {
-        pref = true;
-    } 
-    if (kabcType & KABC::Address::Postal) {
-        Warning() << "postal address is not supported";
-    } 
-    if (kabcType & KABC::Address::Parcel) {
-        Warning() << "parcel is not supported";
-    } 
-    if (kabcType & KABC::Address::Home) {
-        type |= Kolab::Address::Home;
-    } 
-    if (kabcType & KABC::Address::Work) {
-        type |= Kolab::Address::Work;
-    } 
-    return type;
-}
-
-KABC::Address::Type toAddressType(int types, bool pref)
-{
-    KABC::Address::Type type = 0;
-    if (pref) {
-        type |= KABC::Address::Pref;
-    } 
-    if (types & Kolab::Address::Home) {
-        type |= KABC::Address::Home;
-    } 
-    if (types & Kolab::Address::Work) {
-        type |= KABC::Address::Work;
-    } 
-    return type;
-}
-        
-int fromPhoneType(int kabcType, bool &pref)
-{
-    int type = 0;
-    if (kabcType & KABC::PhoneNumber::Home) {
-        type |= Kolab::Telephone::Home;
-    } 
-    if (kabcType & KABC::PhoneNumber::Work) {
-        type |= Kolab::Telephone::Work;
-    } 
-    if (kabcType & KABC::PhoneNumber::Msg) {
-        type |= Kolab::Telephone::Text;
-    } 
-    if (kabcType & KABC::PhoneNumber::Pref) {
-        pref = true;
-    } 
-    if (kabcType & KABC::PhoneNumber::Voice) {
-        type |= Kolab::Telephone::Voice;
-    } 
-    if (kabcType & KABC::PhoneNumber::Fax) {
-        type |= Kolab::Telephone::Fax;
-    } 
-    if (kabcType & KABC::PhoneNumber::Cell) {
-        type |= Kolab::Telephone::Cell;
-    } 
-    if (kabcType & KABC::PhoneNumber::Video) {
-        type |= Kolab::Telephone::Video;
-    } 
-    if (kabcType & KABC::PhoneNumber::Bbs) {
-        Warning() << "mailbox number is not supported";
-    } 
-    if (kabcType & KABC::PhoneNumber::Modem) {
-        Warning() << "modem is not supported";
-    } 
-    if (kabcType & KABC::PhoneNumber::Car) {
-        type |= Kolab::Telephone::Car;
-    } 
-    if (kabcType & KABC::PhoneNumber::Isdn) {
-        Warning() << "isdn number is not supported";
-    } 
-    if (kabcType & KABC::PhoneNumber::Pcs) {
-        type |= Kolab::Telephone::Text;
-    } 
-    if (kabcType & KABC::PhoneNumber::Pager) {
-        type |= Kolab::Telephone::Pager;
-    }
-    return type;
-}
-
-KABC::PhoneNumber::Type toPhoneType(int types, bool pref)
-{
-    KABC::PhoneNumber::Type type = 0;
-    if (types & Kolab::Telephone::Home) {
-        type |= KABC::PhoneNumber::Home;
-    } 
-    if (types & Kolab::Telephone::Work) {
-        type |= KABC::PhoneNumber::Work;
-    } 
-    if (types & Kolab::Telephone::Text) {
-        type |= KABC::PhoneNumber::Msg;
-    } 
-    if (pref) {
-        type |= KABC::PhoneNumber::Pref;
-    } 
-    if (types & Kolab::Telephone::Voice) {
-        type |= KABC::PhoneNumber::Voice;
-    } 
-    if (types & Kolab::Telephone::Fax) {
-        type |= KABC::PhoneNumber::Fax;
-    } 
-    if (types & Kolab::Telephone::Cell) {
-        type |= KABC::PhoneNumber::Cell;
-    } 
-    if (types & Kolab::Telephone::Video) {
-        type |= KABC::PhoneNumber::Video;
-    } 
-    if (types & Kolab::Telephone::Car) {
-        type |= KABC::PhoneNumber::Car;
-    } 
-    if (types & Kolab::Telephone::Text) {
-        type |= KABC::PhoneNumber::Pcs;
-    } 
-    if (types & Kolab::Telephone::Pager) {
-        type |= KABC::PhoneNumber::Pager;
-    }
-    return type;
-}
-
-std::string fromPicture(const KABC::Picture &pic, std::string &mimetype)
-{    
-    QByteArray input;
-    QBuffer buffer( &input );
-    buffer.open( QIODevice::WriteOnly );
-    QImage img;
-        
-    
-    if ( pic.isIntern() ) {
-        if ( !pic.data().isNull() ) {
-            img = pic.data();
-        }
-    } else if ( !pic.url().isEmpty() ) {
-        QString tmpFile;
-        kWarning() << "external pictures are currently not supported";
-        //FIXME add kio support to libcalendaring or use libcurl
-//         if ( KIO::NetAccess::download( pic.url(), tmpFile, 0 /*no widget known*/ ) ) {
-//             img.load( tmpFile );
-//             KIO::NetAccess::removeTempFile( tmpFile );
-//         }
-    }
-    if (img.isNull()) {
-        Error() << "invalid picture";
-        return std::string();
-    }
-    if ( !img.hasAlphaChannel() ) {
-        if (!img.save( &buffer, "JPEG" )) {
-            Error() << "error on jpeg save";
-            return std::string();
-        }
-        mimetype = "image/jpeg";
-    } else {
-        if (!img.save( &buffer, "PNG" )) {
-            Error() << "error on png save";
-            return std::string();
-        }
-        mimetype = "image/png";
-    }
-    return std::string(input.data(), input.size());
-}
-
-KABC::Picture toPicture(const std::string &data, const std::string &mimetype) {
-    QImage img;
-    bool ret = false;
-    QByteArray type(mimetype.data(), mimetype.size());
-    type = type.split('/').last(); // extract "jpeg" from "image/jpeg"
-    if (QImageReader::supportedImageFormats().contains(type)) {
-        ret = img.loadFromData(QByteArray::fromRawData(data.data(), data.size()), type.constData());
-    } else {
-        ret = img.loadFromData(QByteArray::fromRawData(data.data(), data.size()));
-    }
-    if (!ret) {
-        Warning() << "failed to load picture";
-        return KABC::Picture();
-    }
-    
-    KABC::Picture logo(img);
-    if (logo.isEmpty()) {
-        Warning() << "failed to read picture";
-        return KABC::Picture();
-    }
-    return logo;
-}
-
-template <typename T>
-void setCustom(const std::string &value, const std::string &id, T &object)
-{
-    std::vector <Kolab::CustomProperty > properties = object.customProperties();
-    properties.push_back(CustomProperty(id, value));
-    object.setCustomProperties(properties);
-}
-
-template <typename T>
-std::string getCustom(const std::string &id, T &object)
-{
-    const std::vector <Kolab::CustomProperty > &properties = object.customProperties();
-    foreach(const Kolab::CustomProperty &prop, properties) {
-        if (prop.identifier == id) {
-            return prop.value;
-        }
-    }
-    return std::string();
-}
-
-static QString emailTypesToStringList(int emailTypes) {
-    QStringList types;
-    if (emailTypes & Kolab::Email::Home) {
-        types << "home";
-    }
-    if (emailTypes & Kolab::Email::Work) {
-        types << "work";
-    }
-    return types.join(",");
-}
-
-static int emailTypesFromStringlist(const QString &types) {
-    int emailTypes = Kolab::Email::NoType;
-    if (types.contains("home")) {
-        emailTypes |= Kolab::Email::Home;
-    }
-    if (types.contains("work")) {
-        emailTypes |= Kolab::Email::Work;
-    }
-    return emailTypes;
-}
-
-KABC::Addressee toKABC(const Kolab::Contact &contact)
-{
-  KABC::Addressee addressee;
-  addressee.setUid(fromStdString(contact.uid()));
-  addressee.setCategories(toStringList(contact.categories()));
-  //addressee.setName(fromStdString(contact.name()));//This one is only for compatiblity (and results in a non-existing name property)
-  addressee.setFormattedName(fromStdString(contact.name())); //This on corresponds to fn
-  
-  const Kolab::NameComponents &nc = contact.nameComponents();
-  if (!nc.surnames().empty()) {
-      addressee.setFamilyName(fromStdString(nc.surnames().front()));
-  }
-  if (!nc.given().empty()) {
-      addressee.setGivenName(fromStdString(nc.given().front()));
-  }
-  if (!nc.additional().empty()) {
-      addressee.setAdditionalName(fromStdString(nc.additional().front()));
-  }
-  if (!nc.prefixes().empty()) {
-      addressee.setPrefix(fromStdString(nc.prefixes().front()));
-  }
-  if (!nc.suffixes().empty()) {
-      addressee.setSuffix(fromStdString(nc.suffixes().front()));
-  }
-  
-  addressee.setNote(fromStdString(contact.note()));
-  
-  addressee.setSecrecy(KABC::Secrecy::Public); //We don't have any privacy setting in xCard
-  
-  
-  QString preferredEmail;
-  
-  if (!contact.emailAddresses().empty()) {
-      QStringList emails;
-      foreach( const Kolab::Email &email, contact.emailAddresses()) {
-          emails << fromStdString(email.address());
-          const QString types = emailTypesToStringList(email.types());
-          if (!types.isEmpty()) {
-              addressee.insertCustom(QLatin1String("KOLAB"), QString::fromLatin1("EmailTypes%1").arg(fromStdString(email.address())), types);
-          }
-      }
-      addressee.setEmails(emails);
-      if ((contact.emailAddressPreferredIndex() >= 0) && (contact.emailAddressPreferredIndex() < static_cast<int>(contact.emailAddresses().size()))) {
-          preferredEmail = fromStdString(contact.emailAddresses().at(contact.emailAddressPreferredIndex()).address());
-      } else {
-          preferredEmail = fromStdString(contact.emailAddresses().at(0).address());
-      }
-      addressee.insertEmail(preferredEmail, true);
-  }
-  
-  if (!contact.freeBusyUrl().empty()) {
-      if (preferredEmail.isEmpty()) {
-          Error() << "f/b url is set but no email address available, skipping";
-      } else  {
-        addressee.insertCustom("KOLAB", "FreebusyUrl", fromStdString(contact.freeBusyUrl()));
-      }
-  }
-  
-  if (!contact.nickNames().empty()) {
-      addressee.setNickName(fromStdString(contact.nickNames().at(0))); //TODO support multiple
-  }
-  
-  if (contact.bDay().isValid()) {
-      addressee.setBirthday(toDate(contact.bDay()).dateTime());
-  }
-  if (!contact.titles().empty()) {
-      addressee.setTitle(fromStdString(contact.titles().at(0))); //TODO support multiple
-  }
-  if (!contact.urls().empty()) {
-      addressee.setUrl(fromStdString(contact.urls().at(0).url())); //TODO support multiple
-      foreach(const Kolab::Url &u, contact.urls()) {
-          if (u.type() == Kolab::Url::Blog) {
-              addressee.insertCustom("KADDRESSBOOK", "BlogFeed", fromStdString(u.url()));
-          }
-      }
-  }
-  
-
-  if (!contact.affiliations().empty()) {
-      //Storing only a const reference leads to segfaults. No idea why.
-      const Kolab::Affiliation aff = contact.affiliations().at(0); //TODO support multiple
-      if (!aff.organisation().empty()) {
-          addressee.setOrganization(fromStdString(aff.organisation()));
-      }
-      if (!aff.organisationalUnits().empty()) {
-          addressee.setDepartment(fromStdString(aff.organisationalUnits().at(0))); //TODO support multiple
-      }
-      if (!aff.roles().empty()) {
-          addressee.setRole(fromStdString(aff.roles().at(0))); //TODO support multiple
-      }
-      if (!aff.logo().empty()) {
-          addressee.setLogo(toPicture(aff.logo(), aff.logoMimetype()));
-      }
-      foreach(const Kolab::Related &related, aff.relateds()) {
-          if (related.type() != Kolab::Related::Text) {
-              Error() << "invalid relation type";
-              continue;
-          }
-          if (related.relationTypes() & Kolab::Related::Assistant) {
-              addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-AssistantsName"), fromStdString(related.text()));
-          }
-          if (related.relationTypes() & Kolab::Related::Manager) {
-              addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-ManagersName"), fromStdString(related.text()));
-          }
-      }
-      foreach(const Kolab::Address &address, aff.addresses()) {
-          addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Office"), fromStdString(address.label())); //TODO support proper addresses
-      }
-  }
-  const std::string &prof = getCustom("X-Profession", contact);
-  if (!prof.empty()) {
-    addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Profession"), fromStdString(prof));
-  }
-  
-  const std::string &adrBook = getCustom("X-AddressBook", contact);
-  if (!adrBook.empty()) {
-      addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-AddressBook"), fromStdString(prof));
-  }
-  
-  if (!contact.photo().empty()) {
-      addressee.setPhoto(toPicture(contact.photo(), contact.photoMimetype()));
-  }
-  
-  if (!contact.telephones().empty()) {
-      int index = 0;
-      foreach(const Kolab::Telephone &tel, contact.telephones()) {
-          bool pref = false;
-          if (index == contact.telephonesPreferredIndex()) {
-              pref = true;
-          }
-          KABC::PhoneNumber number(fromStdString(tel.number()), toPhoneType(tel.types(), pref));
-          index++;
-          addressee.insertPhoneNumber(number);
-      }
-  }
-  
-  if (!contact.addresses().empty()) {
-      int index = 0;
-      foreach(const Kolab::Address &a, contact.addresses()) {
-          bool pref = false;
-          if (index == contact.addressPreferredIndex()) {
-              pref = true;
-          }
-          KABC::Address adr(toAddressType(a.types(), pref));          
-          adr.setLabel(fromStdString(a.label()));
-          adr.setStreet(fromStdString(a.street()));
-          adr.setLocality(fromStdString(a.locality()));
-          adr.setRegion(fromStdString(a.region()));
-          adr.setPostalCode(fromStdString(a.code()));
-          adr.setCountry(fromStdString(a.country()));
-          
-          index++;
-          addressee.insertAddress(adr);
-      }
-  }
-  
-  if (contact.anniversary().isValid()) {
-      addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Anniversary"), toDate(contact.anniversary()).toString(KDateTime::ISODate));
-  }
-  
-  if (!contact.imAddresses().empty()) {
-      addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-IMAddress"),fromStdString(contact.imAddresses()[0])); //TODO support multiple
-  }
-  
-  if (!contact.relateds().empty()) {
-      foreach(const Kolab::Related &rel, contact.relateds()) {
-          if (rel.type() != Kolab::Related::Text) {
-              Error() << "relation type not supported";
-              continue;
-          }
-          if (rel.relationTypes() & Kolab::Related::Spouse) {
-              addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-SpousesName"),fromStdString(rel.text())); //TODO support multiple
-          } else {
-              Warning() << "relation not supported";
-              continue;
-          }
-      }
-  }
-  
-  return addressee;
-}
-
-Kolab::Contact fromKABC(const KABC::Addressee &addressee)
-{
-    int prefNum = -1;
-    int prefCounter = -1;
-    Kolab::Contact c;
-    c.setUid(toStdString(addressee.uid()));
-    c.setCategories(fromStringList(addressee.categories()));
-    c.setName(toStdString(addressee.formattedName()));
-    Kolab::NameComponents nc;
-    nc.setSurnames(std::vector<std::string>() << toStdString(addressee.familyName()));
-    nc.setGiven(std::vector<std::string>() << toStdString(addressee.givenName()));
-    nc.setAdditional(std::vector<std::string>() << toStdString(addressee.additionalName()));
-    nc.setPrefixes(std::vector<std::string>() << toStdString(addressee.prefix()));
-    nc.setSuffixes(std::vector<std::string>() << toStdString(addressee.suffix()));
-    c.setNameComponents(nc);
-    
-    c.setNote(toStdString(addressee.note()));
-    c.setFreeBusyUrl(toStdString(addressee.custom("KOLAB", QString("FreebusyUrl"))));
-
-    if (!addressee.title().isEmpty()) {
-        c.setTitles(std::vector<std::string>() << toStdString(addressee.title()));
-    }
-    
-    Kolab::Affiliation businessAff;
-    businessAff.setOrganisation(toStdString(addressee.organization()));
-    if (!addressee.department().isEmpty()) {
-        Debug() << addressee.department() << addressee.department().toLatin1() << addressee.department().toUtf8();
-        businessAff.setOrganisationalUnits(std::vector<std::string>() << toStdString(addressee.department()));
-    }
-
-    if (!addressee.logo().isEmpty()) {
-        std::string logoMimetype;
-        const std::string &logo = fromPicture(addressee.logo(), logoMimetype);
-        businessAff.setLogo(logo, logoMimetype);
-    }
-    if (!addressee.role().isEmpty()) {
-        businessAff.setRoles(std::vector<std::string>() << toStdString(addressee.role()));
-    }
-    const QString &office = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Office"));
-    if (!office.isEmpty()) {
-        Kolab::Address a;
-        a.setTypes(Kolab::Address::Work);
-        a.setLabel(toStdString(addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Office"))));
-        businessAff.setAddresses(std::vector<Kolab::Address>() << a);
-    }
-    
-    std::vector<Kolab::Related> relateds;
-    const QString &manager = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-ManagersName"));
-    if (!manager.isEmpty()) {
-        relateds.push_back(Kolab::Related(Kolab::Related::Text, toStdString(manager), Kolab::Related::Manager));
-    }
-    const QString &assistant = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-AssistantsName"));
-    if (!assistant.isEmpty()) {
-        relateds.push_back(Kolab::Related(Kolab::Related::Text, toStdString(assistant), Kolab::Related::Assistant));
-    }
-    if (!relateds.empty()) {
-        businessAff.setRelateds(relateds);
-    }
-    if (!(businessAff == Kolab::Affiliation())) {
-        c.setAffiliations(std::vector<Kolab::Affiliation>() << businessAff);
-    }
-    
-    std::vector<Kolab::Url> urls;
-    if (!addressee.url().isEmpty()) {
-        urls.push_back(Kolab::Url(toStdString(addressee.url().url())));
-    }   
-    const QString &blogUrl = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("BlogFeed"));
-    if (!blogUrl.isEmpty()) {
-        urls.push_back(Kolab::Url(toStdString(blogUrl), Kolab::Url::Blog));
-    }
-    c.setUrls(urls);
-    
-    std::vector<Kolab::Address> addresses;
-    prefNum = -1;
-    prefCounter = -1;
-    foreach(const KABC::Address &a, addressee.addresses()) {
-        Kolab::Address adr;
-        bool pref = false;
-        adr.setTypes(fromAddressType(a.type(), pref));
-        prefCounter++;
-        if (pref) {
-            prefNum = prefCounter;
-        }
-        adr.setLabel(toStdString(a.label()));
-        adr.setStreet(toStdString(a.street()));
-        adr.setLocality(toStdString(a.locality()));
-        adr.setRegion(toStdString(a.region()));
-        adr.setCode(toStdString(a.postalCode()));
-        adr.setCountry(toStdString(a.country()));
-        addresses.push_back(adr);
-    }
-    c.setAddresses(addresses, prefNum);
-    
-    if (!addressee.nickName().isEmpty()) {
-        c.setNickNames(std::vector<std::string>() << toStdString(addressee.nickName()));
-    }
-    
-    const QString &spouse = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-SpousesName"));
-    if (!spouse.isEmpty()) {
-        c.setRelateds(std::vector<Kolab::Related>() << Kolab::Related(Kolab::Related::Text, toStdString(spouse), Kolab::Related::Spouse));
-    }
-    c.setBDay(fromDate(KDateTime(addressee.birthday(), KDateTime::ClockTime)));
-    c.setAnniversary(fromDate(KDateTime(QDate::fromString( addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Anniversary")), Qt::ISODate ), KDateTime::ClockTime)));
-    if (!addressee.photo().isEmpty()) {
-        std::string mimetype;
-        const std::string &photo = fromPicture(addressee.photo(), mimetype);
-        c.setPhoto(photo, mimetype);
-    }
-    //TODO
-//     c.setGender();
-//     c.setLanguages();
-
-    std::vector <Kolab::Telephone> phones;
-    prefNum = -1;
-    prefCounter = -1;
-    foreach (const KABC::PhoneNumber &n, addressee.phoneNumbers()) {
-        Kolab::Telephone p;
-        p.setNumber(toStdString(n.number()));
-        bool pref = false;
-        p.setTypes(fromPhoneType(n.type(), pref));
-        prefCounter++;
-        if (pref) {
-            prefNum = prefCounter;
-        }
-        phones.push_back(p);
-    }
-    c.setTelephones(phones, prefNum);
-    
-    const QString &imAddress = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-IMAddress"));
-    if (!imAddress.isEmpty()) {
-        c.setIMaddresses(std::vector<std::string>() << toStdString(imAddress), 0);
-    }
-    
-    int prefEmail = -1;
-    int count = 0;
-    std::vector<Kolab::Email> emails;
-    foreach(const QString &e, addressee.emails()) {
-        if ((prefEmail == -1) && (e == addressee.preferredEmail())) {
-            prefEmail = count;
-        }
-        count++;
-        emails.push_back(Kolab::Email(toStdString(e), emailTypesFromStringlist(addressee.custom(QLatin1String("KOLAB"), QString::fromLatin1("EmailTypes%1").arg(e)))));
-    }
-    c.setEmailAddresses(emails, prefEmail);
-    if (addressee.geo().isValid()) {
-        c.setGPSpos(std::vector<Kolab::Geo>() << Kolab::Geo(addressee.geo().latitude(), addressee.geo().longitude()));
-    }
-    
-    Kolab::Crypto crypto;
-    
-    const QStringList protocolPrefs = addressee.custom( "KADDRESSBOOK", "CRYPTOPROTOPREF" ).split( ',', QString::SkipEmptyParts );
-    const uint cryptoFormats = stringListToCryptoMessageFormats( protocolPrefs );
-    int formats = 0;
-    if (cryptoFormats & InlineOpenPGPFormat) {
-        formats |= Kolab::Crypto::PGPinline;
-    }
-    if (cryptoFormats & OpenPGPMIMEFormat) {
-        formats |= Kolab::Crypto::PGPmime;
-    }
-    if (cryptoFormats & SMIMEFormat) {
-        formats |= Kolab::Crypto::SMIME;
-    }
-    if (cryptoFormats & SMIMEOpaqueFormat) {
-        formats |= Kolab::Crypto::SMIMEopaque;
-    }
-    crypto.setAllowed(formats);
-    
-    Kolab::Crypto::CryptoPref signPref = Kolab::Crypto::Ask;
-    switch (stringToSigningPreference(addressee.custom( "KADDRESSBOOK", "CRYPTOSIGNPREF" ) )) {
-        case NeverSign:
-            signPref = Kolab::Crypto::Never;
-            break;
-        case AlwaysSign:
-            signPref = Kolab::Crypto::Always;
-            break;
-        case AlwaysSignIfPossible:
-            signPref = Kolab::Crypto::IfPossible;
-            break;
-        case AlwaysAskForSigning:
-        case AskSigningWheneverPossible:
-            signPref = Kolab::Crypto::Ask;
-            break;
-        default:
-            signPref = Kolab::Crypto::Ask;
-    }
-    crypto.setSignPref(signPref);
-    
-    Kolab::Crypto::CryptoPref encryptPref = Kolab::Crypto::Ask;
-    switch (stringToSigningPreference(addressee.custom( "KADDRESSBOOK", "CRYPTOENCRYPTPREF" ) )) {
-        case NeverEncrypt:
-            encryptPref = Kolab::Crypto::Never;
-            break;
-        case AlwaysEncrypt:
-            encryptPref = Kolab::Crypto::Always;
-            break;
-        case AlwaysEncryptIfPossible:
-            encryptPref = Kolab::Crypto::IfPossible;
-            break;
-        case AlwaysAskForEncryption:
-        case AskWheneverPossible:
-            encryptPref = Kolab::Crypto::Ask;
-            break;
-        default:
-            encryptPref = Kolab::Crypto::Ask;
-    }
-    crypto.setEncryptPref(encryptPref);
-    
-    c.setCrypto(crypto);
-    
-    
-    //FIXME the keys are most certainly worng, look at cryptopageplugin.cpp
-    std::vector<Kolab::Key> keys;
-    const std::string &pgpkey = toStdString(addressee.custom( "KADDRESSBOOK", "OPENPGPFP" ));
-    if (!pgpkey.empty()) {
-        keys.push_back(Kolab::Key(pgpkey, Kolab::Key::PGP));
-    }
-    const std::string &smimekey = toStdString(addressee.custom( "KADDRESSBOOK", "SMIMEFP" ));
-    if (!smimekey.empty()) {
-        keys.push_back(Kolab::Key(smimekey, Kolab::Key::PKCS7_MIME));
-    }
-    c.setKeys(keys);
-    
-    
-    if (!addressee.sound().isEmpty()) {
-        Warning() << "sound is not supported";
-    }
-    
-    const std::string &profession = toStdString(addressee.custom( "KADDRESSBOOK", "X-Profession" ));
-    if (!profession.empty()) {
-        setCustom(profession, "X-Profession", c);
-    }
-    
-    const std::string &adrBook = toStdString(addressee.custom( "KADDRESSBOOK", "X-AddressBook" ));
-    if (!adrBook.empty()) {
-        setCustom(adrBook, "X-AddressBook", c);
-    }
-    
-    //TODO preserve all custom properties (also such which are unknown to us)
-        
-    return c;
-}
-
-DistList fromKABC(const KABC::ContactGroup &cg)
-{
-    DistList dl;
-    dl.setName(toStdString(cg.name()));
-    dl.setUid(toStdString(cg.id()));
-    
-    std::vector <Kolab::ContactReference > members;
-    for (unsigned int i = 0; i < cg.dataCount(); i++) {
-        const KABC::ContactGroup::Data &data = cg.data(i);
-        members.push_back(Kolab::ContactReference(Kolab::ContactReference::EmailReference, toStdString(data.email()), toStdString(data.name())));
-    }
-    for (unsigned int i = 0; i < cg.contactReferenceCount(); i++) {
-        const KABC::ContactGroup::ContactReference &ref = cg.contactReference(i);
-        members.push_back(Kolab::ContactReference(Kolab::ContactReference::UidReference, toStdString(ref.uid())));
-    }
-    
-    if (cg.contactGroupReferenceCount() > 0) {
-        kWarning() << "Tried to save contact group references, which should have been resolved already";
-    }
-    
-    dl.setMembers(members);
-    
-    return dl;
-}
-
-KABC::ContactGroup toKABC(const DistList &dl)
-{
-    KABC::ContactGroup cg(fromStdString(dl.name()));
-    cg.setId(fromStdString(dl.uid()));
-    foreach(const Kolab::ContactReference &m, dl.members()) {
-        switch (m.type()) {
-            case Kolab::ContactReference::EmailReference:
-                cg.append(KABC::ContactGroup::Data(fromStdString(m.name()), fromStdString(m.email())));
-                break;
-            case Kolab::ContactReference::UidReference:
-                cg.append(KABC::ContactGroup::ContactReference(fromStdString(m.uid())));
-                break;
-            default:
-                Error() << "invalid contact reference";
-        }
-    }
-    
-    return cg;
-}
-
-
-    } //Namespace
-} //Namespace
diff --git a/conversion/kabcconversion.h b/conversion/kabcconversion.h
deleted file mode 100644
index 0b7863a..0000000
--- a/conversion/kabcconversion.h
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef KOLABKABCCONVERSION_H
-#define KOLABKABCCONVERSION_H
-
-#include "kolab_export.h"
-
-#include <kolabcontact.h>
-#include <kabc/addressee.h>
-#include <kabc/contactgroup.h>
-
-namespace Kolab {
-    /**
-     * Conversion of Kolab-Containers to/from KABC Containers.
-     *
-     */
-    namespace Conversion {
-
-        KOLAB_EXPORT KABC::Addressee toKABC(const Kolab::Contact &);
-        KOLAB_EXPORT Kolab::Contact fromKABC(const KABC::Addressee &);
-        
-        KOLAB_EXPORT KABC::ContactGroup toKABC(const Kolab::DistList &);
-        KOLAB_EXPORT Kolab::DistList fromKABC(const KABC::ContactGroup &);
-
-    };
-};
-
-#endif
diff --git a/conversion/kcalconversion.cpp b/conversion/kcalconversion.cpp
deleted file mode 100644
index a82b6a2..0000000
--- a/conversion/kcalconversion.cpp
+++ /dev/null
@@ -1,858 +0,0 @@
-/*
- * Copyright (C) 2011  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#include "kcalconversion.h"
-
-#include <kcalcore/recurrence.h>
-#include <QtCore/QBitArray>
-#include <QtCore/QVector>
-#include <QtCore/QDebug>
-#include <QUrl>
-#include <vector>
-
-#include "kolabformat/errorhandler.h"
-#include "commonconversion.h"
-
-namespace Kolab {
-    namespace Conversion {
-
-//The uid of a contact which refers to the uuid of a contact in the addressbook
-#define CUSTOM_KOLAB_CONTACT_UUID "X_KOLAB_CONTACT_UUID"
-#define CUSTOM_KOLAB_CONTACT_CUTYPE "X_KOLAB_CONTACT_CUTYPE"
-#define CUSTOM_KOLAB_URL "X-KOLAB-URL"
-
-KCalCore::Duration toDuration(const Kolab::Duration &d)
-{
-    int value = 0;
-    if (d.hours() || d.minutes() || d.seconds()) {
-        value = ((((d.weeks() * 7 + d.days()) * 24 + d.hours()) * 60 + d.minutes()) * 60 + d.seconds());
-        if (d.isNegative()) {
-            value = -value;
-        }
-        return KCalCore::Duration(value);
-    }
-    value = d.weeks() * 7 + d.days();
-    if (d.isNegative()) {
-        value = -value;
-    }
-    return KCalCore::Duration(value, KCalCore::Duration::Days);
-}
-
-Kolab::Duration fromDuration(const KCalCore::Duration &d)
-{
-    int value = d.value();
-    bool isNegative = false;
-    if (value < 0) {
-        isNegative = true;
-        value = -value;
-    }
-    //We don't know how the seconds/days were distributed before, so no point in distributing them (probably)
-    if (d.isDaily()) {
-        int days = value;
-        return Kolab::Duration(days, 0, 0, 0, isNegative);
-    }
-    int seconds = value;
-//         int minutes = seconds / 60;
-//         seconds = seconds % 60;
-//         int hours = minutes / 60;
-//         minutes = minutes % 60;
-    return Kolab::Duration(0, 0, 0, seconds, isNegative);
-
-}
-
-KCalCore::Incidence::Secrecy toSecrecy(Kolab::Classification c)
-{
-    switch(c) {
-        case Kolab::ClassPublic:
-            return KCalCore::Incidence::SecrecyPublic;
-        case Kolab::ClassPrivate:
-            return KCalCore::Incidence::SecrecyPrivate;
-        case Kolab::ClassConfidential:
-            return KCalCore::Incidence::SecrecyConfidential;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return KCalCore::Incidence::SecrecyPublic;
-}
-
-Kolab::Classification fromSecrecy(KCalCore::Incidence::Secrecy c)
-{
-    switch(c) {
-        case KCalCore::Incidence::SecrecyPublic:
-            return Kolab::ClassPublic;
-        case KCalCore::Incidence::SecrecyPrivate:
-            return Kolab::ClassPrivate;
-        case KCalCore::Incidence::SecrecyConfidential:
-            return Kolab::ClassConfidential;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return Kolab::ClassPublic;
-}
-
-int toPriority(int priority)
-{
-    //Same mapping
-    return priority;
-}
-
-int fromPriority(int priority)
-{
-    //Same mapping
-    return priority;
-}
-
-KCalCore::Incidence::Status toStatus(Kolab::Status s)
-{
-    switch (s) {
-        case StatusUndefined:
-            return  KCalCore::Incidence::StatusNone;
-        case StatusNeedsAction:
-            return  KCalCore::Incidence::StatusNeedsAction;
-        case StatusCompleted:
-            return  KCalCore::Incidence::StatusCompleted;
-        case StatusInProcess:
-            return  KCalCore::Incidence::StatusInProcess;
-        case StatusCancelled:
-            return  KCalCore::Incidence::StatusCanceled;
-        case StatusTentative:
-            return  KCalCore::Incidence::StatusTentative;
-        case StatusConfirmed:
-            return  KCalCore::Incidence::StatusConfirmed;
-        case StatusDraft:
-            return  KCalCore::Incidence::StatusDraft;
-        case StatusFinal:
-            return  KCalCore::Incidence::StatusFinal;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return KCalCore::Incidence::StatusNone;
-}
-
-Kolab::Status fromStatus(KCalCore::Incidence::Status s)
-{
-    switch (s) {
-        case KCalCore::Incidence::StatusNone:
-            return StatusUndefined;
-        case KCalCore::Incidence::StatusNeedsAction:
-            return StatusNeedsAction;
-        case KCalCore::Incidence::StatusCompleted:
-            return StatusCompleted;
-        case KCalCore::Incidence::StatusInProcess:
-            return StatusInProcess;
-        case KCalCore::Incidence::StatusCanceled:
-            return StatusCancelled;
-        case KCalCore::Incidence::StatusTentative:
-            return StatusTentative;
-        case KCalCore::Incidence::StatusConfirmed:
-            return StatusConfirmed;
-        case KCalCore::Incidence::StatusDraft:
-            return StatusDraft;
-        case KCalCore::Incidence::StatusFinal:
-            return StatusFinal;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return StatusUndefined;
-}
-
-KCalCore::Attendee::PartStat toPartStat(Kolab::PartStatus p)
-{
-    switch (p) {
-        case PartNeedsAction:
-            return KCalCore::Attendee::NeedsAction;
-        case PartAccepted:
-            return KCalCore::Attendee::Accepted;
-        case PartDeclined:
-            return KCalCore::Attendee::Declined;
-        case PartTentative:
-            return KCalCore::Attendee::Tentative;
-        case PartDelegated:
-            return KCalCore::Attendee::Delegated;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return KCalCore::Attendee::NeedsAction;
-}
-
-Kolab::PartStatus fromPartStat(KCalCore::Attendee::PartStat p)
-{
-    switch (p) {
-        case KCalCore::Attendee::NeedsAction:
-            return PartNeedsAction;
-        case KCalCore::Attendee::Accepted:
-            return PartAccepted;
-        case KCalCore::Attendee::Declined:
-            return PartDeclined;
-        case KCalCore::Attendee::Tentative:
-            return PartTentative;
-        case KCalCore::Attendee::Delegated:
-            return PartDelegated;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return PartNeedsAction;
-}
-
-KCalCore::Attendee::Role toRole(Kolab::Role r)
-{
-    switch (r) {
-        case Required:
-            return KCalCore::Attendee::ReqParticipant;
-        case Chair:
-            return KCalCore::Attendee::Chair;
-        case Optional:
-            return KCalCore::Attendee::OptParticipant;
-        case NonParticipant:
-            return KCalCore::Attendee::NonParticipant;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return KCalCore::Attendee::ReqParticipant;
-}
-
-Kolab::Role fromRole(KCalCore::Attendee::Role r)
-{
-    switch (r) {
-        case KCalCore::Attendee::ReqParticipant:
-            return Required;
-        case KCalCore::Attendee::Chair:
-            return Chair;
-        case KCalCore::Attendee::OptParticipant:
-            return Optional;
-        case KCalCore::Attendee::NonParticipant:
-            return NonParticipant;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return Required;
-}
-
-template <typename T>
-QString getCustomProperty(const QString &id, const T &e)
-{
-    std::vector<CustomProperty> &props = e.customProperties();
-    foreach (const CustomProperty &p, props) {
-        if (fromStdString(p.identifier) == id) {
-            return fromStdString(p.value);
-        }
-    }
-}
-
-template <typename T>
-void setIncidence(KCalCore::Incidence &i, const T &e)
-{
-    if (!e.uid().empty()) {
-        i.setUid(fromStdString(e.uid()));
-    }
-    
-    i.setCreated(toDate(e.created()));
-    i.setLastModified(toDate(e.lastModified()));
-    i.setRevision(e.sequence());
-    i.setSecrecy(toSecrecy(e.classification()));
-    i.setCategories(toStringList(e.categories()));
-    
-    if (e.start().isValid()) {
-        i.setDtStart(toDate(e.start()));
-    }
-
-    i.setSummary(fromStdString(e.summary())); //TODO detect richtext
-    i.setDescription(fromStdString(e.description())); //TODO detect richtext
-    i.setStatus(toStatus(e.status()));
-    foreach (const Kolab::Attendee a, e.attendees()) {
-        /*
-         * KCalCore always sets a UID if empty, but that's just a pointer, and not the uid of a real contact.
-         * Since that means the semantics of the two are different, we have to store the kolab uid as a custom property.
-         */
-        KCalCore::Attendee::Ptr attendee = KCalCore::Attendee::Ptr(new KCalCore::Attendee(fromStdString(a.contact().name()), 
-                                                                                          fromStdString(a.contact().email()),
-                                                                                          a.rsvp(),
-                                                                                          toPartStat(a.partStat()),
-                                                                                          toRole(a.role()) ));
-        if (!a.contact().uid().empty()) { //TODO Identify contact from addressbook based on uid
-            attendee->customProperties().setNonKDECustomProperty(CUSTOM_KOLAB_CONTACT_UUID, fromStdString(a.contact().uid()));
-        }
-        if (!a.delegatedTo().empty()) {
-            if (a.delegatedTo().size() > 1) {
-                WARNING("multiple delegatees are not supported");
-            }
-            attendee->setDelegate(toMailto(a.delegatedTo().front().email(), a.delegatedTo().front().name()).toString());
-        }
-        if (!a.delegatedFrom().empty()) {
-            if (a.delegatedFrom().size() > 1) {
-                WARNING("multiple delegators are not supported");
-            }
-            attendee->setDelegator(toMailto(a.delegatedFrom().front().email(), a.delegatedFrom().front().name()).toString());
-        }
-        if (!a.cutype() != CutypeIndividual) {
-            attendee->customProperties().setNonKDECustomProperty(CUSTOM_KOLAB_CONTACT_CUTYPE, QString::number(a.cutype()));
-        }
-        i.addAttendee(attendee);
-    }
-    foreach (const Kolab::Attachment a, e.attachments()) {
-        KCalCore::Attachment::Ptr ptr;
-        if (!a.uri().empty()) {
-            ptr = KCalCore::Attachment::Ptr(new KCalCore::Attachment(fromStdString(a.uri()), fromStdString(a.mimetype())));
-        } else {
-            ptr = KCalCore::Attachment::Ptr(new KCalCore::Attachment(QByteArray::fromRawData(a.data().c_str(), a.data().size()), fromStdString(a.mimetype())));
-        }
-        if (!a.label().empty()) {
-            ptr->setLabel(fromStdString(a.label()));
-        }
-        i.addAttachment(ptr);
-    }
-
-    QMap<QByteArray, QString> props;
-    foreach (const Kolab::CustomProperty &prop, e.customProperties()) {
-        QString key;
-        if (prop.identifier.compare(0, 5, "X-KDE")) {
-            key.append(QString::fromLatin1("X-KOLAB-"));
-        }
-        key.append(fromStdString(prop.identifier));
-        props.insert(key.toLatin1(), fromStdString(prop.value));
-//         i.setCustomProperty("KOLAB", fromStdString(prop.identifier).toLatin1(), fromStdString(prop.value));
-    }
-    i.setCustomProperties(props);
-}
-
-template <typename T, typename I>
-void getIncidence(T &i, const I &e)
-{
-    i.setUid(toStdString(e.uid()));
-    i.setCreated(fromDate(e.created()));
-    i.setLastModified(fromDate(e.lastModified()));
-    i.setSequence(e.revision());
-    i.setClassification(fromSecrecy(e.secrecy()));
-    i.setCategories(fromStringList(e.categories()));
-    
-    i.setStart(fromDate(e.dtStart()));
-    i.setSummary(toStdString(e.summary()));
-    i.setDescription(toStdString(e.description()));
-    i.setStatus(fromStatus(e.status()));
-    std::vector<Kolab::Attendee> attendees;
-    foreach (const KCalCore::Attendee::Ptr ptr, e.attendees()) {
-        const QString &uid = ptr->customProperties().nonKDECustomProperty(CUSTOM_KOLAB_CONTACT_UUID);
-        Kolab::Attendee a(Kolab::ContactReference(toStdString(ptr->email()), toStdString(ptr->name()), toStdString(uid)));
-        a.setRSVP(ptr->RSVP());
-        a.setPartStat(fromPartStat(ptr->status()));
-        a.setRole(fromRole(ptr->role()));
-        if (!ptr->delegate().isEmpty()) {
-            std::string name;
-            const std::string &email = fromMailto(ptr->delegate(), name);
-            a.setDelegatedTo(std::vector<Kolab::ContactReference>() << Kolab::ContactReference(email, name));
-        }
-        if (!ptr->delegator().isEmpty()) {
-            std::string name;
-            const std::string &email = fromMailto(ptr->delegator(), name);
-            a.setDelegatedFrom(std::vector<Kolab::ContactReference>() << Kolab::ContactReference(email, name));
-        }
-        const QString &cutype = ptr->customProperties().nonKDECustomProperty(CUSTOM_KOLAB_CONTACT_CUTYPE);
-        if (!cutype.isEmpty()) {
-            a.setCutype(static_cast<Kolab::Cutype>(cutype.toInt()));
-        }
-        
-        attendees.push_back(a);
-    }
-    i.setAttendees(attendees);
-    std::vector<Kolab::Attachment> attachments;
-    foreach (const KCalCore::Attachment::Ptr &ptr, e.attachments()) {
-        Kolab::Attachment a;
-        if (ptr->isUri()) {
-            a.setUri(toStdString(ptr->uri()), toStdString(ptr->mimeType()));
-        } else {
-            a.setData(std::string(ptr->decodedData().data(), ptr->decodedData().size()), toStdString(ptr->mimeType()));
-        }
-        a.setLabel(toStdString(ptr->label()));
-        attachments.push_back(a);
-    }
-    i.setAttachments(attachments);
-
-    std::vector<Kolab::CustomProperty> customProperties;
-    const QMap<QByteArray, QString> &props = e.customProperties();
-    for (QMap<QByteArray, QString>::const_iterator it = props.begin(); it != props.end(); it++) {
-        QString key(it.key());
-        if (key == QLatin1String(CUSTOM_KOLAB_URL)) {
-            continue;
-        }
-        customProperties.push_back(Kolab::CustomProperty(toStdString(key.remove("X-KOLAB-")), toStdString(it.value())));
-    }
-    i.setCustomProperties(customProperties);
-}
-
-int toWeekDay(Kolab::Weekday wday)
-{
-    switch (wday) {
-        case Kolab::Monday:
-            return  1;
-        case Kolab::Tuesday:
-            return 2;
-        case Kolab::Wednesday:
-            return 3;
-        case Kolab::Thursday:
-            return 4;
-        case Kolab::Friday:
-            return 5;
-        case Kolab::Saturday:
-            return 6;
-        case Kolab::Sunday:
-            return 7;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return 1;
-}
-
-Kolab::Weekday fromWeekDay(int wday)
-{
-    switch (wday) {
-        case 1:
-            return Kolab::Monday;
-        case 2:
-            return Kolab::Tuesday;
-        case 3:
-            return Kolab::Wednesday;
-        case 4:
-            return Kolab::Thursday;
-        case 5:
-            return Kolab::Friday;
-        case 6:
-            return Kolab::Saturday;
-        case 7:
-            return Kolab::Sunday;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return Kolab::Monday;
-}
-
-KCalCore::RecurrenceRule::PeriodType toRecurrenceType(Kolab::RecurrenceRule::Frequency freq)
-{
-    switch(freq) {
-        case Kolab::RecurrenceRule::FreqNone:
-            Warning() << "no recurrence?";
-            break;
-        case Kolab::RecurrenceRule::Yearly:
-            return KCalCore::RecurrenceRule::rYearly;
-        case Kolab::RecurrenceRule::Monthly:
-            return KCalCore::RecurrenceRule::rMonthly;
-        case Kolab::RecurrenceRule::Weekly:
-            return KCalCore::RecurrenceRule::rWeekly;
-        case Kolab::RecurrenceRule::Daily:
-            return KCalCore::RecurrenceRule::rDaily;
-        case Kolab::RecurrenceRule::Hourly:
-            return KCalCore::RecurrenceRule::rHourly;
-        case Kolab::RecurrenceRule::Minutely:
-            return KCalCore::RecurrenceRule::rMinutely;
-        case Kolab::RecurrenceRule::Secondly:
-            return KCalCore::RecurrenceRule::rSecondly;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return KCalCore::RecurrenceRule::rNone;
-}
-
-Kolab::RecurrenceRule::Frequency fromRecurrenceType(KCalCore::RecurrenceRule::PeriodType freq)
-{
-    switch(freq) {
-        case KCalCore::RecurrenceRule::rNone:
-            Warning() << "no recurrence?";
-            break;
-        case KCalCore::RecurrenceRule::rYearly:
-            return Kolab::RecurrenceRule::Yearly;
-        case KCalCore::RecurrenceRule::rMonthly:
-            return Kolab::RecurrenceRule::Monthly;
-        case KCalCore::RecurrenceRule::rWeekly:
-            return Kolab::RecurrenceRule::Weekly;
-        case KCalCore::RecurrenceRule::rDaily:
-            return Kolab::RecurrenceRule::Daily;
-        case KCalCore::RecurrenceRule::rHourly:
-            return Kolab::RecurrenceRule::Hourly;
-        case KCalCore::RecurrenceRule::rMinutely:
-            return Kolab::RecurrenceRule::Minutely;
-        case KCalCore::RecurrenceRule::rSecondly:
-            return Kolab::RecurrenceRule::Secondly;
-        default:
-            Error() << "unhandled";
-            Q_ASSERT(0);
-    }
-    return Kolab::RecurrenceRule::FreqNone;
-}
-
-KCalCore::RecurrenceRule::WDayPos toWeekDayPos(const Kolab::DayPos &dp)
-{
-    return KCalCore::RecurrenceRule::WDayPos(dp.occurence(), toWeekDay(dp.weekday()));
-}
-
-Kolab::DayPos fromWeekDayPos(const KCalCore::RecurrenceRule::WDayPos &dp)
-{
-    return Kolab::DayPos(dp.pos(), fromWeekDay(dp.day()));
-}
-
-template <typename T>
-void setRecurrence(KCalCore::Incidence &e, const T &event)
-{
-    const Kolab::RecurrenceRule &rrule = event.recurrenceRule();
-    if (rrule.isValid()) {
-        KCalCore::Recurrence *rec = e.recurrence();
-        
-        KCalCore::RecurrenceRule *defaultRR = rec->defaultRRule(true);
-        Q_ASSERT(defaultRR);
-        
-        defaultRR->setWeekStart(toWeekDay(rrule.weekStart()));
-        defaultRR->setRecurrenceType(toRecurrenceType(rrule.frequency()));
-        defaultRR->setFrequency(rrule.interval());
-        
-        if (rrule.end().isValid()) {
-            rec->setEndDateTime(toDate(rrule.end())); //TODO date/datetime setEndDate(). With date-only the start date has to be taken into account.
-        } else {
-            rec->setDuration(rrule.count());
-        }
-        
-        if (!rrule.bysecond().empty()) {
-            defaultRR->setBySeconds(QVector<int>::fromStdVector(rrule.bysecond()).toList());
-        }
-        if (!rrule.byminute().empty()) {
-            defaultRR->setByMinutes(QVector<int>::fromStdVector(rrule.byminute()).toList());
-        }
-        if (!rrule.byhour().empty()) {
-            defaultRR->setByHours(QVector<int>::fromStdVector(rrule.byhour()).toList());
-        }
-        if (!rrule.byday().empty()) {
-            QList<KCalCore::RecurrenceRule::WDayPos> daypos;
-            foreach(const Kolab::DayPos &dp, rrule.byday()) {
-                daypos.append(toWeekDayPos(dp));
-            }
-            defaultRR->setByDays(daypos);
-        }
-        if (!rrule.bymonthday().empty()) {
-            defaultRR->setByMonthDays(QVector<int>::fromStdVector(rrule.bymonthday()).toList());
-        }
-        if (!rrule.byyearday().empty()) {
-            defaultRR->setByYearDays(QVector<int>::fromStdVector(rrule.byyearday()).toList());
-        }
-        if (!rrule.byweekno().empty()) {
-            defaultRR->setByWeekNumbers(QVector<int>::fromStdVector(rrule.byweekno()).toList());
-        }
-        if (!rrule.bymonth().empty()) {
-            defaultRR->setByMonths(QVector<int>::fromStdVector(rrule.bymonth()).toList());
-        }
-    }
-    foreach (const Kolab::cDateTime &dt, event.recurrenceDates()) {
-        const KDateTime &date = toDate(dt);
-        if (date.isDateOnly()) {
-            e.recurrence()->addRDate(date.date());
-        } else {
-            e.recurrence()->addRDateTime(date);
-        }
-    }
-    foreach (const Kolab::cDateTime &dt, event.exceptionDates()) {
-        const KDateTime &date = toDate(dt);
-        if (date.isDateOnly()) {
-            e.recurrence()->addExDate(date.date());
-        } else {
-            e.recurrence()->addExDateTime(date);
-        }
-    }
-
-}
-
-template <typename T, typename I>
-void getRecurrence(T &i, const I &e)
-{
-    if (!e.recurs()) {
-        return;
-    }
-    KCalCore::Recurrence *rec = e.recurrence();
-    KCalCore::RecurrenceRule *defaultRR = rec->defaultRRule(false);
-    if (!defaultRR) {
-        Warning() << "no recurrence";
-        return;
-    }
-    Q_ASSERT(defaultRR);
-
-    Kolab::RecurrenceRule rrule;
-    rrule.setWeekStart(fromWeekDay(defaultRR->weekStart()));
-    rrule.setFrequency(fromRecurrenceType(defaultRR->recurrenceType()));
-    rrule.setInterval(defaultRR->frequency());
-  
-    if (defaultRR->duration() != 0) { //Inidcates if end date is set or not
-        if (defaultRR->duration() > 0) {
-            rrule.setCount(defaultRR->duration());
-        }
-    } else {
-        rrule.setEnd(fromDate(defaultRR->endDt()));
-    }
-    
-    rrule.setBysecond(defaultRR->bySeconds().toVector().toStdVector());
-    rrule.setByminute(defaultRR->byMinutes().toVector().toStdVector());
-    rrule.setByhour(defaultRR->byHours().toVector().toStdVector());
-    
-    std::vector<Kolab::DayPos> daypos;
-    foreach (const KCalCore::RecurrenceRule::WDayPos &dp, defaultRR->byDays()) {
-        daypos.push_back(fromWeekDayPos(dp));
-    }
-    rrule.setByday(daypos);
-    
-    rrule.setBymonthday(defaultRR->byMonthDays().toVector().toStdVector());
-    rrule.setByyearday(defaultRR->byYearDays().toVector().toStdVector());
-    rrule.setByweekno(defaultRR->byWeekNumbers().toVector().toStdVector());
-    rrule.setBymonth(defaultRR->byMonths().toVector().toStdVector());
-    i.setRecurrenceRule(rrule);
-    
-    std::vector<Kolab::cDateTime> rdates;
-    foreach (const KDateTime &dt, rec->rDateTimes()) {
-        rdates.push_back(fromDate(dt));
-    }
-    foreach (const QDate &dt, rec->rDates()) {
-        rdates.push_back(fromDate(KDateTime(dt)));
-    }
-    i.setRecurrenceDates(rdates);
-    
-    std::vector<Kolab::cDateTime> exdates;
-    foreach (const KDateTime &dt, rec->exDateTimes()) {
-        exdates.push_back(fromDate(dt));
-    }
-    foreach (const QDate &dt, rec->exDates()) {
-        exdates.push_back(fromDate(KDateTime(dt)));
-    }
-    i.setExceptionDates(exdates);
-    
-    if (!rec->exRules().empty()) {
-        Warning() << "exrules are not supported";
-    }
-}
-
-template <typename T>
-void setTodoEvent(KCalCore::Incidence &i, const T &e)
-{
-    i.setPriority(toPriority(e.priority()));
-    if (!e.location().empty()) {
-        i.setLocation(fromStdString(e.location())); //TODO detect richtext
-    }
-    if (e.organizer().isValid()) {
-        i.setOrganizer(KCalCore::Person::Ptr(new KCalCore::Person(fromStdString(e.organizer().name()), fromStdString(e.organizer().email())))); //TODO handle uid too
-    }
-    if (!e.url().empty()) {
-        i.setNonKDECustomProperty(CUSTOM_KOLAB_URL, fromStdString(e.url()));
-    }
-    if (e.recurrenceID().isValid()) {
-        i.setRecurrenceId(toDate(e.recurrenceID())); //TODO THISANDFUTURE
-    }
-    setRecurrence(i, e);
-    foreach (const Kolab::Alarm a, e.alarms()) {
-        KCalCore::Alarm::Ptr alarm = KCalCore::Alarm::Ptr(new KCalCore::Alarm(&i));
-        switch (a.type()) {
-            case Kolab::Alarm::EMailAlarm: {
-                KCalCore::Person::List receipents;
-                foreach (Kolab::ContactReference c ,a.attendees()) {
-                    KCalCore::Person::Ptr person = KCalCore::Person::Ptr(new KCalCore::Person(fromStdString(c.name()), fromStdString(c.email())));
-                    receipents.append(person);
-                }
-                alarm->setEmailAlarm(fromStdString(a.summary()), fromStdString(a.description()), receipents);
-            }
-                break;
-            case Kolab::Alarm::DisplayAlarm:
-                alarm->setDisplayAlarm(fromStdString(a.text()));
-                break;
-            case Kolab::Alarm::AudioAlarm:
-                alarm->setAudioAlarm(fromStdString(a.audioFile().uri()));
-                break;
-            default:
-                Error() << "invalid alarm";
-        }
-
-        if (a.start().isValid()) {
-            alarm->setTime(toDate(a.start()));
-        } else if (a.relativeStart().isValid()) {
-            if (a.relativeTo() == Kolab::End) {
-                alarm->setEndOffset(toDuration(a.relativeStart()));
-            } else {
-                alarm->setStartOffset(toDuration(a.relativeStart()));
-            }
-        }
-        
-        alarm->setSnoozeTime(toDuration(a.duration()));
-        alarm->setRepeatCount(a.numrepeat());
-        alarm->setEnabled(true);
-        i.addAlarm(alarm);       
-    }
-}
-
-template <typename T, typename I>
-void getTodoEvent(T &i, const I &e)
-{
-    i.setPriority(fromPriority(e.priority()));
-    i.setLocation(toStdString(e.location()));
-    if (e.organizer() && !e.organizer()->email().isEmpty()) {
-        i.setOrganizer(Kolab::ContactReference(Kolab::ContactReference::EmailReference, toStdString(e.organizer()->email()), toStdString(e.organizer()->name()))); //TODO handle uid too
-    }
-    i.setUrl(toStdString(e.nonKDECustomProperty(CUSTOM_KOLAB_URL)));
-    i.setRecurrenceID(fromDate(e.recurrenceId()), false); //TODO THISANDFUTURE
-    getRecurrence(i, e);
-    std::vector <Kolab::Alarm> alarms;
-    foreach (const KCalCore::Alarm::Ptr &a, e.alarms()) {
-        Kolab::Alarm alarm;
-        //TODO KCalCore disables alarms using KCalCore::Alarm::enabled() (X-KDE-KCALCORE-ENABLED) We should either delete the alarm, or store the attribute .
-        //Ideally we would store the alarm somewhere and temporarily delete it, so we can restore it when parsing. For now we just remove disabled alarms.
-        if (!a->enabled()) {
-            Warning() << "skipping disabled alarm";
-            continue;
-        }
-        switch (a->type()) {
-            case KCalCore::Alarm::Display:
-                alarm = Kolab::Alarm(toStdString(a->text()));
-                break;
-            case KCalCore::Alarm::Email: {
-                std::vector<Kolab::ContactReference> receipents;
-                foreach(const KCalCore::Person::Ptr &p, a->mailAddresses()) {
-                    receipents.push_back(Kolab::ContactReference(toStdString(p->email()), toStdString(p->name())));
-                }
-                alarm = Kolab::Alarm(toStdString(a->mailSubject()), toStdString(a->mailText()), receipents);
-            }
-                break;
-            case KCalCore::Alarm::Audio: {
-                Kolab::Attachment audioFile;
-                audioFile.setUri(toStdString(a->audioFile()), std::string());
-                alarm = Kolab::Alarm(audioFile);
-            }
-                break;
-            default:
-                Error() << "unhandled alarm";
-        }
-
-        if (a->hasTime()) {
-            alarm.setStart(fromDate(a->time()));
-        } else if (a->hasStartOffset()) {
-            alarm.setRelativeStart(fromDuration(a->startOffset()), Start);
-        } else if (a->hasEndOffset()) {
-            alarm.setRelativeStart(fromDuration(a->endOffset()), End);
-        } else {
-            Error() << "alarm trigger is missing";
-            continue;
-        }
-        
-        alarm.setDuration(fromDuration(a->snoozeTime()), a->repeatCount());
-        
-        alarms.push_back(alarm);
-    }
-    i.setAlarms(alarms);
-}
-
-KCalCore::Event::Ptr toKCalCore(const Kolab::Event &event)
-{
-    KCalCore::Event::Ptr e(new KCalCore::Event);
-    setIncidence(*e, event);
-    setTodoEvent(*e, event);
-    if (event.end().isValid()) {
-        e->setDtEnd(toDate(event.end()));
-    }
-    if (event.duration().isValid()) {
-        e->setDuration(toDuration(event.duration()));
-    }
-    if (event.transparency()) {
-        e->setTransparency(KCalCore::Event::Transparent);
-    } else {
-        e->setTransparency(KCalCore::Event::Opaque);
-    }
-    return e;
-}
-
-Event fromKCalCore(const KCalCore::Event &event)
-{
-    Event e;
-    getIncidence(e, event);
-    getTodoEvent(e, event);
-    if (event.hasEndDate()) {
-        e.setEnd(fromDate(event.dtEnd()));
-    } else if (event.hasDuration()) {
-        e.setDuration(fromDuration(event.duration()));
-    }
-    if (event.transparency() == KCalCore::Event::Transparent) {
-        e.setTransparency(true);
-    } else {
-        e.setTransparency(false);
-    }
-    return e;
-}
-
-
-
-KCalCore::Todo::Ptr toKCalCore ( const Todo &todo )
-{
-    KCalCore::Todo::Ptr e(new KCalCore::Todo);
-    setIncidence(*e, todo);
-    setTodoEvent(*e, todo);
-    if (todo.due().isValid()) {
-        e->setDtDue(toDate(todo.due()));
-    }
-    if (!todo.relatedTo().empty()) {
-        e->setRelatedTo(Conversion::fromStdString(todo.relatedTo().front()), KCalCore::Incidence::RelTypeParent);
-        if (todo.relatedTo().size() > 1) {
-            Error() << "only one relation support but got multiple";
-        }
-    }
-    e->setPercentComplete(todo.percentComplete());
-    return e;
-}
-
-Todo fromKCalCore ( const KCalCore::Todo &todo )
-{
-    Todo t;
-    getIncidence(t, todo);
-    getTodoEvent(t, todo);
-    t.setDue(fromDate(todo.dtDue(true)));
-    t.setPercentComplete(todo.percentComplete());
-    const QString relatedTo = todo.relatedTo(KCalCore::Incidence::RelTypeParent);
-    if (!relatedTo.isEmpty()) {
-        std::vector<std::string> relateds;
-        relateds.push_back(Conversion::toStdString(relatedTo));
-        t.setRelatedTo(relateds);
-    }
-    return t;
-}
-
-KCalCore::Journal::Ptr toKCalCore ( const Journal &journal )
-{
-    KCalCore::Journal::Ptr e(new KCalCore::Journal);
-    setIncidence(*e, journal);
-    //TODO contacts
-    return e;
-}
-
-Journal fromKCalCore ( const KCalCore::Journal &journal )
-{
-    Journal j;
-    getIncidence(j, journal);
-    //TODO contacts
-    return j;
-}
-
-
-
-}
-}
diff --git a/conversion/kcalconversion.h b/conversion/kcalconversion.h
deleted file mode 100644
index cd4f4e9..0000000
--- a/conversion/kcalconversion.h
+++ /dev/null
@@ -1,52 +0,0 @@
-/*
- * Copyright (C) 2011  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
-*/
-
-#ifndef KOLABKCALCONVERSION_H
-#define KOLABKCALCONVERSION_H
-
-#include "kolab_export.h"
-
-#include <kolabevent.h>
-#include <kolabtodo.h>
-#include <kolabjournal.h>
-#include <kcalcore/event.h>
-#include <kcalcore/todo.h>
-#include <kcalcore/journal.h>
-
-namespace Kolab {
-    /**
-     * Conversion of Kolab-Containers to/from KCalCore Containers.
-     *
-     */
-    namespace Conversion {
-
-        KOLAB_EXPORT KCalCore::Event::Ptr toKCalCore(const Kolab::Event &);
-        KOLAB_EXPORT Kolab::Event fromKCalCore(const KCalCore::Event &);
-
-        KOLAB_EXPORT KCalCore::Todo::Ptr toKCalCore(const Kolab::Todo &);
-        KOLAB_EXPORT Kolab::Todo fromKCalCore(const KCalCore::Todo &);
-
-        KOLAB_EXPORT KCalCore::Journal::Ptr toKCalCore(const Kolab::Journal &);
-        KOLAB_EXPORT Kolab::Journal fromKCalCore(const KCalCore::Journal &);
-
-        KOLAB_EXPORT KDateTime toDate(const Kolab::cDateTime &dt);
-        KOLAB_EXPORT cDateTime fromDate(const KDateTime &dt);
-
-    };
-};
-
-#endif
diff --git a/conversion/kolabconversion.cpp b/conversion/kolabconversion.cpp
deleted file mode 100644
index 249f051..0000000
--- a/conversion/kolabconversion.cpp
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-
-#include "kolabconversion.h"
-#include "commonconversion.h"
-#include <akonadi/notes/noteutils.h>
-
-namespace Kolab {
-    namespace Conversion {
-        
-Note fromNote(const KMime::Message::Ptr &m)
-{
-    Akonadi::NoteUtils::NoteMessageWrapper note(m);
-    Note n;
-    n.setSummary(toStdString(note.title()));
-    n.setDescription(toStdString(note.text()));
-    KDateTime created = note.creationDate();
-    created.setTimeSpec(KDateTime::UTC);
-    n.setCreated(fromDate(created));
-
-// #if KDEPIMLIBS_VERSION >= 0x040840
-#ifdef KDEPIMLIBS_VERSION_DEVEL
-    n.setUid(toStdString(note.uid()));
-    KDateTime lastModified = note.lastModifiedDate();
-    lastModified.setTimeSpec(KDateTime::UTC);
-    n.setLastModified(fromDate(lastModified));
-    
-    switch (note.classification()) {
-        case Akonadi::NoteUtils::NoteMessageWrapper::Confidential:
-            n.setClassification(Kolab::ClassConfidential);
-            break;
-        case Akonadi::NoteUtils::NoteMessageWrapper::Private:
-            n.setClassification(Kolab::ClassPrivate);
-            break;
-        default:
-            n.setClassification(Kolab::ClassPublic);
-    }
-    
-    std::vector<Kolab::CustomProperty> customs;
-    QMap<QString, QString> &customsMap = note.custom();
-    for (QMap <QString, QString >::const_iterator it = customsMap.constBegin(); it != customsMap.constEnd(); it ++) {
-        customs.push_back(Kolab::CustomProperty(toStdString(it.key()), toStdString(it.value())));
-    }
-    n.setCustomProperties(customs);
-    
-    std::vector<Kolab::Attachment> attachments;
-    foreach(const Akonadi::NoteUtils::Attachment &a, note.attachments()) {
-        Kolab::Attachment attachment;
-        if (a.url().isValid()) {
-            attachment.setUri(toStdString(a.url().toString()), toStdString(a.mimetype()));
-        } else {
-            attachment.setData(toStdString(QString(a.data())), toStdString(a.mimetype()));
-        }
-        attachment.setLabel(toStdString(a.label()));
-        attachments.push_back(attachment);
-    }
-    n.setAttachments(attachments);
-
-#endif
-    return n;
-}
-
-KMime::Message::Ptr toNote(const Note &n)
-{
-    Akonadi::NoteUtils::NoteMessageWrapper note;
-    note.setTitle(fromStdString(n.summary()));
-    note.setText(fromStdString(n.description()));
-    note.setFrom("kolab@kde4");
-    note.setCreationDate(toDate(n.created()));
-#ifdef KDEPIMLIBS_VERSION_DEVEL
-    note.setUid(fromStdString(n.uid()));
-    note.setLastModifiedDate(toDate(n.lastModified()));
-    switch (n.classification()) {
-        case Kolab::ClassPrivate:
-            note.setClassification(Akonadi::NoteUtils::NoteMessageWrapper::Private);
-            break;
-        case Kolab::ClassConfidential:
-            note.setClassification(Akonadi::NoteUtils::NoteMessageWrapper::Confidential);
-            break;
-        default:
-            note.setClassification(Akonadi::NoteUtils::NoteMessageWrapper::Public);
-    }
-
-    foreach (const Kolab::Attachment &a, n.attachments()) {
-        if (!a.uri().empty()) {
-            Akonadi::NoteUtils::Attachment attachment(QUrl(fromStdString(a.uri())), fromStdString(a.mimetype()));
-            attachment.setLabel(fromStdString(a.label()));
-            note.attachments().append(attachment);
-        } else {
-            Akonadi::NoteUtils::Attachment attachment(fromStdString(a.data()).toLatin1(), fromStdString(a.mimetype()));
-            attachment.setLabel(fromStdString(a.label()));
-            note.attachments().append(attachment);
-        }
-    }
-    foreach (const Kolab::CustomProperty &a, n.customProperties()) {
-        note.custom().insert(fromStdString(a.identifier), fromStdString(a.value));
-    }
-#endif
-    return note.message();
-}
-
-        
-    }
-}
-
diff --git a/conversion/kolabconversion.h b/conversion/kolabconversion.h
deleted file mode 100644
index 88de02e..0000000
--- a/conversion/kolabconversion.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef KOLABCONVERSION_H
-#define KOLABCONVERSION_H
-
-#include "kolab_export.h"
-
-#include <kolabnote.h>
-#include <kmime/kmime_message.h>
-
-namespace Kolab {
-    /**
-     * Conversion of Kolab-Containers to/from KDE Containers.
-     *
-     */
-    namespace Conversion {
-        
-        KOLAB_EXPORT KMime::Message::Ptr toNote(const Kolab::Note &);
-        KOLAB_EXPORT Kolab::Note fromNote(const KMime::Message::Ptr &);
-        
-    };
-};
-
-#endif
diff --git a/conversion/timezoneconverter.cpp b/conversion/timezoneconverter.cpp
deleted file mode 100644
index 7a75a04..0000000
--- a/conversion/timezoneconverter.cpp
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "timezoneconverter.h"
-#include <ktimezone.h>
-#include <ksystemtimezone.h>
-#include <kdebug.h>
-#include <QRegExp>
-#include <QStringList>
-#include "kolabformat/errorhandler.h"
-
-QString TimezoneConverter::normalizeTimezone(const QString& tz)
-{
-    KTimeZone timezone = KSystemTimeZones::zone(tz); //Needs ktimezoned (timezone daemon running) http://api.kde.org/4.x-api/kdelibs-apidocs/kdecore/html/classKSystemTimeZones.html
-    if (timezone.isValid()) {
-        return tz;
-    } else if (!KSystemTimeZones::isTimeZoneDaemonAvailable()) {
-        Error() << "ktimezoned is not available and required for timezone interpretation";
-    }
-    //We're dealing with an invalid or unknown timezone, try to parse it
-    QString guessedTimezone = fromCityName(tz);
-    if (guessedTimezone.isEmpty()) {
-        guessedTimezone = fromHardcodedList(tz);
-    }
-    if (guessedTimezone.isEmpty()) {
-        guessedTimezone = fromGMTOffsetTimezone(tz);
-    }
-//     if (guessedTimezone.isEmpty()) {
-//         //slower but also finds outdated zones
-//         timezone = KSystemTimeZones::readZone(tz);
-//         if (timezone.isValid()) {
-//             //This thinks all kinds of shit is valid, including /etc/localtime. Let's verify again.
-//             qDebug() << "found " << tz;
-//             return tz;
-//         }
-//     }
-    Debug() << "Guessed timezone and found: " << guessedTimezone;
-    return guessedTimezone;
-}
-
-QString TimezoneConverter::fromGMTOffsetTimezone(const QString& tz)
-{
-    Q_UNUSED(tz);
-    return QString();
-}
-
-QString TimezoneConverter::fromCityName(const QString& tz)
-{
-    const KTimeZones::ZoneMap zones = KSystemTimeZones::zones();
-    KTimeZones::ZoneMap::const_iterator it = zones.constBegin();
-    QHash<QString, QString> countryMap;
-    for(;it != zones.constEnd(); it++) {
-        const QString cityName = it.key().split('/').last();
-//         kDebug() << it.key() << it.value().name() << cityName;
-        Q_ASSERT(!countryMap.contains(cityName));
-        countryMap.insert(cityName, it.key());
-    }
-
-    QRegExp locationFinder("\\b([a-zA-Z])+\\b", Qt::CaseSensitive, QRegExp::RegExp2);
-    int pos = 0;
-    while (pos >= 0) {
-        pos = locationFinder.indexIn(tz, pos);
-        if (pos >= 0) {
-            ++pos;
-        }
-        const QString location = locationFinder.capturedTexts().first();
-//         kDebug() << "location " << location;
-        if (countryMap.contains(location)) {
-//             kDebug() << "found match " << countryMap.value(location);
-            return countryMap.value(location);
-        }
-    }
-    return QString();
-}
-
-
-//Based on
-// * http://msdn.microsoft.com/en-us/library/ms912391(v=winembedded.11).aspx
-// * http://technet.microsoft.com/en-us/library/cc749073(v=ws.10).aspx
-// * http://unicode.org/repos/cldr/trunk/common/supplemental/windowsZones.xml
-// * http://stackoverflow.com/questions/4967903/linux-windows-timezone-mapping
-static const struct WindowsTimezone {
-//   const int gmtOffset;
-  const char *timezoneSpecifier; //This one should be stable and always in english
-  const char *name; //The display name (which is in some cases still useful to try guessing)
-  const char *olson[28]; //Corresponding olson timezones we can map to
-} windowsTimezones[] = {
-    {"Afghanistan Standard Time", "Kabul", {"Asia/Kabul", "Asia/Kabul"}},
-    {"Alaskan Standard Time", "Alaska", {"America/Anchorage", "America/Anchorage America/Juneau America/Nome America/Sitka America/Yakutat"}},
-    {"Arab Standard Time", "Kuwait, Riyadh", {"Asia/Riyadh", "Asia/Bahrain", "Asia/Kuwait", "Asia/Qatar", "Asia/Riyadh", "Asia/Aden"}},
-    {"Arabian Standard Time", "Abu Dhabi, Muscat", {"Asia/Dubai", "Asia/Dubai", "Asia/Muscat", "Etc/GMT-4"}},
-    {"Arabic Standard Time", "Baghdad", {"Asia/Baghdad", "Asia/Baghdad"}},
-    {"Atlantic Standard Time", "Atlantic Time (Canada)", {"America/Halifax", "Atlantic/Bermuda", "America/Halifax America/Glace_Bay America/Goose_Bay America/Moncton", "America/Thule"}},
-    {"AUS Central Standard Time", "Darwin", {"Australia/Darwin", "Australia/Darwin"}},
-    {"AUS Eastern Standard Time", "Canberra, Melbourne, Sydney", {"Australia/Sydney", "Australia/Sydney Australia/Melbourne"}},
-    {"Azerbaijan Standard Time", "Baku", {"Asia/Baku", "Asia/Baku"}},
-    {"Azores Standard Time", "Azores", {"Atlantic/Azores", "America/Scoresbysund", "Atlantic/Azores"}},
-    {"Canada Central Standard Time", "Saskatchewan", {"America/Regina", "America/Regina America/Swift_Current"}},
-    {"Cape Verde Standard Time", "Cape Verde Islands", {"Atlantic/Cape_Verde", "Atlantic/Cape_Verde", "Etc/GMT+1"}},
-    {"Caucasus Standard Time", "Yerevan", {"Asia/Yerevan", "Asia/Yerevan"}},
-    {"Cen. Australia Standard Time", "Adelaide", {"Australia/Adelaide", "Australia/Adelaide Australia/Broken_Hill"}},
-    {"Central America Standard Time", "Central America", {"America/Guatemala", "America/Belize", "America/Costa_Rica", "Pacific/Galapagos", "America/Guatemala", "America/Tegucigalpa", "America/Managua", "America/El_Salvador", "Etc/GMT+6"}},
-    {"Central Asia Standard Time", "Astana, Dhaka", {"Asia/Almaty", "Antarctica/Vostok", "Indian/Chagos", "Asia/Bishkek", "Asia/Almaty Asia/Qyzylorda", "Etc/GMT-6"}},
-    {"Central Brazilian Standard Time", "Manaus", {"America/Cuiaba", "America/Cuiaba America/Campo_Grande"}},
-    {"Central Europe Standard Time", "Belgrade, Bratislava, Budapest, Ljubljana, Prague", {"Europe/Budapest", "Europe/Tirane", "Europe/Prague", "Europe/Budapest", "Europe/Podgorica", "Europe/Belgrade", "Europe/Ljubljana", "Europe/Bratislava"}},
-    {"Central European Standard Time", "Sarajevo, Skopje, Warsaw, Zagreb", {"Europe/Warsaw", "Europe/Sarajevo", "Europe/Zagreb", "Europe/Skopje", "Europe/Warsaw"}},
-    {"Central Pacific Standard Time", "Magadan, Solomon Islands, New Caledonia", {"Pacific/Guadalcanal", "Antarctica/Macquarie", "Pacific/Ponape Pacific/Kosrae", "Pacific/Noumea", "Pacific/Guadalcanal", "Pacific/Efate", "Etc/GMT-11"}},
-    {"Central Standard Time", "Central Time (US and Canada)", {"America/Chicago", "America/Winnipeg America/Rainy_River America/Rankin_Inlet America/Resolute", "America/Matamoros", "America/Chicago America/Indiana/Knox America/Indiana/Tell_City America/Menominee America/North_Dakota/Beulah America/North_Dakota/Center America/North_Dakota/New_Salem", "CST6CDT"}},
-    {"Central Standard Time (Mexico)", "Guadalajara, Mexico City, Monterrey", {"America/Mexico_City", "America/Mexico_City America/Bahia_Banderas America/Cancun America/Merida America/Monterrey"}},
-    {"China Standard Time", "Beijing, Chongqing, Hong Kong SAR, Urumqi", {"Asia/Shanghai", "Asia/Shanghai Asia/Chongqing Asia/Harbin Asia/Kashgar Asia/Urumqi", "Asia/Hong_Kong", "Asia/Macau"}},
-    {"Dateline Standard Time", "International Date Line West", {"Etc/GMT+12", "Etc/GMT+12"}},
-    {"E. Africa Standard Time", "Nairobi", {"Africa/Nairobi", "Antarctica/Syowa", "Africa/Djibouti", "Africa/Asmera", "Africa/Addis_Ababa", "Africa/Nairobi", "Indian/Comoro", "Indian/Antananarivo", "Africa/Khartoum", "Africa/Mogadishu", "Africa/Juba", "Africa/Dar_es_Salaam", "Africa/Kampala", "Indian/Mayotte", "Etc/GMT-3"}},
-    {"E. Australia Standard Time", "Brisbane", {"Australia/Brisbane", "Australia/Brisbane Australia/Lindeman"}},
-    {"E. Europe Standard Time", "Minsk", {"Asia/Nicosia", "Asia/Nicosia"}},
-    {"E. South America Standard Time", "Brasilia", {"America/Sao_Paulo", "America/Sao_Paulo"}},
-    {"Eastern Standard Time", "Eastern Time (US and Canada)", {"America/New_York", "America/Nassau", "America/Toronto America/Iqaluit America/Montreal America/Nipigon America/Pangnirtung America/Thunder_Bay", "America/Grand_Turk", "America/New_York America/Detroit America/Indiana/Petersburg America/Indiana/Vincennes America/Indiana/Winamac America/Kentucky/Monticello America/Louisville", "EST5EDT"}},
-    {"Egypt Standard Time", "Cairo", {"Africa/Cairo", "Africa/Cairo", "Asia/Gaza Asia/Hebron"}},
-    {"Ekaterinburg Standard Time", "Ekaterinburg", {"Asia/Yekaterinburg", "Asia/Yekaterinburg"}},
-    {"Fiji Standard Time", "Fiji Islands, Kamchatka, Marshall Islands", {"Pacific/Fiji", "Pacific/Fiji"}},
-    {"FLE Standard Time", "Helsinki, Kiev, Riga, Sofia, Tallinn, Vilnius", {"Europe/Kiev", "Europe/Mariehamn", "Europe/Sofia", "Europe/Tallinn", "Europe/Helsinki", "Europe/Vilnius", "Europe/Riga", "Europe/Kiev Europe/Simferopol Europe/Uzhgorod Europe/Zaporozhye"}},
-    {"Georgian Standard Time", "Tblisi", {"Asia/Tbilisi", "Asia/Tbilisi"}},
-    {"GMT Standard Time", "Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London", {"Europe/London", "Atlantic/Canary", "Atlantic/Faeroe", "Europe/London", "Europe/Guernsey", "Europe/Dublin", "Europe/Isle_of_Man", "Europe/Jersey", "Europe/Lisbon Atlantic/Madeira"}},
-    {"Greenland Standard Time", "Greenland", {"America/Godthab", "America/Godthab"}},
-    {"Greenwich Standard Time", "Casablanca, Monrovia", {"Atlantic/Reykjavik", "Africa/Ouagadougou", "Africa/Abidjan", "Africa/El_Aaiun", "Africa/Accra", "Africa/Banjul", "Africa/Conakry", "Africa/Bissau", "Atlantic/Reykjavik", "Africa/Monrovia", "Africa/Bamako", "Africa/Nouakchott", "Atlantic/St_Helena", "Africa/Freetown", "Africa/Dakar", "Africa/Sao_Tome", "Africa/Lome"}},
-    {"GTB Standard Time", "Athens, Bucharest, Istanbul", {"Europe/Bucharest", "Europe/Athens", "Europe/Chisinau", "Europe/Bucharest"}},
-    {"Hawaiian Standard Time", "Hawaii", {"Pacific/Honolulu", "Pacific/Rarotonga", "Pacific/Tahiti", "Pacific/Johnston", "Pacific/Honolulu", "Etc/GMT+10"}},
-    {"India Standard Time", "Chennai, Kolkata, Mumbai, New Delhi", {"Asia/Calcutta", "Asia/Calcutta"}},
-    {"Iran Standard Time", "Tehran", {"Asia/Tehran", "Asia/Tehran"}},
-    {"Israel Standard Time", "Jerusalem", {"Asia/Jerusalem", "Asia/Jerusalem"}},
-    {"Korea Standard Time", "Seoul", {"Asia/Seoul", "Asia/Pyongyang", "Asia/Seoul"}},
-//    {"Mid-Atlantic Standard Time", "Mid-Atlantic", {"}},
-    {"Mountain Standard Time", "Mountain Time (US and Canada)", {"America/Denver", "America/Edmonton America/Cambridge_Bay America/Inuvik America/Yellowknife", "America/Ojinaga", "America/Denver America/Boise America/Shiprock", "MST7MDT"}},
-    {"Mountain Standard Time (Mexico)", "Chihuahua, La Paz, Mazatlan", {"America/Chihuahua", "America/Chihuahua America/Mazatlan"}},
-    {"Myanmar Standard Time", "Yangon (Rangoon)", {"Asia/Rangoon", "Indian/Cocos", "Asia/Rangoon"}},
-    {"N. Central Asia Standard Time", "Almaty, Novosibirsk", {"Asia/Novosibirsk", "Asia/Novosibirsk Asia/Novokuznetsk Asia/Omsk"}},
-    {"Namibia Standard Time", "Windhoek", {"Africa/Windhoek", "Africa/Windhoek"}},
-    {"Nepal Standard Time", "Kathmandu", {"Asia/Katmandu", "Asia/Katmandu"}},
-    {"New Zealand Standard Time", "Auckland, Wellington", {"Pacific/Auckland", "Antarctica/South_Pole Antarctica/McMurdo", "Pacific/Auckland"}},
-    {"Newfoundland Standard Time", "Newfoundland and Labrador", {"America/St_Johns", "America/St_Johns"}},
-    {"North Asia East Standard Time", "Irkutsk, Ulaanbaatar", {"Asia/Irkutsk", "Asia/Irkutsk"}},
-    {"North Asia Standard Time", "Krasnoyarsk", {"Asia/Krasnoyarsk", "Asia/Krasnoyarsk"}},
-    {"Pacific SA Standard Time", "Santiago", {"America/Santiago", "Antarctica/Palmer", "America/Santiago"}},
-    {"Pacific Standard Time", "Pacific Time (US and Canada); Tijuana", {"America/Los_Angeles", "America/Vancouver America/Dawson America/Whitehorse", "America/Tijuana", "America/Los_Angeles", "PST8PDT"}},
-    {"Romance Standard Time", "Brussels, Copenhagen, Madrid, Paris", {"Europe/Paris", "Europe/Brussels", "Europe/Copenhagen", "Europe/Madrid Africa/Ceuta", "Europe/Paris"}},
-    {"Russian Standard Time", "Moscow, St. Petersburg, Volgograd", {"Europe/Moscow", "Europe/Moscow Europe/Samara Europe/Volgograd"}},
-    {"SA Eastern Standard Time", "Buenos Aires, Georgetown", {"America/Cayenne", "Antarctica/Rothera", "America/Fortaleza America/Araguaina America/Belem America/Maceio America/Recife America/Santarem", "Atlantic/Stanley", "America/Cayenne", "America/Paramaribo", "Etc/GMT+3"}},
-    {"SA Pacific Standard Time", "Bogota, Lima, Quito", {"America/Bogota", "America/Coral_Harbour", "America/Bogota", "America/Guayaquil", "America/Port-au-Prince", "America/Jamaica", "America/Cayman", "America/Panama", "America/Lima", "Etc/GMT+5"}},
-    {"SA Western Standard Time", "Caracas, La Paz", {"America/La_Paz", "America/Antigua", "America/Anguilla", "America/Aruba", "America/Barbados", "America/St_Barthelemy", "America/La_Paz", "America/Kralendijk", "America/Manaus America/Boa_Vista America/Eirunepe America/Porto_Velho America/Rio_Branco", "America/Blanc-Sablon", "America/Curacao", "America/Dominica", "America/Santo_Domingo", "America/Grenada", "America/Guadeloupe", "America/Guyana", "America/St_Kitts", "America/St_Lucia", "America/Marigot", "America/Martinique", "America/Montserrat", "America/Puerto_Rico", "America/Lower_Princes", "America/Port_of_Spain", "America/St_Vincent", "America/Tortola", "America/St_Thomas", "Etc/GMT+4"}},
-    {"Samoa Standard Time", "Midway Island, Samoa", {"Pacific/Apia", "Pacific/Apia"}},
-    {"SE Asia Standard Time", "Bangkok, Hanoi, Jakarta", {"Asia/Bangkok", "Antarctica/Davis", "Indian/Christmas", "Asia/Jakarta Asia/Pontianak", "Asia/Phnom_Penh", "Asia/Vientiane", "Asia/Hovd", "Asia/Bangkok", "Asia/Saigon", "Etc/GMT-7"}},
-    {"Singapore Standard Time", "Kuala Lumpur, Singapore", {"Asia/Singapore", "Asia/Brunei", "Asia/Makassar", "Asia/Kuala_Lumpur Asia/Kuching", "Asia/Manila", "Asia/Singapore", "Etc/GMT-8"}},
-    {"South Africa Standard Time", "Harare, Pretoria", {"Africa/Johannesburg", "Africa/Bujumbura", "Africa/Gaborone", "Africa/Lubumbashi", "Africa/Maseru", "Africa/Blantyre", "Africa/Maputo", "Africa/Kigali", "Africa/Mbabane", "Africa/Johannesburg", "Africa/Lusaka", "Africa/Harare", "Etc/GMT-2"}},
-    {"Sri Lanka Standard Time", "Sri Jayawardenepura", {"Asia/Colombo", "Asia/Colombo"}},
-    {"Taipei Standard Time", "Taipei", {"Asia/Taipei", "Asia/Taipei"}},
-    {"Tasmania Standard Time", "Hobart", {"Australia/Hobart", "Australia/Hobart Australia/Currie"}},
-    {"Tokyo Standard Time", "Osaka, Sapporo, Tokyo", {"Asia/Tokyo", "Asia/Jayapura", "Asia/Tokyo", "Pacific/Palau", "Asia/Dili", "Etc/GMT-9"}},
-    {"Tonga Standard Time", "Nuku'alofa", {"Pacific/Tongatapu", "Pacific/Enderbury", "Pacific/Fakaofo", "Pacific/Tongatapu", "Etc/GMT-13"}},
-    {"US Eastern Standard Time", "Indiana (East)", {"America/Indianapolis", "America/Indianapolis America/Indiana/Marengo America/Indiana/Vevay"}},
-    {"US Mountain Standard Time", "Arizona", {"America/Phoenix", "America/Dawson_Creek America/Creston", "America/Hermosillo", "America/Phoenix", "Etc/GMT+7"}},
-    {"Vladivostok Standard Time", "Vladivostok", {"Asia/Vladivostok", "Asia/Vladivostok Asia/Sakhalin"}},
-    {"W. Australia Standard Time", "Perth", {"Australia/Perth", "Antarctica/Casey", "Australia/Perth"}},
-    {"W. Central Africa Standard Time", "West Central Africa", {"Africa/Lagos", "Africa/Luanda", "Africa/Porto-Novo", "Africa/Kinshasa", "Africa/Bangui", "Africa/Brazzaville", "Africa/Douala", "Africa/Algiers", "Africa/Libreville", "Africa/Malabo", "Africa/Niamey", "Africa/Lagos", "Africa/Ndjamena", "Africa/Tunis", "Etc/GMT-1"}},
-    {"W. Europe Standard Time", "Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna", {"Europe/Berlin", "Europe/Andorra", "Europe/Vienna", "Europe/Zurich", "Europe/Berlin", "Europe/Gibraltar", "Europe/Rome", "Europe/Vaduz", "Europe/Luxembourg", "Africa/Tripoli", "Europe/Monaco", "Europe/Malta", "Europe/Amsterdam", "Europe/Oslo", "Europe/Stockholm", "Arctic/Longyearbyen", "Europe/San_Marino", "Europe/Vatican"}},
-    {"West Asia Standard Time", "Islamabad, Karachi, Tashkent", {"Asia/Tashkent", "Antarctica/Mawson", "Asia/Oral Asia/Aqtau Asia/Aqtobe", "Indian/Maldives", "Indian/Kerguelen", "Asia/Dushanbe", "Asia/Ashgabat", "Asia/Tashkent Asia/Samarkand", "Etc/GMT-5"}},
-    {"West Pacific Standard Time", "Guam, Port Moresby", {"Pacific/Port_Moresby", "Antarctica/DumontDUrville", "Pacific/Truk", "Pacific/Guam", "Pacific/Saipan", "Pacific/Port_Moresby", "Etc/GMT-10"}},
-    {"Yakutsk Standard Time", "Yakuts", {"Asia/Yakutsk", "Asia/Yakutsk"}}
-};
-static const int numWindowsTimezones = sizeof windowsTimezones / sizeof *windowsTimezones;
-
-QString TimezoneConverter::fromHardcodedList(const QString& tz)
-{
-    for (int i = 0; i <numWindowsTimezones; i++) {
-        const WindowsTimezone &windowsTimezone = windowsTimezones[i];
-        const QByteArray specifier(windowsTimezone.timezoneSpecifier);
-        const QByteArray windowsName(windowsTimezone.name);
-        if ((!specifier.isEmpty() && tz.contains(specifier)) ||
-            (!windowsName.isEmpty() && tz.contains(windowsName))) {
-            //TODO find the olson timezone matching the local timezone if we have multiple to map to
-            return QString::fromLatin1(windowsTimezone.olson[0]);
-        }
-    }
-    return QString();
-}
diff --git a/conversion/timezoneconverter.h b/conversion/timezoneconverter.h
deleted file mode 100644
index 84cad70..0000000
--- a/conversion/timezoneconverter.h
+++ /dev/null
@@ -1,33 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef TIMEZONECONVERTER_H
-#define TIMEZONECONVERTER_H
-
-#include <QString>
-
-class TimezoneConverter
-{
-public:
-    static QString normalizeTimezone(const QString &tz);
-private:
-    static QString fromCityName(const QString &tz);
-    static QString fromHardcodedList(const QString &tz);
-    static QString fromGMTOffsetTimezone(const QString &tz);
-};
-
-#endif // TIMEZONECONVERTER_H
diff --git a/freebusy/CMakeLists.txt b/freebusy/CMakeLists.txt
deleted file mode 100644
index f1f584e..0000000
--- a/freebusy/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-set (FREEBUSY_SRCS
-    ${CMAKE_CURRENT_SOURCE_DIR}/freebusy.cpp
-    PARENT_SCOPE)
diff --git a/freebusy/freebusy.cpp b/freebusy/freebusy.cpp
deleted file mode 100644
index 7b20c20..0000000
--- a/freebusy/freebusy.cpp
+++ /dev/null
@@ -1,321 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-
-#include "freebusy.h"
-#include "conversion/kcalconversion.h"
-#include "conversion/commonconversion.h"
-#include "libkolab-version.h"
-#include <kcalcore/freebusy.h>
-#include <kcalcore/icalformat.h>
-#include <kdebug.h>
-#include <quuid.h>
-
-
-// namespace KCalCore {
-//     struct KCalFreebusy
-// {
-//
-// void init( const Event::List &eventList, const KDateTime &start, const KDateTime &end )
-// {
-//     mDtStart = start.toUtc();
-//     mDtEnd = end.toUtc();
-//
-//   // Loops through every event in the calendar
-//   Event::List::ConstIterator it;
-//   for ( it = eventList.constBegin(); it != eventList.constEnd(); ++it ) {
-//     Event::Ptr event = *it;
-//
-//     // If this event is transparent it shouldn't be in the freebusy list.
-//     if ( event->transparency() == Event::Transparent ) {
-//       continue;
-//     }
-//
-//     if ( event->hasRecurrenceId() ) {
-//       continue; //TODO apply special period exception (duration could be different)
-//     }
-//
-//     const KDateTime eventStart = event->dtStart().toUtc();
-//     const KDateTime eventEnd = event->dtEnd().toUtc();
-//
-//     if ( event->recurs() ) {
-//         const KCalCore::Duration duration( eventStart, eventEnd );
-//         const KCalCore::DateTimeList list = event->recurrence()->timesInInterval(start, end);
-//         foreach (const KDateTime &dt, list) {
-//             const KDateTime utc = dt.toUtc();
-//             addLocalPeriod(utc, duration.end(utc) );
-//         }
-//     } else {
-//         addLocalPeriod( eventStart, eventEnd );
-//     }
-//   }
-//
-// //   q->sortList();
-// }
-//
-// bool addLocalPeriod(
-//                                         const KDateTime &eventStart,
-//                                         const KDateTime &eventEnd )
-// {
-//   KDateTime tmpStart;
-//   KDateTime tmpEnd;
-//
-//   //Check to see if the start *or* end of the event is
-//   //between the start and end of the freebusy dates.
-//   if ( !( ( ( mDtStart.secsTo( eventStart ) >= 0 ) &&
-//             ( eventStart.secsTo( mDtEnd ) >= 0 ) ) ||
-//           ( ( mDtStart.secsTo( eventEnd ) >= 0 ) &&
-//             ( eventEnd.secsTo( mDtEnd ) >= 0 ) ) ) ) {
-//       qDebug() << "out of scope";
-//     return false;
-//   }
-//
-// //   qDebug() << eventStart.date().toString() << eventStart.time().toString() << mDtStart.toString();
-//   if ( eventStart < mDtStart ) { //eventStart is before start
-// //       qDebug() << "use start";
-//     tmpStart = mDtStart;
-//   } else {
-//     tmpStart = eventStart;
-//   }
-//
-//   qDebug() << eventEnd.date().toString() << eventEnd.time().toString() << mDtEnd.toString();
-//   if ( eventEnd > mDtEnd ) { //event end is after dtEnd
-// //     qDebug() << "use end";
-//     tmpEnd = mDtEnd;
-//   } else {
-//     tmpEnd = eventEnd;
-//   }
-//
-// //   qDebug() << "########## " << tmpStart.isValid();
-//   Q_ASSERT(tmpStart.isValid());
-//   Q_ASSERT(tmpEnd.isValid());
-// //   qDebug() << tmpStart.date().toString() << tmpStart.time().toString() << tmpStart.toString();
-//
-//   FreeBusyPeriod p( tmpStart, tmpEnd );
-//   mBusyPeriods.append( p );
-//
-//   return true;
-// }
-//
-//     KDateTime mDtStart;
-//     KDateTime mDtEnd;                  // end datetime
-//     FreeBusyPeriod::List mBusyPeriods; // list of periods
-//
-// };
-//
-// } // Namespace
-
-
-
-
-
-
-
-namespace Kolab {
-    namespace FreebusyUtils {
-
-static QString createUuid()
-{
-    const QString uuid = QUuid::createUuid().toString();
-    return uuid.mid(1, uuid.size()-2);
-}
-
-Kolab::Period addLocalPeriod(  const KDateTime &eventStart, const KDateTime &eventEnd, const KDateTime &mDtStart, const KDateTime &mDtEnd)
-{
-  KDateTime tmpStart;
-  KDateTime tmpEnd;
-
-  //Check to see if the start *or* end of the event is
-  //between the start and end of the freebusy dates.
-  if ( !( ( ( mDtStart <= eventStart) &&
-            ( eventStart <= mDtEnd ) ) ||
-          ( ( mDtStart <= eventEnd ) &&
-            ( eventEnd <= mDtEnd ) ) ) ) {
-    qDebug() << "event is not within the fb range, skipping";
-    return Kolab::Period();
-  }
-
-  if ( eventStart < mDtStart ) { //eventStart is before start
-    tmpStart = mDtStart;
-  } else {
-    tmpStart = eventStart;
-  }
-
-//   qDebug() << eventEnd.date().toString() << eventEnd.time().toString() << mDtEnd.toString();
-  if ( eventEnd > mDtEnd ) { //event end is after dtEnd
-    tmpEnd = mDtEnd;
-  } else {
-    tmpEnd = eventEnd;
-  }
-  Q_ASSERT(tmpStart.isValid());
-  Q_ASSERT(tmpEnd.isValid());
-  if (tmpStart.isDateOnly()) {
-    tmpStart.setTime(QTime(0,0,0,0));
-  }
-  if (tmpEnd.isDateOnly()) {
-    tmpEnd.setTime(QTime(23,59,59,999)); //The window is inclusive
-  }
-  return Kolab::Period(Kolab::Conversion::fromDate(tmpStart), Kolab::Conversion::fromDate(tmpEnd));
-}
-
-Freebusy generateFreeBusy(const std::vector< Event >& events, const cDateTime& startDate, const cDateTime& endDate)
-{
-    QList<KCalCore::Event::Ptr> list;
-    foreach (const Kolab::Event &e, events) {
-        list.append(Kolab::Conversion::toKCalCore(e));
-    }
-    KCalCore::Person::Ptr person(new KCalCore::Person("dummyname", "dummyemail"));
-    return generateFreeBusy(list, Kolab::Conversion::toDate(startDate), Kolab::Conversion::toDate(endDate), person);
-}
-
-Freebusy generateFreeBusy(const QList<KCalCore::Event::Ptr>& events, const KDateTime& startDate, const KDateTime& endDate, const KCalCore::Person::Ptr &organizer)
-{
-    /*
-     * TODO the conversion of date-only values to date-time is only necessary because xCal doesn't allow date only. iCalendar doesn't seem to make this restriction so it looks like a bug.
-     */
-    KDateTime start = startDate.toUtc();
-    if (start.isDateOnly()) {
-        start.setTime(QTime(0,0,0,0));
-    }
-    KDateTime end = endDate.toUtc();
-    if (end.isDateOnly()) {
-        end.addDays(1);
-        end.setTime(QTime(0,0,0,0)); //The window is inclusive
-    }
-
-    //TODO try to merge that with KCalCore::Freebusy
-    std::vector<Kolab::FreebusyPeriod> freebusyPeriods;
-    Q_FOREACH (KCalCore::Event::Ptr event, events) {    
-        // If this event is transparent it shouldn't be in the freebusy list.
-        if ( event->transparency() == KCalCore::Event::Transparent ) {
-            continue;
-        }
-
-        if ( event->hasRecurrenceId() ) {
-            continue; //TODO apply special period exception (duration could be different)
-        }
-
-        const KDateTime eventStart = event->dtStart().toUtc();
-        const KDateTime eventEnd = event->dtEnd().toUtc();
-
-        std::vector <Kolab::Period> periods;
-        if ( event->recurs() ) {
-            const KCalCore::Duration duration( eventStart, eventEnd );
-            const KCalCore::DateTimeList list = event->recurrence()->timesInInterval(start, end);
-            Q_FOREACH (const KDateTime &dt, list) {
-                const KDateTime utc = dt.toUtc();
-                const Kolab::Period &period = addLocalPeriod(utc, duration.end(utc), start, end);
-                if (period.isValid()) {
-                    periods.push_back(period);
-                }
-            }
-        } else {
-            const Kolab::Period &period = addLocalPeriod(eventStart, eventEnd, start, end);
-            if (period.isValid()) {
-                periods.push_back(period);
-            }
-        }
-        if (!periods.empty()) {
-            Kolab::FreebusyPeriod period;
-            period.setPeriods(periods);
-            //TODO get busy type from event (out-of-office, tentative)
-            period.setType(Kolab::FreebusyPeriod::Busy);
-            period.setEvent(Kolab::Conversion::toStdString(event->uid()), Kolab::Conversion::toStdString(event->summary()), Kolab::Conversion::toStdString(event->location()));
-            freebusyPeriods.push_back(period);
-        }
-    }
-
-    Kolab::Freebusy freebusy;
-    
-    freebusy.setStart(Kolab::Conversion::fromDate(start));
-    freebusy.setEnd(Kolab::Conversion::fromDate(end));
-    freebusy.setPeriods(freebusyPeriods);
-    freebusy.setUid(createUuid().toStdString());
-    freebusy.setTimestamp(Kolab::Conversion::fromDate(KDateTime::currentUtcDateTime()));
-    if (organizer) {
-        freebusy.setOrganizer(ContactReference(Kolab::ContactReference::EmailReference, Kolab::Conversion::toStdString(organizer->email()), Kolab::Conversion::toStdString(organizer->name())));
-    }
-    
-    return freebusy;
-}
-
-Freebusy aggregateFreeBusy(const std::vector< Freebusy >& fbList, const std::string &organizerEmail, const std::string &organizerName, bool simple)
-{
-    std::vector <Kolab::FreebusyPeriod > periods;
-
-    KDateTime start;
-    KDateTime end;
-    Q_FOREACH (const Freebusy &fb, fbList) {
-
-        const KDateTime &tmpStart = Kolab::Conversion::toDate(fb.start());
-        if (!start.isValid() || tmpStart < start) {
-            start = tmpStart;
-        }
-        const KDateTime &tmpEnd = Kolab::Conversion::toDate(fb.end());
-        if (!end.isValid() || tmpEnd > end) {
-            end = tmpEnd;
-        }
-
-        Q_FOREACH (const Kolab::FreebusyPeriod &period, fb.periods()) {
-            Kolab::FreebusyPeriod simplifiedPeriod;
-            simplifiedPeriod.setPeriods(period.periods());
-            simplifiedPeriod.setType(period.type());
-            if (!simple) { //Don't copy and reset to avoid unintentional information leaking into simple lists
-                simplifiedPeriod.setEvent(period.eventSummary(), period.eventUid(), period.eventLocation());
-            }
-            periods.push_back(simplifiedPeriod);
-        }
-    }
-    
-    Freebusy aggregateFB;
-
-    aggregateFB.setStart(Kolab::Conversion::fromDate(start));
-    aggregateFB.setEnd(Kolab::Conversion::fromDate(end));
-    aggregateFB.setPeriods(periods);
-    aggregateFB.setUid(createUuid().toStdString());
-    aggregateFB.setTimestamp(Kolab::Conversion::fromDate(KDateTime::currentUtcDateTime()));
-    aggregateFB.setOrganizer(ContactReference(Kolab::ContactReference::EmailReference, organizerEmail, organizerName));
-    return aggregateFB;
-}
-
-std::string toIFB(const Kolab::Freebusy &freebusy)
-{
-    KCalCore::FreeBusy::Ptr fb(new KCalCore::FreeBusy(Kolab::Conversion::toDate(freebusy.start()), Kolab::Conversion::toDate(freebusy.end())));
-    KCalCore::FreeBusyPeriod::List list;
-    Q_FOREACH (const Kolab::FreebusyPeriod &fbPeriod, freebusy.periods()) {
-        Q_FOREACH (const Kolab::Period &p, fbPeriod.periods()) {
-            KCalCore::FreeBusyPeriod period(Kolab::Conversion::toDate(p.start), Kolab::Conversion::toDate(p.end));
-//             period.setSummary("summary"); Doesn't even work. X-SUMMARY is read though (just not written out)
-            //TODO
-            list.append(period);
-            
-        }
-    }
-    fb->addPeriods(list);
-
-    fb->setUid(QString::fromStdString(freebusy.uid()));
-    fb->setOrganizer(KCalCore::Person::Ptr(new KCalCore::Person(Conversion::fromStdString(freebusy.organizer().name()), Conversion::fromStdString(freebusy.organizer().email()))));
-    fb->setLastModified(Kolab::Conversion::toDate(freebusy.timestamp()));
-
-    KCalCore::ICalFormat format;
-    format.setApplication("libkolab", LIBKOLAB_LIB_VERSION_STRING);
-    QString data = format.createScheduleMessage( fb, KCalCore::iTIPPublish );
-    return Conversion::toStdString(data);
-}
-
-    }
-}
diff --git a/freebusy/freebusy.h b/freebusy/freebusy.h
deleted file mode 100644
index 3781db9..0000000
--- a/freebusy/freebusy.h
+++ /dev/null
@@ -1,39 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-
-#ifndef FREEBUSY_H
-#define FREEBUSY_H
-
-#include "kolab_export.h"
-#include <kolabevent.h>
-#include <kolabfreebusy.h>
-#include <kcalcore/event.h>
-
-namespace Kolab {
-    namespace FreebusyUtils {
-
-KOLAB_EXPORT Freebusy generateFreeBusy(const QList<KCalCore::Event::Ptr>& events, const KDateTime& startDate, const KDateTime& endDate, const KCalCore::Person::Ptr &organizer);
-KOLAB_EXPORT std::string toIFB(const Kolab::Freebusy &);
-
-Kolab::Freebusy generateFreeBusy(const std::vector<Kolab::Event> &events, const Kolab::cDateTime &startDate, const Kolab::cDateTime &endDate);
-KOLAB_EXPORT Kolab::Freebusy aggregateFreeBusy(const std::vector<Kolab::Freebusy> &fbs, const std::string &organizerEmail, const std::string &organizerName, bool simple = true);
-
-    }
-}
-
-#endif // FREEBUSY_H
diff --git a/icalendar/CMakeLists.txt b/icalendar/CMakeLists.txt
deleted file mode 100644
index ee276d6..0000000
--- a/icalendar/CMakeLists.txt
+++ /dev/null
@@ -1,15 +0,0 @@
-
-set (ICALENDAR_SRCS
-    ${CMAKE_CURRENT_SOURCE_DIR}/icalendar.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/imip.cpp
-    PARENT_SCOPE)
-
-if(PYTHON_BINDINGS)
-    message("building python bindings")
-    add_subdirectory(python)
-endif(PYTHON_BINDINGS)
-
-if(PHP_BINDINGS)
-    message("building php bindings")
-    add_subdirectory(php)
-endif(PHP_BINDINGS)
diff --git a/icalendar/icalendar.cpp b/icalendar/icalendar.cpp
deleted file mode 100644
index be7c0e6..0000000
--- a/icalendar/icalendar.cpp
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
-    <one line to give the library's name and an idea of what it does.>
-    Copyright (C) 2012  Christian Mollekopf <chrigi_1@fastmail.fm>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-
-#include "icalendar.h"
-#include "imip.h"
-#include "libkolab-version.h"
-#include <conversion/kcalconversion.h>
-#include <conversion/commonconversion.h>
-#include <mime/mimeutils.h>
-#include <kcalcore/event.h>
-#include <kcalcore/memorycalendar.h>
-#include <kcalcore/icalformat.h>
-#include <kmime/kmime_message.h>
-// #include <klocalizedstring.h>
-#include <kdebug.h>
-#include <iostream>
-
-namespace Kolab {
-
-std::string toICal(const std::vector<Event> &events)
-{
-    KCalCore::Calendar::Ptr calendar(new KCalCore::MemoryCalendar(Kolab::Conversion::getTimeSpec(true, std::string())));
-    foreach (const Event &event, events) {
-        KCalCore::Event::Ptr kcalEvent = Conversion::toKCalCore(event);
-        kcalEvent->setCreated(KDateTime::currentUtcDateTime()); //sets dtstamp
-        calendar->addEvent(kcalEvent);
-    }
-    KCalCore::ICalFormat format;
-    format.setApplication("libkolab", LIBKOLAB_LIB_VERSION_STRING);
-//     qDebug() << format.createScheduleMessage(calendar->events().first(), KCalCore::iTIPRequest);
-
-    return Conversion::toStdString(format.toString(calendar));
-    
-}
-
-std::vector< Event > fromICalEvents(const std::string &input)
-{
-    KCalCore::Calendar::Ptr calendar(new KCalCore::MemoryCalendar(Kolab::Conversion::getTimeSpec(true, std::string())));
-    KCalCore::ICalFormat format;
-    format.setApplication("libkolab", LIBKOLAB_LIB_VERSION_STRING);
-    format.fromString(calendar, Conversion::fromStdString(input));
-    std::vector<Event> events;
-    foreach (const KCalCore::Event::Ptr &event, calendar->events()) {
-        events.push_back(Conversion::fromKCalCore(*event));
-    }
-    return events;
-}
-
-ITipHandler::ITipHandler()
-:   mMethod(iTIPNoMethod)
-{
-}
-
-
-ITipHandler::ITipMethod mapFromKCalCore(KCalCore::iTIPMethod method)
-{
-    Q_ASSERT((int)KCalCore::iTIPPublish == (int)ITipHandler::iTIPPublish);
-    Q_ASSERT((int)KCalCore::iTIPNoMethod == (int)ITipHandler::iTIPNoMethod);
-    return static_cast<ITipHandler::ITipMethod>(method);
-}
-
-KCalCore::iTIPMethod mapToKCalCore(ITipHandler::ITipMethod method)
-{
-    Q_ASSERT((int)KCalCore::iTIPPublish == (int)ITipHandler::iTIPPublish);
-    Q_ASSERT((int)KCalCore::iTIPNoMethod == (int)ITipHandler::iTIPNoMethod);
-    return static_cast<KCalCore::iTIPMethod>(method);
-}
-
-
-std::string ITipHandler::toITip(const Event &event, ITipHandler::ITipMethod method) const
-{
-    KCalCore::ICalFormat format;
-    format.setApplication("libkolab", LIBKOLAB_LIB_VERSION_STRING);
-    KCalCore::iTIPMethod m = mapToKCalCore(method);
-    if (m == KCalCore::iTIPNoMethod) {
-        return std::string();
-    }
-//     kDebug() << event.start().
-/* TODO
- * DTSTAMP is created
- * CREATED is current timestamp
- * LASTMODIFIED is lastModified
- * 
- * Double check if that is correct.
- *
- * I think DTSTAMP should be the current timestamp, and CREATED should be the creation date.
- */
-    KCalCore::Event::Ptr e = Conversion::toKCalCore(event);
-    return Conversion::toStdString(format.createScheduleMessage(e, m));
-}
-
-
-std::vector< Event > ITipHandler::fromITip(const std::string &string)
-{
-    KCalCore::Calendar::Ptr calendar(new KCalCore::MemoryCalendar(KDateTime::Spec(KDateTime::UTC)));
-    KCalCore::ICalFormat format;
-    KCalCore::ScheduleMessage::Ptr msg= format.parseScheduleMessage(calendar, Conversion::fromStdString(string));
-    KCalCore::Event::Ptr event = msg->event().dynamicCast<KCalCore::Event>();
-    std::vector< Event > events;
-    events.push_back(Conversion::fromKCalCore(*event));
-    mMethod = mapFromKCalCore(msg->method());
-    return events;
-}
-
-ITipHandler::ITipMethod ITipHandler::method() const
-{
-    return mMethod;
-}
-
-std::string ITipHandler::toIMip(const Event &event , ITipHandler::ITipMethod m, std::string from, bool bccMe) const
-{
-    KCalCore::Event::Ptr e = Conversion::toKCalCore(event);
-//     e->recurrence()->addRDateTime(e->dtStart()); //FIXME The createScheduleMessage converts everything to utc without a recurrence.
-    KCalCore::ICalFormat format;
-    format.setApplication("libkolab", LIBKOLAB_LIB_VERSION_STRING);
-    KCalCore::iTIPMethod method = mapToKCalCore(m);
-    const QString &messageText = format.createScheduleMessage( e, method );
-    //This code is mostly from MailScheduler::performTransaction
-    if ( method == KCalCore::iTIPRequest ||
-        method == KCalCore::iTIPCancel ||
-        method == KCalCore::iTIPAdd ||
-        method == KCalCore::iTIPDeclineCounter ) {
-        return Conversion::toStdString(QString(mailAttendees(e, bccMe, messageText)));
-    } else {
-        QString subject;
-        if ( e && method == KCalCore::iTIPCounter ) {
-            subject = QString( "Counter proposal: %1" ).arg(e->summary());
-        }
-        return Conversion::toStdString(QString(mailOrganizer( e, Conversion::fromStdString(from), bccMe, messageText, subject)));
-    }
-    return std::string();
-}
-
-std::vector< Event > ITipHandler::fromIMip(const std::string &input)
-{
-    KMime::Message::Ptr msg = KMime::Message::Ptr(new KMime::Message);
-    msg->setContent( Conversion::fromStdString(input).toUtf8() );
-    msg->parse();
-    msg->content(KMime::ContentIndex());
-
-    KMime::Content *c = Kolab::Mime::findContentByType(msg, "text/calendar");
-    if (!c) {
-        qWarning() << "could not find text/calendar part";
-        return std::vector< Event >();
-    }
-    return fromITip(Conversion::toStdString(QString(c->decodedContent())));
-}
-
-
-
-
-}
diff --git a/icalendar/icalendar.h b/icalendar/icalendar.h
deleted file mode 100644
index 10f1267..0000000
--- a/icalendar/icalendar.h
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
-    <one line to give the library's name and an idea of what it does.>
-    Copyright (C) 2012  Christian Mollekopf <chrigi_1@fastmail.fm>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-
-#ifndef ICALENDAR_H
-#define ICALENDAR_H
-
-#ifndef SWIG
-#include "kolab_export.h"
-#else
-/* No export/import SWIG interface files */
-#define KOLAB_EXPORT
-#endif
-
-#include <kolabevent.h>
-
-namespace Kolab {
-
-    /**
-     * Takes a list of events and writes them to an iCal object.
-     *
-     */
-    KOLAB_EXPORT std::string toICal(const std::vector<Kolab::Event> &);
-    /**
-     * Takes an iCal object and returns the contained events.
-     */
-    KOLAB_EXPORT std::vector<Kolab::Event> fromICalEvents(const std::string &);
-
-    class KOLAB_EXPORT ITipHandler {
-    public:
-        ITipHandler();
-        enum ITipMethod {
-            iTIPPublish,       /**< Event, to-do, journal or freebusy posting */
-            iTIPRequest,       /**< Event, to-do or freebusy scheduling request */
-            iTIPReply,         /**< Event, to-do or freebusy reply to request */
-            iTIPAdd,           /**< Event, to-do or journal additional property request */
-            iTIPCancel,        /**< Event, to-do or journal cancellation notice */
-            iTIPRefresh,       /**< Event or to-do description update request */
-            iTIPCounter,       /**< Event or to-do submit counter proposal */
-            iTIPDeclineCounter,/**< Event or to-do decline a counter proposal */
-            iTIPNoMethod       /**< No method */
-        };
-        
-        std::string toIMip(const Kolab::Event &, ITipMethod, std::string from, bool bbcMe = false) const;
-        std::vector<Kolab::Event> fromIMip(const std::string &);
-
-        /**
-         * Create iTip message from single event
-         */
-        std::string toITip(const Kolab::Event &, ITipMethod) const;
-
-        /**
-         * Parse iTip message with a single event
-         */
-        std::vector<Kolab::Event> fromITip(const std::string &);
-        ITipMethod method() const;
-    private:
-        ITipMethod mMethod;
-    };
-
-
-}
-
-#endif // ICALENDAR_H
diff --git a/icalendar/icalendar.i b/icalendar/icalendar.i
deleted file mode 100644
index 62156e7..0000000
--- a/icalendar/icalendar.i
+++ /dev/null
@@ -1,13 +0,0 @@
-%{
-    /* This macro ensures that return vectors remain a vector also in python and are not converted to tuples */
-    #define SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
-
-    #include "icalendar.h"
-%}
-
-%include "std_string.i"
-
-%import(module="kolabformat") <kolabevent.h>
-%import "../shared.i"
-
-%include "icalendar.h"
\ No newline at end of file
diff --git a/icalendar/imip.cpp b/icalendar/imip.cpp
deleted file mode 100644
index 11e8962..0000000
--- a/icalendar/imip.cpp
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
-    <one line to give the library's name and an idea of what it does.>
-    Copyright (C) 2012  Christian Mollekopf <chrigi_1@fastmail.fm>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-
-#include "imip.h"
-
-#include <kcalutils/incidenceformatter.h>
-#include <kpimutils/email.h>
-#include <kmime/kmime_message.h>
-#include <QDebug>
-// #include <klocalizedstring.h>
-#include <ksystemtimezone.h>
-#include <kdebug.h>
-
-/*
- * The code in here is copy paste work from kdepim/calendarsupport.
- *
- * We need to refactor the code there and move the relevant parts to kdepimlibs to make it reusable.
- *
- *
- */
-
-//From MailClient::send
-KMime::Message::Ptr createMessage( const QString &from, const QString &_to,
-                       const QString &cc, const QString &subject,
-                       const QString &body, bool hidden, bool bccMe,
-                       const QString &attachment/*, const QString &mailTransport */)
-{
-  Q_UNUSED( hidden );
-
-  const bool outlookConformInvitation = false;
-  QString userAgent = "libkolab";
-
-  // We must have a recipients list for most MUAs. Thus, if the 'to' list
-  // is empty simply use the 'from' address as the recipient.
-  QString to = _to;
-  if ( to.isEmpty() ) {
-    to = from;
-  }
-  kDebug() << "\nFrom:" << from
-           << "\nTo:" << to
-           << "\nCC:" << cc
-           << "\nSubject:" << subject << "\nBody: \n" << body
-           << "\nAttachment:\n" << attachment
-           /*<< "\nmailTransport: " << mailTransport*/;
-
-  // Now build the message we like to send. The message KMime::Message::Ptr instance
-  // will be the root message that has 2 additional message. The body itself and
-  // the attached cal.ics calendar file.
-  KMime::Message::Ptr message = KMime::Message::Ptr( new KMime::Message );
-  message->contentTransferEncoding()->clear();  // 7Bit, decoded.
-
-  // Set the headers
-  message->userAgent()->fromUnicodeString(userAgent, "utf-8" );
-  message->from()->fromUnicodeString( from, "utf-8" );
-  message->to()->fromUnicodeString( to, "utf-8" );
-  message->cc()->fromUnicodeString( cc, "utf-8" );
-  if( bccMe ) {
-    message->bcc()->fromUnicodeString( from, "utf-8" ); //from==me, right?
-  }
-  message->date()->setDateTime( KDateTime::currentLocalDateTime() );
-  message->subject()->fromUnicodeString( subject, "utf-8" );
-
-  if ( outlookConformInvitation ) {
-    message->contentType()->setMimeType( "text/calendar" );
-    message->contentType()->setCharset( "utf-8" );
-    message->contentType()->setName( QLatin1String( "cal.ics" ), "utf-8" );
-    message->contentType()->setParameter( QLatin1String( "method" ), QLatin1String( "request" ) );
-
-    if ( !attachment.isEmpty() ) {
-      KMime::Headers::ContentDisposition *disposition =
-        new KMime::Headers::ContentDisposition( message.get() );
-      disposition->setDisposition( KMime::Headers::CDinline );
-      message->setHeader( disposition );
-      message->contentTransferEncoding()->setEncoding( KMime::Headers::CEquPr );
-      message->setBody( KMime::CRLFtoLF( attachment.toUtf8() ) );
-    }
-  } else {
-    // We need to set following 4 lines by hand else KMime::Content::addContent
-    // will create a new Content instance for us to attach the main message
-    // what we don't need cause we already have the main message instance where
-    // 2 additional messages are attached.
-    KMime::Headers::ContentType *ct = message->contentType();
-    ct->setMimeType( "multipart/mixed" );
-    ct->setBoundary( KMime::multiPartBoundary() );
-    ct->setCategory( KMime::Headers::CCcontainer );
-
-    // Set the first multipart, the body message.
-    KMime::Content *bodyMessage = new KMime::Content;
-    KMime::Headers::ContentDisposition *bodyDisposition =
-      new KMime::Headers::ContentDisposition( bodyMessage );
-    bodyDisposition->setDisposition( KMime::Headers::CDinline );
-    bodyMessage->contentType()->setMimeType( "text/plain" );
-    bodyMessage->contentType()->setCharset( "utf-8" );
-    bodyMessage->contentTransferEncoding()->setEncoding( KMime::Headers::CEquPr );
-    bodyMessage->setBody( KMime::CRLFtoLF( body.toUtf8() ) );
-    message->addContent( bodyMessage );
-
-    // Set the sedcond multipart, the attachment.
-    if ( !attachment.isEmpty() ) {
-      KMime::Content *attachMessage = new KMime::Content;
-      KMime::Headers::ContentDisposition *attachDisposition =
-        new KMime::Headers::ContentDisposition( attachMessage );
-      attachDisposition->setDisposition( KMime::Headers::CDattachment );
-      attachMessage->contentType()->setMimeType( "text/calendar" );
-      attachMessage->contentType()->setCharset( "utf-8" );
-      attachMessage->contentType()->setName( QLatin1String( "cal.ics" ), "utf-8" );
-      attachMessage->contentType()->setParameter( QLatin1String( "method" ),
-                                                  QLatin1String( "request" ) );
-      attachMessage->setHeader( attachDisposition );
-      attachMessage->contentTransferEncoding()->setEncoding( KMime::Headers::CEquPr );
-      attachMessage->setBody( KMime::CRLFtoLF( attachment.toUtf8() ) );
-      message->addContent( attachMessage );
-    }
-  }
-
-  // Job done, attach the both multiparts and assemble the message.
-  message->assemble();
-  return message;
-}
-
-//From MailClient::mailAttendees
-QByteArray mailAttendees( const KCalCore::IncidenceBase::Ptr &incidence,
-//                                 const KPIMIdentities::Identity &identity,
-                                bool bccMe, const QString &attachment
-                                /*const QString &mailTransport */)
-{
-  KCalCore::Attendee::List attendees = incidence->attendees();
-  if ( attendees.isEmpty() ) {
-    kWarning() << "There are no attendees to e-mail";
-    return QByteArray();
-  }
-
-  const QString from = incidence->organizer()->fullName();
-  const QString organizerEmail = incidence->organizer()->email();
-
-  QStringList toList;
-  QStringList ccList;
-  const int numberOfAttendees( attendees.count() );
-  for ( int i=0; i<numberOfAttendees; ++i ) {
-    KCalCore::Attendee::Ptr a = attendees.at(i);
-
-    const QString email = a->email();
-    if ( email.isEmpty() ) {
-      continue;
-    }
-
-    // In case we (as one of our identities) are the organizer we are sending
-    // this mail. We could also have added ourselves as an attendee, in which
-    // case we don't want to send ourselves a notification mail.
-    if ( organizerEmail == email ) {
-      continue;
-    }
-
-    // Build a nice address for this attendee including the CN.
-    QString tname, temail;
-    const QString username = KPIMUtils::quoteNameIfNecessary( a->name() );
-    // ignore the return value from extractEmailAddressAndName() because
-    // it will always be false since tusername does not contain "@domain".
-    KPIMUtils::extractEmailAddressAndName( username, temail/*byref*/, tname/*byref*/ );
-    tname += QLatin1String( " <" ) + email + QLatin1Char( '>' );
-
-    // Optional Participants and Non-Participants are copied on the email
-    if ( a->role() == KCalCore::Attendee::OptParticipant ||
-         a->role() == KCalCore::Attendee::NonParticipant ) {
-      ccList << tname;
-    } else {
-      toList << tname;
-    }
-  }
-  if( toList.isEmpty() && ccList.isEmpty() ) {
-    // Not really to be called a groupware meeting, eh
-    kWarning() << "There are really no attendees to e-mail";
-    return QByteArray();
-  }
-  QString to;
-  if ( !toList.isEmpty() ) {
-    to = toList.join( QLatin1String( ", " ) );
-  }
-  QString cc;
-  if ( !ccList.isEmpty() ) {
-    cc = ccList.join( QLatin1String( ", " ) );
-  }
-
-  QString subject;
-  if ( incidence->type() != KCalCore::Incidence::TypeFreeBusy ) {
-    KCalCore::Incidence::Ptr inc = incidence.staticCast<KCalCore::Incidence>();
-    subject = inc->summary();
-  } else {
-    subject = QString( "Free Busy Object" );
-  }
-
-  const QString body =
-    KCalUtils::IncidenceFormatter::mailBodyStr( incidence, KSystemTimeZones::local() );
-
-  return createMessage(/* identity, */from, to, cc, subject, body, false,
-               bccMe, attachment/*, mailTransport */)->encodedContent();
-}
-
-QByteArray mailOrganizer( const KCalCore::IncidenceBase::Ptr &incidence,
-//                                 const KPIMIdentities::Identity &identity,
-                                const QString &from, bool bccMe,
-                                const QString &attachment,
-                                const QString &sub/*, const QString &mailTransport*/ )
-{
-  const QString to = incidence->organizer()->fullName();
-  QString subject = sub;
-
-  if ( incidence->type() != KCalCore::Incidence::TypeFreeBusy ) {
-    KCalCore::Incidence::Ptr inc = incidence.staticCast<KCalCore::Incidence>();
-    if ( subject.isEmpty() ) {
-      subject = inc->summary();
-    }
-  } else {
-    subject = QString( "Free Busy Message" );
-  }
-
-  QString body = KCalUtils::IncidenceFormatter::mailBodyStr( incidence, KSystemTimeZones::local() );
-
-  return createMessage( /*identity, */from, to, QString(), subject, body, false,
-               bccMe, attachment/*, mailTransport */)->encodedContent();
-}
-
diff --git a/icalendar/imip.h b/icalendar/imip.h
deleted file mode 100644
index 2ee747e..0000000
--- a/icalendar/imip.h
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
-    <one line to give the library's name and an idea of what it does.>
-    Copyright (C) 2012  Christian Mollekopf <chrigi_1@fastmail.fm>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
-*/
-
-
-#ifndef IMIP_H
-#define IMIP_H
-#include <QByteArray>
-#include <kcalcore/incidencebase.h>
-
-QByteArray mailAttendees( const KCalCore::IncidenceBase::Ptr &incidence,
-                                bool bccMe, const QString &attachment );
-
-QByteArray mailOrganizer( const KCalCore::IncidenceBase::Ptr &incidence,
-                                const QString &from, bool bccMe,
-                                const QString &attachment,
-                                const QString &sub );
-
-#endif // IMIP_H
diff --git a/icalendar/php/CMakeLists.txt b/icalendar/php/CMakeLists.txt
deleted file mode 100644
index 3aea015..0000000
--- a/icalendar/php/CMakeLists.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-#Generate PHP wrapper
-include_directories(../)
-include(SWIGUtils)
-generatePHPBindings(kolabicalendar ../icalendar.i)
diff --git a/icalendar/python/CMakeLists.txt b/icalendar/python/CMakeLists.txt
deleted file mode 100644
index 0b842a4..0000000
--- a/icalendar/python/CMakeLists.txt
+++ /dev/null
@@ -1,3 +0,0 @@
-include_directories(../)
-include(SWIGUtils)
-generatePythonBindings(icalendar ../icalendar.i)
diff --git a/kolab_export.h b/kolab_export.h
deleted file mode 100644
index d242045..0000000
--- a/kolab_export.h
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- *  This file is part of libkolab.
- *  Copyright (c) 2012 Christian Mollekopf <mollekopf@kolabsys.com>
- * 
- *  This library is free software; you can redistribute it and/or
- *  modify it under the terms of the GNU Library General Public
- *  License as published by the Free Software Foundation; either
- *  version 2 of the License, or (at your option) any later version.
- * 
- *  This library is distributed in the hope that it will be useful,
- *  but WITHOUT ANY WARRANTY; without even the implied warranty of
- *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- *  Library General Public License for more details.
- * 
- *  You should have received a copy of the GNU Library General Public License
- *  along with this library; see the file COPYING.LIB.  If not, write to
- *  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
- *  Boston, MA 02110-1301, USA.
- */
-
-#ifndef KOLAB_EXPORT_H
-#define KOLAB_EXPORT_H
-
-// #include <kdemacros.h>
-
-#ifndef KOLAB_EXPORT
-# if defined(KOLAB_STATIC_LIBS)
-/* No export/import for static libraries */
-#  define KOLAB_EXPORT
-# elif defined(MAKE_KOLAB_LIB)
-/* We are building this library */
-#  define KOLAB_EXPORT __attribute__ ((visibility("default")))
-# else
-/* We are using this library */
-#  define KOLAB_EXPORT __attribute__ ((visibility("default")))
-# endif
-#endif
-
-# ifndef KOLAB_EXPORT_DEPRECATED
-#  define KOLAB_EXPORT_DEPRECATED KDE_DEPRECATED __attribute__ ((visibility("default")))
-# endif
-
-/**
- *  @namespace Kolab
- * 
- *  @brief
- *  Contains all the KOLAB library global classes, objects, and functions.
- */
-
-#endif
diff --git a/kolabformat/errorhandler.cpp b/kolabformat/errorhandler.cpp
deleted file mode 100644
index 91021f4..0000000
--- a/kolabformat/errorhandler.cpp
+++ /dev/null
@@ -1,138 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-
-#include "errorhandler.h"
-
-#include <qdebug.h>
-#include <QTime>
-#include <QStringList>
-#include <qmutex.h>
-#include <iostream>
-
-#include <kolabformat.h>
-
-QDebug operator<<(QDebug dbg, const std::string &s)
-{
-    dbg.nospace() << QString::fromStdString(s);
-    return dbg.space();
-}
-
-namespace Kolab {
-
-DebugStream::DebugStream()
-:   QIODevice()
-{
-    open(WriteOnly);
-}
-
-DebugStream::~DebugStream(){}
-
-qint64 DebugStream::writeData(const char *data, qint64 len) {
-    const QByteArray buf = QByteArray::fromRawData(data, len);
-//         qt_message_output(QtDebugMsg, buf.trimmed().constData());
-    ErrorHandler::instance().addError(m_severity, buf, m_location);
-    return len;
-}
-
-
-QMutex mutex;
-    
-void logMessage(const QString &message, const QString &file, int line, ErrorHandler::Severity s)
-{
-    ErrorHandler::instance().addError(s, message, file+" "+QString::number(line));
-}
-
-ErrorHandler::ErrorHandler()
-:   m_worstError(Debug),
-    m_debugStream(new DebugStream)
-{
-
-};
-
-QDebug ErrorHandler::debugStream(ErrorHandler::Severity severity, int line, const char* file)
-{
-    QMutexLocker locker(&mutex);
-    ErrorHandler::instance().m_debugStream->m_location = QString(QString(file) + "(" + QString::number(line)+")");
-    ErrorHandler::instance().m_debugStream->m_severity = severity;
-    return QDebug(ErrorHandler::instance().m_debugStream.data());
-}
-
-void ErrorHandler::addError(ErrorHandler::Severity s, const QString& message, const QString &location)
-{
-    QMutexLocker locker(&mutex);
-    QString filename = location;
-    if (!filename.split(QLatin1Char('/')).isEmpty()) {
-       filename = filename.split(QLatin1Char('/')).last();
-    }
-    const QString output = QTime::currentTime().toString(QLatin1String("(hh:mm:ss) ")) + filename + QLatin1String(":\t") + message;
-    std::cout << output.toStdString() << std::endl;
-    if (s == Debug) {
-        return;
-    }
-    if (s > m_worstError) {
-        m_worstError = s;
-        m_worstErrorMessage = message;
-    }
-    m_errorQueue.append(Err(s, message, location));
-}
-
-ErrorHandler::Severity ErrorHandler::error() const
-{
-    QMutexLocker locker(&mutex);
-    return m_worstError;
-}
-
-QString ErrorHandler::errorMessage() const
-{
-    QMutexLocker locker(&mutex);
-    return m_worstErrorMessage;
-}
-
-const QList< ErrorHandler::Err >& ErrorHandler::getErrors() const
-{
-    QMutexLocker locker(&mutex);
-    return m_errorQueue;
-}
-
-void ErrorHandler::clear()
-{
-    QMutexLocker locker(&mutex);
-    m_errorQueue.clear();
-    m_worstError = Debug;
-}
-
-void ErrorHandler::handleLibkolabxmlErrors()
-{
-    switch (Kolab::error()) {
-        case Kolab::Warning:
-            instance().addError(ErrorHandler::Warning, QString::fromStdString(Kolab::errorMessage()), "libkolabxml");
-            break;
-        case Kolab::Error:
-            instance().addError(ErrorHandler::Error, QString::fromStdString(Kolab::errorMessage()), "libkolabxml");
-            break;
-        case Kolab::Critical:
-            instance().addError(ErrorHandler::Critical, QString::fromStdString(Kolab::errorMessage()), "libkolabxml");
-            break;
-        default:
-            //Do nothing, there is no message available in this case
-            break;
-    }
-}
-
-
-}
diff --git a/kolabformat/errorhandler.h b/kolabformat/errorhandler.h
deleted file mode 100644
index 2a3d34e..0000000
--- a/kolabformat/errorhandler.h
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-
-#ifndef ERRORHANDLER_H
-#define ERRORHANDLER_H
-
-#include <kolab_export.h>
-
-#include <QString>
-#include <QList>
-#include <QDebug>
-
-namespace Kolab {
-
-class DebugStream;
-/**
- * Kolab Error Handler
- * 
- * Errors are reported during an operation, but the operation might still succeed.
- * The error handler therefore contains all errors which occured during a single operation,
- * and must be cleared at the start of a new operation.
- * 
- * A user of the kolabobject classes should check ErrorHandler::error() after every operation.
- * 
- * all non-const functions are not for the user of this class and only exist for internal usage.
- * 
- * TODO: Hide everything which is not meant for the user from the interface.
- * FIXME: Use Threadlocal storage to make this threadsafe.
- */
-class KOLAB_EXPORT ErrorHandler
-{
-public:
-    enum Severity {
-        Debug,
-        Warning, //Warning, error could be corrected, object can be used without dataloss. This warning is also used if dataloss is acceptable because a feature is explicitly not supported.
-        Error, //Potentially corrupt object, writing the object back could result in dataloss. (Object could still be used to display the data readonly).
-        Critical //Critical error, produced object cannot be used and should be thrown away (writing back will result in dataloss).
-    };
-    
-    struct Err {
-        Err(Severity s, const QString &m, const QString &l): severity(s), message(m), location(l){};
-        Severity severity;
-        QString message;
-        QString location;
-    };
-    
-    static ErrorHandler &instance()
-    {
-        static ErrorHandler inst;
-        return inst;
-    }
-    
-    void addError(Severity s, const QString &message, const QString &location);
-    const QList <Err> &getErrors() const;
-    Severity error() const;
-    QString errorMessage() const;
-    void clear();
-    
-    /**
-     * Check for errors during the libkolabxml reading/writing process and copy them into this error handler.
-     */
-    static void handleLibkolabxmlErrors();
-    
-    static void clearErrors()
-    {
-        ErrorHandler::instance().clear();
-    }
-    
-    static bool errorOccured()
-    {
-        if (ErrorHandler::instance().error() >= Error) {
-            return true;
-        }
-        return false;
-    }
-    
-    /**
-     * Returns a debug stream to which logs errors
-     */
-    static QDebug debugStream(Severity, int line, const char* file);
-
-private:
-    ErrorHandler();
-    ErrorHandler(const ErrorHandler &);
-    ErrorHandler & operator= (const ErrorHandler &);
-    
-    Severity m_worstError;
-    QString m_worstErrorMessage;
-    QList <Err> m_errorQueue;
-    QScopedPointer<DebugStream> m_debugStream;
-};
-
-void logMessage(const QString &,const QString &, int, ErrorHandler::Severity s);
-
-#define LOG(message) logMessage(message,__FILE__, __LINE__, ErrorHandler::Debug);
-#define WARNING(message) logMessage(message,__FILE__, __LINE__, ErrorHandler::Warning);
-#define ERROR(message) logMessage(message,__FILE__, __LINE__, ErrorHandler::Error);
-#define CRITICAL(message) logMessage(message,__FILE__, __LINE__, ErrorHandler::Critical);
-
-
-class DebugStream: public QIODevice
-{
-public:
-    QString m_location;
-    ErrorHandler::Severity m_severity;
-    DebugStream();
-    virtual ~DebugStream();
-    bool isSequential() const { return true; }
-    qint64 readData(char *, qint64) { return 0; /* eof */ }
-    qint64 readLineData(char *, qint64) { return 0; /* eof */ }
-    qint64 writeData(const char *data, qint64 len);
-private:
-    Q_DISABLE_COPY(DebugStream)
-};
-
-#define Debug() Kolab::ErrorHandler::debugStream(Kolab::ErrorHandler::Debug, __LINE__, __FILE__)
-#define Warning() Kolab::ErrorHandler::debugStream(Kolab::ErrorHandler::Warning, __LINE__, __FILE__)
-#define Error() Kolab::ErrorHandler::debugStream(Kolab::ErrorHandler::Error, __LINE__, __FILE__)
-#define Critical() Kolab::ErrorHandler::debugStream(Kolab::ErrorHandler::Critical, __LINE__, __FILE__)
-
-}
-
-QDebug operator<<(QDebug dbg, const std::string &s);
-
-#endif // ERRORHANDLER_H
diff --git a/kolabformat/formathelpers.cpp b/kolabformat/formathelpers.cpp
deleted file mode 100644
index b376b8c..0000000
--- a/kolabformat/formathelpers.cpp
+++ /dev/null
@@ -1,95 +0,0 @@
-#include "formathelpers.h"
-#include <klocalizedstring.h>
-#include "kolabdefinitions.h"
-
-namespace Kolab {
-
-static const struct {
-  const char *name;
-  const char *label;
-} folderTypeData[] = {
-  { KOLAB_FOLDER_TYPE_MAIL,    ""                      },
-  { KOLAB_FOLDER_TYPE_CONTACT, I18N_NOOP( "Contacts" ) },
-  { KOLAB_FOLDER_TYPE_EVENT,   I18N_NOOP( "Calendar" ) },
-  { KOLAB_FOLDER_TYPE_TASK,    I18N_NOOP( "Tasks" )    },
-  { KOLAB_FOLDER_TYPE_JOURNAL, I18N_NOOP( "Journal" )  },
-  { KOLAB_FOLDER_TYPE_NOTE,    I18N_NOOP( "Notes" )    },
-  { KOLAB_FOLDER_TYPE_CONFIGURATION, I18N_NOOP( "Configuration" )    },
-  { KOLAB_FOLDER_TYPE_FREEBUSY,    I18N_NOOP( "Freebusy" ) },
-  { KOLAB_FOLDER_TYPE_FILE,    I18N_NOOP( "Files" ) }
-};
-static const int numFolderTypeData = sizeof folderTypeData / sizeof *folderTypeData;
-
-std::string folderAnnotation(FolderType type, bool isDefault)
-{
-    Q_ASSERT( type >= 0 && type < LastType );
-    std::string result = folderTypeData[ type ].name;
-    if ( isDefault ) {
-        result += KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX;
-    }
-    return result;
-}
-
-FolderType folderTypeFromString(const std::string& folderTypeName)
-{
-    if ( folderTypeName == KOLAB_FOLDER_TYPE_CONTACT ||
-    folderTypeName == KOLAB_FOLDER_TYPE_CONTACT KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
-        return ContactType;
-    }
-
-    if ( folderTypeName == KOLAB_FOLDER_TYPE_EVENT ||
-        folderTypeName == KOLAB_FOLDER_TYPE_EVENT KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
-        return EventType;
-    }
-
-    if ( folderTypeName == KOLAB_FOLDER_TYPE_TASK ||
-        folderTypeName == KOLAB_FOLDER_TYPE_TASK KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
-        return TaskType;
-    }
-
-    if ( folderTypeName == KOLAB_FOLDER_TYPE_JOURNAL ||
-        folderTypeName == KOLAB_FOLDER_TYPE_JOURNAL KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
-        return JournalType;
-    }
-
-    if ( folderTypeName == KOLAB_FOLDER_TYPE_NOTE ||
-        folderTypeName == KOLAB_FOLDER_TYPE_NOTE KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
-        return NoteType;
-    }
-    
-    if ( folderTypeName == KOLAB_FOLDER_TYPE_CONFIGURATION ||
-        folderTypeName == KOLAB_FOLDER_TYPE_CONFIGURATION KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
-        return ConfigurationType;
-    }
-    
-    if ( folderTypeName == KOLAB_FOLDER_TYPE_FREEBUSY ||
-        folderTypeName == KOLAB_FOLDER_TYPE_FREEBUSY KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
-        return FreebusyType;
-    }
-
-    if ( folderTypeName == KOLAB_FOLDER_TYPE_FILE ||
-        folderTypeName == KOLAB_FOLDER_TYPE_FILE KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
-        return FileType;
-    }
-
-    return MailType;
-}
-
-FolderType guessFolderTypeFromName(const std::string& name)
-{
-    for ( int i = 0; i < numFolderTypeData; ++i ) {
-        if ( name == i18n( folderTypeData[ i ].label ).toStdString() ||
-            name == folderTypeData[ i ].label ) {
-            return static_cast<FolderType>( i );
-        }
-    }
-    return MailType;
-}
-
-std::string nameForFolderType(FolderType type)
-{
-    Q_ASSERT( type >= 0 && type < LastType );
-    return i18n( folderTypeData[ type ].label ).toStdString();
-}
-
-}
diff --git a/kolabformat/formathelpers.h b/kolabformat/formathelpers.h
deleted file mode 100644
index 08a1fd4..0000000
--- a/kolabformat/formathelpers.h
+++ /dev/null
@@ -1,43 +0,0 @@
-
-#ifndef FORMATHELPERS_H
-#define FORMATHELPERS_H
-
-#include <kolab_export.h>
-#include <string>
-
-namespace Kolab {
-    
-enum FolderType {
-    MailType = 0,
-    ContactType,
-    EventType,
-    TaskType,
-    JournalType,
-    NoteType,
-    ConfigurationType,
-    FreebusyType,
-    FileType,
-    LastType
-};
-
-/**
- * Returns the FolderType from a KOLAB_FOLDER_TYPE_* folder type string
- */
-KOLAB_EXPORT FolderType folderTypeFromString( const std::string &folderTypeName );
-/**
- * Returns the annotation string for a folder
- */
-KOLAB_EXPORT std::string folderAnnotation( FolderType type, bool isDefault = false );
-/**
- * Guesses the folder type from a user visible string
- */
-KOLAB_EXPORT FolderType guessFolderTypeFromName( const std::string &name );
-
-/**
- * Returns a folder name for a type
- */
-KOLAB_EXPORT std::string nameForFolderType( FolderType type );
-
-}
-
-#endif
diff --git a/kolabformat/kolabdefinitions.h b/kolabformat/kolabdefinitions.h
deleted file mode 100644
index e1d8e93..0000000
--- a/kolabformat/kolabdefinitions.h
+++ /dev/null
@@ -1,88 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef KOLABDEFINITIONS_H
-#define KOLABDEFINITIONS_H
-
-namespace Kolab {
-
-#define KOLAB_FOLDER_TYPE_MAIL    "mail"
-#define KOLAB_FOLDER_TYPE_CONTACT "contact"
-#define KOLAB_FOLDER_TYPE_EVENT   "event"
-#define KOLAB_FOLDER_TYPE_TASK    "task"
-#define KOLAB_FOLDER_TYPE_JOURNAL "journal"
-#define KOLAB_FOLDER_TYPE_NOTE    "note"
-#define KOLAB_FOLDER_TYPE_CONFIGURATION "configuration"
-#define KOLAB_FOLDER_TYPE_FREEBUSY      "freebusy"
-#define KOLAB_FOLDER_TYPE_FILE    "file"
-
-#define KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ".default"
-#define KOLAB_FOLDER_TYPE_DRAFT_SUFFIX ".drafts"
-#define KOLAB_FOLDER_TYPE_SENT_SUFFIX ".sentitems"
-#define KOLAB_FOLDER_TYPE_OUTBOX_SUFFIX ".outbox"
-#define KOLAB_FOLDER_TYPE_TRASH_SUFFIX ".wastebasket"
-#define KOLAB_FOLDER_TYPE_JUNK_SUFFIX ".junkemail"
-#define KOLAB_FOLDER_TYPE_INBOX_SUFFIX ".inbox"
-
-#define KOLAB_FOLDER_TYPE_ANNOTATION "/vendor/kolab/folder-type"
-
-#define X_KOLAB_TYPE_HEADER "X-Kolab-Type"
-#define X_KOLAB_MIME_VERSION_HEADER "X-Kolab-Mime-Version"
-#define X_KOLAB_MIME_VERSION_HEADER_COMPAT "X-Kolab-Version"
-#define KOLAB_VERSION_V2 "2.0"
-#define KOLAB_VERSION_V3 "3.0"
-
-#define KOLAB_OBJECT_FILENAME "kolab.xml"
-
-#define MIME_TYPE_XCAL "application/calendar+xml"
-#define MIME_TYPE_XCARD "application/vcard+xml"
-#define MIME_TYPE_KOLAB "application/vnd.kolab+xml"
-
-#define KOLAB_TYPE_EVENT    "application/x-vnd.kolab.event"
-#define KOLAB_TYPE_TASK    "application/x-vnd.kolab.task"
-#define KOLAB_TYPE_JOURNAL    "application/x-vnd.kolab.journal"
-#define KOLAB_TYPE_CONTACT    "application/x-vnd.kolab.contact"
-#define KOLAB_TYPE_DISTLIST_V2    "application/x-vnd.kolab.contact.distlist"
-#define KOLAB_TYPE_DISTLIST  "application/x-vnd.kolab.distribution-list"
-#define KOLAB_TYPE_NOTE   "application/x-vnd.kolab.note"
-#define KOLAB_TYPE_CONFIGURATION    "application/x-vnd.kolab.configuration"
-#define KOLAB_TYPE_DICT    "application/x-vnd.kolab.configuration.dictionary"
-#define KOLAB_TYPE_FREEBUSY    "application/x-vnd.kolab.freebusy"
-#define KOLAB_TYPE_FILE    "application/x-vnd.kolab.file"
-#define KOLAB_TYPE_RELATION "application/x-vnd.kolab.configuration.relation"
-
-enum Version {
-    KolabV2,
-    KolabV3
-};
-
-enum ObjectType {
-    InvalidObject,
-    EventObject,
-    TodoObject,
-    JournalObject,
-    ContactObject,
-    DistlistObject,
-    NoteObject,
-    DictionaryConfigurationObject,
-    FreebusyObject,
-    RelationConfigurationObject
-};
-
-}
-
-#endif
diff --git a/kolabformat/kolabobject.cpp b/kolabformat/kolabobject.cpp
deleted file mode 100644
index 90b4e78..0000000
--- a/kolabformat/kolabobject.cpp
+++ /dev/null
@@ -1,751 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-
-#include "kolabobject.h"
-#include "v2helpers.h"
-#include "kolabdefinitions.h"
-#include "errorhandler.h"
-#include "libkolab-version.h"
-
-#include <kolabbase.h>
-#include <kolabformatV2/journal.h>
-#include <kolabformatV2/task.h>
-#include <kolabformatV2/event.h>
-#include <kolabformatV2/contact.h>
-#include <kolabformatV2/distributionlist.h>
-#include <kolabformatV2/note.h>
-#include <mime/mimeutils.h>
-#include <conversion/kcalconversion.h>
-#include <conversion/kabcconversion.h>
-#include <conversion/kolabconversion.h>
-#include <conversion/commonconversion.h>
-#include <akonadi/notes/noteutils.h>
-#include <kolabformat.h>
-
-
-namespace Kolab {
-
-
-static inline QString eventKolabType() { return QString::fromLatin1(KOLAB_TYPE_EVENT); };
-static inline QString todoKolabType() { return QString::fromLatin1(KOLAB_TYPE_TASK); };
-static inline QString journalKolabType() { return QString::fromLatin1(KOLAB_TYPE_JOURNAL); };
-static inline QString contactKolabType() { return QString::fromLatin1(KOLAB_TYPE_CONTACT); };
-static inline QString distlistKolabType() { return QString::fromLatin1(KOLAB_TYPE_DISTLIST); }
-static inline QString distlistKolabTypeCompat() { return QString::fromLatin1(KOLAB_TYPE_DISTLIST_V2); }
-static inline QString noteKolabType() { return QString::fromLatin1(KOLAB_TYPE_NOTE); }
-static inline QString configurationKolabType() { return QString::fromLatin1(KOLAB_TYPE_CONFIGURATION); }
-static inline QString dictKolabType() { return QString::fromLatin1(KOLAB_TYPE_DICT); }
-static inline QString freebusyKolabType() { return QString::fromLatin1(KOLAB_TYPE_FREEBUSY); }
-static inline QString relationKolabType() { return QString::fromLatin1(KOLAB_TYPE_RELATION); }
-
-static inline QString xCalMimeType() { return QString::fromLatin1(MIME_TYPE_XCAL); };
-static inline QString xCardMimeType() { return QString::fromLatin1(MIME_TYPE_XCARD); };
-static inline QString kolabMimeType() { return QString::fromLatin1(MIME_TYPE_KOLAB); };
-
-KCalCore::Event::Ptr readV2EventXML(const QByteArray& xmlData, QStringList& attachments)
-{
-    return fromXML<KCalCore::Event::Ptr, KolabV2::Event>(xmlData, attachments);
-}
-
-RelationMember parseMemberUrl(const QString &string)
-{
-    RelationMember member;
-    QUrl url(QUrl::fromPercentEncoding(string.toLatin1()));
-    QList<QByteArray> path = url.encodedPath().split('/');
-    // qDebug() << path;
-    int start = path.indexOf("user");
-    if (start < 0) {
-        kWarning() << "Couldn't find \"user\" in path: " << path;
-        return RelationMember();
-    }
-    path = path.mid(start + 1);
-    if (path.size() < 2) {
-        kWarning() << "Incomplete path: " << path;
-        return RelationMember();
-    }
-    // user-name
-    path.removeFirst();
-    member.uid = path.takeLast().toLong();
-    member.mailbox = path;
-    member.messageId = url.queryItemValue("message-id");
-    member.subject = url.queryItemValue("subject");
-    member.date = url.queryItemValue("date");
-    // qDebug() << member.uid << member.mailbox;
-    return member;
-}
-
-static QByteArray join(const QList<QByteArray> &list, const QByteArray &c)
-{
-    QByteArray result;
-    Q_FOREACH (const QByteArray &a, list) {
-        result += a + c;
-    }
-    result.chop(c.size());
-    return result;
-}
-
-KOLAB_EXPORT QString generateMemberUrl(const RelationMember &member)
-{
-    QUrl url;
-    url.setScheme("imap");
-    QList<QByteArray> path;
-    path << "user";
-    path << "localuser@localhost";
-    path << member.mailbox;
-    path << QByteArray::number(member.uid);
-    url.setPath("/" + join(path, "/"));
-
-    QList<QPair<QString, QString> > queryItems;
-    queryItems.append(qMakePair(QString::fromLatin1("message-id"), member.messageId));
-    queryItems.append(qMakePair(QString::fromLatin1("subject"), member.subject));
-    queryItems.append(qMakePair(QString::fromLatin1("date"), member.date));
-    url.setQueryItems(queryItems);
-
-    return QString::fromLatin1(url.toEncoded());
-}
-
-//@cond PRIVATE
-class KolabObjectReader::Private
-{
-public:
-    Private()
-    :   mObjectType( InvalidObject ),
-        mVersion( KolabV3 ),
-        mOverrideObjectType(InvalidObject),
-        mDoOverrideVersion(false)
-    {
-        mAddressee = KABC::Addressee();
-    }
-
-    ObjectType readKolabV2(const KMime::Message::Ptr &msg, Kolab::ObjectType objectType);
-    ObjectType readKolabV3(const KMime::Message::Ptr &msg, Kolab::ObjectType objectType);
-    
-    KCalCore::Incidence::Ptr mIncidence;
-    KABC::Addressee mAddressee;
-    KABC::ContactGroup mContactGroup;
-    KMime::Message::Ptr mNote;
-    QStringList mDictionary;
-    QString mDictionaryLanguage;
-    ObjectType mObjectType;
-    Version mVersion;
-    Kolab::Freebusy mFreebusy;
-    Akonadi::Tag mTag;
-    QStringList mTagMembers;
-    ObjectType mOverrideObjectType;
-    Version mOverrideVersion;
-    bool mDoOverrideVersion;
-};
-//@endcond
-
-KolabObjectReader::KolabObjectReader()
-: d( new KolabObjectReader::Private )
-{
-}
-
-KolabObjectReader::KolabObjectReader(const KMime::Message::Ptr& msg)
-: d( new KolabObjectReader::Private )
-{
-    parseMimeMessage(msg);
-}
-
-KolabObjectReader::~KolabObjectReader()
-{
-    delete d;
-}
-
-void KolabObjectReader::setObjectType(ObjectType type)
-{
-    d->mOverrideObjectType = type;
-}
-
-void KolabObjectReader::setVersion(Version version)
-{
-    d->mOverrideVersion = version;
-    d->mDoOverrideVersion = true;
-}
-
-Kolab::ObjectType getObjectType(const QString &type)
-{
-    if (type == eventKolabType()) {
-        return EventObject;
-    } else if (type == todoKolabType()) {
-        return TodoObject;
-    } else if (type == journalKolabType()) {
-        return JournalObject;
-    } else if (type == contactKolabType()) {
-        return ContactObject;
-    } else if (type == distlistKolabType() || type == distlistKolabTypeCompat()) {
-        return DistlistObject;
-    } else if (type == noteKolabType()) {
-        return NoteObject;
-    } else if (type == freebusyKolabType()) {
-        return FreebusyObject;
-    } else if (type.contains(dictKolabType())) { //Previous versions appended the language to the type
-        return DictionaryConfigurationObject;
-    } else if (type == relationKolabType()) {
-        return RelationConfigurationObject;
-    }
-    Warning() << "Unknown object type: " << type;
-    return Kolab::InvalidObject;
-}
-
-QByteArray getTypeString(Kolab::ObjectType type)
-{
-    switch (type) {
-        case EventObject:
-            return KOLAB_TYPE_EVENT;
-        case TodoObject:
-            return KOLAB_TYPE_TASK;
-        case JournalObject:
-            return KOLAB_TYPE_JOURNAL;
-        case FreebusyObject:
-            return KOLAB_TYPE_FREEBUSY;
-        case ContactObject:
-            return KOLAB_TYPE_CONTACT;
-        case DistlistObject:
-            return KOLAB_TYPE_DISTLIST;
-        case NoteObject:
-            return KOLAB_TYPE_NOTE;
-        case DictionaryConfigurationObject:
-            return KOLAB_TYPE_CONFIGURATION;
-        case RelationConfigurationObject:
-            return KOLAB_TYPE_RELATION;
-        default:
-            Critical() << "unknown type "<< type;
-    }
-    return QByteArray();
-}
-
-QByteArray getMimeType(Kolab::ObjectType type)
-{
-    switch (type) {
-        case EventObject:
-        case TodoObject:
-        case JournalObject:
-        case FreebusyObject:
-            return MIME_TYPE_XCAL;
-        case ContactObject:
-        case DistlistObject:
-            return MIME_TYPE_XCARD;
-        case NoteObject:
-        case DictionaryConfigurationObject:
-        case RelationConfigurationObject:
-            return MIME_TYPE_KOLAB;
-        default:
-            Critical() << "unknown type "<< type;
-    }
-    return QByteArray();
-}
-
-Kolab::ObjectType detectType(const KMime::Message::Ptr &msg)
-{
-    Q_FOREACH(const QByteArray &type, Mime::getContentMimeTypeList(msg)) {
-        Kolab::ObjectType t = getObjectType(type); //works for v2 types
-        if (t != InvalidObject) {
-            return t;
-        }
-    }
-    return InvalidObject;
-}
-
-void printMessageDebugInfo(const KMime::Message::Ptr &msg)
-{
-    //TODO replace by Debug stream for Mimemessage
-    Debug() << "MessageId: " << msg->messageID()->asUnicodeString();
-    Debug() << "Subject: " << msg->subject()->asUnicodeString();
-//     Debug() << msg->encodedContent();
-}
-
-ObjectType KolabObjectReader::Private::readKolabV2(const KMime::Message::Ptr &msg, Kolab::ObjectType objectType)
-{
-    if (objectType == DictionaryConfigurationObject) {
-        KMime::Content *xmlContent = Mime::findContentByType( msg, "application/xml" );
-        if ( !xmlContent ) {
-            Critical() << "no application/xml part found";
-            printMessageDebugInfo(msg);
-            return InvalidObject;
-        }
-        const QByteArray &xmlData = xmlContent->decodedContent();
-        mDictionary = readLegacyDictionaryConfiguration(xmlData, mDictionaryLanguage);
-        mObjectType = objectType;
-        return mObjectType;
-    }
-    KMime::Content *xmlContent = Mime::findContentByType( msg, getTypeString(objectType)  );
-    if ( !xmlContent ) {
-        Critical() << "no part with type" << getTypeString(objectType) << " found";
-        printMessageDebugInfo(msg);
-        return InvalidObject;
-    }
-    const QByteArray &xmlData = xmlContent->decodedContent();
-    Q_ASSERT(!xmlData.isEmpty());
-    QStringList attachments;
-
-    switch (objectType) {
-        case EventObject:
-            mIncidence = fromXML<KCalCore::Event::Ptr, KolabV2::Event>(xmlData, attachments);
-            break;
-        case TodoObject:
-            mIncidence = fromXML<KCalCore::Todo::Ptr, KolabV2::Task>(xmlData, attachments);
-            break;
-        case JournalObject:
-            mIncidence = fromXML<KCalCore::Journal::Ptr, KolabV2::Journal>(xmlData, attachments);
-            break;
-        case ContactObject:
-            mAddressee = addresseeFromKolab(xmlData, msg);
-            break;
-        case DistlistObject:
-            mContactGroup = contactGroupFromKolab(xmlData);
-            break;
-        case NoteObject:
-            mNote = noteFromKolab(xmlData, msg->date()->dateTime());
-            break;
-        default:
-            CRITICAL("no kolab object found ");
-            break;
-    }
-    if (!mIncidence.isNull()) {
-//             kDebug() << "v2 attachments " << attachments.size() << d->mIncidence->attachments().size();
-        mIncidence->clearAttachments();
-        Mime::getAttachments(mIncidence, attachments, msg);
-        if (mIncidence->attachments().size() != attachments.size()) {
-            Error() << "Could not extract all attachments. " << mIncidence->attachments().size() << " out of " << attachments.size();
-        }
-    }
-    if (ErrorHandler::errorOccured()) {
-        printMessageDebugInfo(msg);
-        return InvalidObject;
-    }
-    mObjectType = objectType;
-    return mObjectType;
-}
-
-ObjectType KolabObjectReader::Private::readKolabV3(const KMime::Message::Ptr &msg, Kolab::ObjectType objectType)
-{
-    KMime::Content * const xmlContent = Mime::findContentByType( msg, getMimeType(objectType) );
-    if ( !xmlContent ) {
-        Critical() << "no " << getMimeType(objectType) << " part found";
-        printMessageDebugInfo(msg);
-        return InvalidObject;
-    }
-    const QByteArray &content = xmlContent->decodedContent();
-    const std::string xml = std::string(content.data(), content.size());
-    switch (objectType) {
-        case EventObject: {
-            const Kolab::Event & event = Kolab::readEvent(xml, false);
-            mIncidence = Kolab::Conversion::toKCalCore(event);
-        }
-            break;
-        case TodoObject: {
-            const Kolab::Todo & event = Kolab::readTodo(xml, false);
-            mIncidence = Kolab::Conversion::toKCalCore(event);
-        }
-            break;
-        case JournalObject: {
-            const Kolab::Journal & event = Kolab::readJournal(xml, false);
-            mIncidence = Kolab::Conversion::toKCalCore(event);
-        }
-            break;
-        case ContactObject: {
-            const Kolab::Contact &contact = Kolab::readContact(xml, false);
-            mAddressee = Kolab::Conversion::toKABC(contact); //TODO extract attachments
-        }
-            break;
-        case DistlistObject: {
-            const Kolab::DistList &distlist = Kolab::readDistlist(xml, false);
-            mContactGroup = Kolab::Conversion::toKABC(distlist);
-        }
-            break;
-        case NoteObject: {
-            const Kolab::Note &note = Kolab::readNote(xml, false);
-            mNote = Kolab::Conversion::toNote(note);
-        }
-            break;
-        case DictionaryConfigurationObject: {
-            const Kolab::Configuration &configuration = Kolab::readConfiguration(xml, false);
-            const Kolab::Dictionary &dictionary = configuration.dictionary();
-            mDictionary.clear();
-            foreach (const std::string &entry, dictionary.entries()) {
-                mDictionary.append(Conversion::fromStdString(entry));
-            }
-            mDictionaryLanguage = Conversion::fromStdString(dictionary.language());
-        }
-            break;
-        case FreebusyObject: {
-            const Kolab::Freebusy &fb = Kolab::readFreebusy(xml, false);
-            mFreebusy = fb;
-        }
-            break;
-        case RelationConfigurationObject: {
-            const Kolab::Configuration &configuration = Kolab::readConfiguration(xml, false);
-            const Kolab::Relation &relation = configuration.relation();
-
-            mTag = Akonadi::Tag();
-            mTag.setName(Conversion::fromStdString(relation.name()));
-            mTag.setGid(Conversion::fromStdString(configuration.uid()).toLatin1());
-            mTag.setType(Akonadi::Tag::PLAIN);
-
-            mTagMembers.reserve(relation.members().size());
-            foreach (const std::string &member, relation.members()) {
-                mTagMembers << Conversion::fromStdString(member);
-            }
-
-        }
-            break;
-        default:
-            Critical() << "no kolab object found ";
-            printMessageDebugInfo(msg);
-            break;
-    }
-
-    if (!mIncidence.isNull()) {
-//             kDebug() << "getting attachments";
-        Mime::getAttachmentsById(mIncidence, msg);
-    }
-    ErrorHandler::handleLibkolabxmlErrors();
-    if (ErrorHandler::errorOccured()) {
-        printMessageDebugInfo(msg);
-        return InvalidObject;
-    }
-    mObjectType = objectType;
-    return mObjectType;
-}
-
-ObjectType KolabObjectReader::parseMimeMessage(const KMime::Message::Ptr &msg)
-{
-    ErrorHandler::clearErrors();
-    d->mObjectType = InvalidObject;
-    if (msg->contents().isEmpty()) {
-        Critical() << "message has no contents (we likely failed to parse it correctly)";
-        printMessageDebugInfo(msg);
-        return InvalidObject;
-    }
-    Kolab::ObjectType objectType = InvalidObject;
-    if (d->mOverrideObjectType == InvalidObject) {
-        if (KMime::Headers::Base *xKolabHeader = msg->getHeaderByType(X_KOLAB_TYPE_HEADER)) {
-            objectType = getObjectType(xKolabHeader->asUnicodeString().trimmed());
-        } else {
-            Warning() << "could not find the X-Kolab-Type Header, trying autodetection" ;
-            //This works only for v2 messages atm.
-            objectType = detectType(msg);
-        }
-    } else {
-        objectType = d->mOverrideObjectType;
-    }
-    if (objectType == InvalidObject) {
-        Critical() << "unable to detect object type";
-        printMessageDebugInfo(msg);
-        return InvalidObject;
-    }
-
-    if (!d->mDoOverrideVersion) {
-        KMime::Headers::Base *xKolabVersion = msg->getHeaderByType(X_KOLAB_MIME_VERSION_HEADER);
-        if (!xKolabVersion) {
-            //For backwards compatibility to development versions, can be removed in future versions
-            xKolabVersion = msg->getHeaderByType(X_KOLAB_MIME_VERSION_HEADER_COMPAT);
-        }
-        if (!xKolabVersion || xKolabVersion->asUnicodeString() == KOLAB_VERSION_V2) {
-            d->mVersion = KolabV2;
-        } else {
-            if (xKolabVersion->asUnicodeString() != KOLAB_VERSION_V3) { //TODO version compatibility check?
-                Warning() << "Kolab Version Header available but not on the same version as the implementation: " << xKolabVersion->asUnicodeString();
-            }
-            d->mVersion = KolabV3;
-        }
-    } else {
-        d->mVersion = d->mOverrideVersion;
-    }
-
-    if (d->mVersion == KolabV2) {
-        return d->readKolabV2(msg, objectType);
-    }
-    return d->readKolabV3(msg, objectType);
-}
-
-Version KolabObjectReader::getVersion() const
-{
-    return d->mVersion;
-}
-
-ObjectType KolabObjectReader::getType() const
-{
-    return d->mObjectType;
-}
-
-KCalCore::Event::Ptr KolabObjectReader::getEvent() const
-{
-    return d->mIncidence.dynamicCast<KCalCore::Event>();
-}
-
-KCalCore::Todo::Ptr KolabObjectReader::getTodo() const
-{
-    return d->mIncidence.dynamicCast<KCalCore::Todo>();
-}
-
-KCalCore::Journal::Ptr KolabObjectReader::getJournal() const
-{
-    return d->mIncidence.dynamicCast<KCalCore::Journal>();
-}
-
-KCalCore::Incidence::Ptr KolabObjectReader::getIncidence() const
-{
-    return d->mIncidence;
-}
-
-KABC::Addressee KolabObjectReader::getContact() const
-{
-    return d->mAddressee;
-}
-
-KABC::ContactGroup KolabObjectReader::getDistlist() const
-{
-    return d->mContactGroup;
-}
-
-KMime::Message::Ptr KolabObjectReader::getNote() const
-{
-    return d->mNote;
-}
-
-QStringList KolabObjectReader::getDictionary(QString& lang) const
-{
-    lang = d->mDictionaryLanguage;
-    return d->mDictionary;
-}
-
-Freebusy KolabObjectReader::getFreebusy() const
-{
-    return d->mFreebusy;
-}
-
-Akonadi::Tag KolabObjectReader::getTag() const
-{
-    return d->mTag;
-}
-
-QStringList KolabObjectReader::getTagMembers() const
-{
-    return d->mTagMembers;
-}
-
-
-//Normalize incidences before serializing them
-KCalCore::Incidence::Ptr normalizeIncidence(KCalCore::Incidence::Ptr original)
-{
-    KCalCore::Incidence::Ptr i = KCalCore::Incidence::Ptr(original->clone()); //We copy to avoid destructive writing
-    Q_FOREACH (KCalCore::Attachment::Ptr attachment, i->attachments()) {
-        attachment->setUri(QString::fromLatin1("cid:")+QString::fromLatin1(KMime::uniqueString() + '@' + "kolab.resource.akonadi")); //Serialize the attachment as attachment with uri, referencing the created mime-part
-    }
-    return i;
-}
-/*
-KABC::Addressee normalizeContact(const KABC::Addressee &a)
-{
-    KABC::Addressee addresee = a;
-    Q_FOREACH (KCalCore::Attachment::Ptr attachment, addresee.photo()) {
-        attachment->setUri(QString::fromLatin1("cid:")+QString::fromLatin1(KMime::uniqueString() + '@' + "kolab.resource.akonadi")); //Serialize the attachment as attachment with uri, referencing the created mime-part
-    }
-    return i;
-}*/
-
-QString getProductId(const QString &pId)
-{
-    if (pId.isEmpty()) {
-        return LIBKOLAB_LIB_VERSION_STRING;
-    }
-    return pId+" "+LIBKOLAB_LIB_VERSION_STRING;
-}
-
-KMime::Message::Ptr KolabObjectWriter::writeEvent(const KCalCore::Event::Ptr &i, Version v, const QString &productId, const QString &tz)
-{
-    ErrorHandler::clearErrors();
-    if (!i) {
-        Critical() << "passed a null pointer";
-        return KMime::Message::Ptr();
-    }
-    Q_ASSERT(!i.isNull());
-    if (v == KolabV3) {
-        KCalCore::Event::Ptr ic = normalizeIncidence(i).dynamicCast<KCalCore::Event>();
-        const Kolab::Event &incidence = Kolab::Conversion::fromKCalCore(*ic);
-        const std::string &v3String = Kolab::writeEvent(incidence, std::string(getProductId(productId).toUtf8().constData()));
-        ErrorHandler::handleLibkolabxmlErrors();
-        return Mime::createMessage(ic, xCalMimeType(), eventKolabType(), QString::fromUtf8(v3String.c_str()).toUtf8(), true, getProductId(productId));
-    }
-    const QString &xml = KolabV2::Event::eventToXML(i, tz);
-    return Mime::createMessage(i, eventKolabType(), eventKolabType(), xml.toUtf8(), false, getProductId(productId));
-}
-
-KMime::Message::Ptr KolabObjectWriter::writeTodo(const KCalCore::Todo::Ptr &i, Version v, const QString &productId, const QString &tz)
-{
-    ErrorHandler::clearErrors();
-    if (!i) {
-        Critical() << "passed a null pointer";
-        return KMime::Message::Ptr();
-    }
-    Q_ASSERT(!i.isNull());
-    if (v == KolabV3) {
-        KCalCore::Todo::Ptr ic = normalizeIncidence(i).dynamicCast<KCalCore::Todo>();
-        const Kolab::Todo &incidence = Kolab::Conversion::fromKCalCore(*ic);
-        const std::string &v3String = Kolab::writeTodo(incidence, Conversion::toStdString(getProductId(productId)));
-        ErrorHandler::handleLibkolabxmlErrors();
-        return Mime::createMessage(ic, xCalMimeType(), todoKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
-    }
-    const QString &xml = KolabV2::Task::taskToXML(i, tz);
-    return Mime::createMessage(i, todoKolabType(), todoKolabType(), xml.toUtf8(), false, getProductId(productId));
-}
-
-KMime::Message::Ptr KolabObjectWriter::writeJournal(const KCalCore::Journal::Ptr &i, Version v, const QString &productId, const QString &tz)
-{
-    ErrorHandler::clearErrors();
-    if (!i) {
-        Critical() << "passed a null pointer";
-        return KMime::Message::Ptr();
-    }
-    Q_ASSERT(!i.isNull());
-    if (v == KolabV3) {
-        KCalCore::Journal::Ptr ic = normalizeIncidence(i).dynamicCast<KCalCore::Journal>();
-        const Kolab::Journal &incidence = Kolab::Conversion::fromKCalCore(*ic);
-        const std::string &v3String = Kolab::writeJournal(incidence, Conversion::toStdString(getProductId(productId)));
-        ErrorHandler::handleLibkolabxmlErrors();
-        return  Mime::createMessage(ic, xCalMimeType(), journalKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
-    }
-    const QString &xml = KolabV2::Journal::journalToXML(i, tz);
-    return Mime::createMessage(i, journalKolabType(), journalKolabType(), xml.toUtf8(), false, getProductId(productId));
-}
-
-KMime::Message::Ptr KolabObjectWriter::writeIncidence(const KCalCore::Incidence::Ptr &i, Version v, const QString& productId, const QString& tz)
-{
-    if (!i) {
-        Critical() << "passed a null pointer";
-        return KMime::Message::Ptr();
-    }
-    switch (i->type()) {
-        case KCalCore::IncidenceBase::TypeEvent:
-            return writeEvent(i.dynamicCast<KCalCore::Event>(),v,productId,tz);
-        case KCalCore::IncidenceBase::TypeTodo:
-            return writeTodo(i.dynamicCast<KCalCore::Todo>(),v,productId,tz);
-        case KCalCore::IncidenceBase::TypeJournal:
-            return writeJournal(i.dynamicCast<KCalCore::Journal>(),v,productId,tz);
-        default:
-            Critical() << "unknown incidence type";
-    }
-    return KMime::Message::Ptr();
-}
-
-
-KMime::Message::Ptr KolabObjectWriter::writeContact(const KABC::Addressee &addressee, Version v, const QString &productId)
-{
-    ErrorHandler::clearErrors();
-    if (v == KolabV3) {
-        const Kolab::Contact &contact = Kolab::Conversion::fromKABC(addressee);
-        const std::string &v3String = Kolab::writeContact(contact, Conversion::toStdString(getProductId(productId)));
-        ErrorHandler::handleLibkolabxmlErrors();
-        return  Mime::createMessage(addressee, xCardMimeType(), contactKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
-    }
-    KolabV2::Contact contact(&addressee);
-    return contactToKolabFormat(contact, getProductId(productId));
-}
-
-KMime::Message::Ptr KolabObjectWriter::writeDistlist(const KABC::ContactGroup &distlist, Version v, const QString &productId)
-{
-    ErrorHandler::clearErrors();
-    if (v == KolabV3) {
-        const Kolab::DistList &dist = Kolab::Conversion::fromKABC(distlist);
-        const std::string &v3String = Kolab::writeDistlist(dist, Conversion::toStdString(getProductId(productId)));
-        ErrorHandler::handleLibkolabxmlErrors();
-        return  Mime::createMessage(Conversion::fromStdString(dist.uid()), xCardMimeType(), distlistKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
-    }
-    KolabV2::DistributionList d(&distlist);
-    return distListToKolabFormat(d, getProductId(productId));
-}
-
-KMime::Message::Ptr KolabObjectWriter::writeNote(const KMime::Message::Ptr &note, Version v, const QString &productId)
-{
-    ErrorHandler::clearErrors();
-    if (!note) {
-        Critical() << "passed a null pointer";
-        return KMime::Message::Ptr();
-    }
-    Q_ASSERT(note.get());
-    if (v == KolabV3) {
-        const Kolab::Note &n = Kolab::Conversion::fromNote(note);
-        const std::string &v3String = Kolab::writeNote(n, Conversion::toStdString(getProductId(productId)));
-        ErrorHandler::handleLibkolabxmlErrors();
-        return  Mime::createMessage(Conversion::fromStdString(n.uid()), kolabMimeType(), noteKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
-    }
-    return noteToKolab(note, getProductId(productId));
-}
-
-KMime::Message::Ptr KolabObjectWriter::writeDictionary(const QStringList &entries, const QString& lang, Version v, const QString& productId)
-{
-    ErrorHandler::clearErrors();
-    if (v != KolabV3) {
-        Critical() << "only v3 implementation available";
-    }
-
-    Kolab::Dictionary dictionary(Conversion::toStdString(lang));
-    std::vector <std::string> ent;
-    foreach (const QString &e, entries) {
-        ent.push_back(Conversion::toStdString(e));
-    }
-    dictionary.setEntries(ent);
-    Kolab::Configuration configuration(dictionary); //TODO preserve creation/lastModified date
-    const std::string &v3String = Kolab::writeConfiguration(configuration, Conversion::toStdString(getProductId(productId)));
-    ErrorHandler::handleLibkolabxmlErrors();
-    return  Mime::createMessage(Conversion::fromStdString(configuration.uid()), kolabMimeType(), dictKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
-}
-
-KMime::Message::Ptr KolabObjectWriter::writeFreebusy(const Freebusy &freebusy, Version v, const QString& productId)
-{
-    ErrorHandler::clearErrors();
-    if (v != KolabV3) {
-        Critical() << "only v3 implementation available";
-    }
-    const std::string &v3String = Kolab::writeFreebusy(freebusy, Conversion::toStdString(getProductId(productId)));
-    ErrorHandler::handleLibkolabxmlErrors();
-    return  Mime::createMessage(Conversion::fromStdString(freebusy.uid()), xCalMimeType(), freebusyKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
-}
-
-KMime::Message::Ptr KolabObjectWriter::writeTag(const Akonadi::Tag &tag, const QStringList &members, Version v, const QString &productId)
-{
-    ErrorHandler::clearErrors();
-    if (v != KolabV3) {
-        Critical() << "only v3 implementation available";
-    }
-
-    Kolab::Relation relation(Conversion::toStdString(tag.name()), "tag");
-    std::vector<std::string> m;
-    m.reserve(members.count());
-    foreach (const QString &member, members) {
-        m.push_back(Conversion::toStdString(member));
-    }
-    relation.setMembers(m);
-
-    Kolab::Configuration configuration(relation); //TODO preserve creation/lastModified date
-    configuration.setUid(tag.gid().constData());
-    const std::string &v3String = Kolab::writeConfiguration(configuration, Conversion::toStdString(getProductId(productId)));
-    ErrorHandler::handleLibkolabxmlErrors();
-    return  Mime::createMessage(Conversion::fromStdString(configuration.uid()), kolabMimeType(), relationKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
-}
-
-
-
-
-
-
-}; //Namespace
-
diff --git a/kolabformat/kolabobject.h b/kolabformat/kolabobject.h
deleted file mode 100644
index 71a0e4b..0000000
--- a/kolabformat/kolabobject.h
+++ /dev/null
@@ -1,134 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef KOLABOBJECT_H
-#define KOLABOBJECT_H
-
-#include <kolab_export.h>
-
-#include <akonadi/tag.h>
-#include <kabc/addressee.h>
-#include <kabc/contactgroup.h>
-#include <kcalcore/incidence.h>
-#include <kcalcore/event.h>
-#include <kcalcore/journal.h>
-#include <kcalcore/todo.h>
-#include <kmime/kmime_message.h>
-
-#include "kolabdefinitions.h"
-
-namespace Kolab {
-
-class Freebusy;
-
-
-KOLAB_EXPORT KCalCore::Event::Ptr readV2EventXML(const QByteArray &xmlData, QStringList &attachments);
-
-struct KOLAB_EXPORT RelationMember {
-    QString messageId;
-    QString subject;
-    QString date;
-    QList<QByteArray> mailbox;
-    QString user;
-    qint64 uid;
-};
-KOLAB_EXPORT RelationMember parseMemberUrl(const QString &url);
-KOLAB_EXPORT QString generateMemberUrl(const RelationMember &url);
-
-/**
- * Class to read Kolab Mime files
- * 
- * It implements the Kolab specifics of Mime message handling.
- * This class is not reusable and only meant to read a single object.
- * Parse the mime message and then call the correct getter, based on the type
- * 
- */
-class KOLAB_EXPORT KolabObjectReader {
-public:
-    KolabObjectReader();
-    explicit KolabObjectReader(const KMime::Message::Ptr &msg);
-    ~KolabObjectReader();
-    
-    ObjectType parseMimeMessage(const KMime::Message::Ptr &msg);
-
-    /**
-     * Set to Q_DECL_OVERRIDE the autodetected object type, before parsing the message.
-     */
-    void setObjectType(ObjectType);
-    
-    /**
-     * Set to Q_DECL_OVERRIDE the autodetected version, before parsing the message.
-     */
-    void setVersion(Version);
-    
-    /**
-     * Returns the Object type of the parsed kolab object.
-     */
-    ObjectType getType() const;
-    /**
-     * Returns the kolab-format version of the parsed kolab object.
-     */
-    Version getVersion() const;
-    
-    /**
-     * Getter to get the retrieved object.
-     * Only the correct one will return a valid object.
-     * 
-     * Use getType() to determine the correct one to call.
-     */
-    KCalCore::Event::Ptr getEvent() const;
-    KCalCore::Todo::Ptr getTodo() const;
-    KCalCore::Journal::Ptr getJournal() const;
-    KCalCore::Incidence::Ptr getIncidence() const;
-    KABC::Addressee getContact() const;
-    KABC::ContactGroup getDistlist() const;
-    KMime::Message::Ptr getNote() const;
-    QStringList getDictionary(QString &lang) const;
-    Freebusy getFreebusy() const;
-    Akonadi::Tag getTag() const;
-    QStringList getTagMembers() const;
-
-private:
-    //@cond PRIVATE
-    class Private;
-    Private *const d;
-    //@endcond
-};
-
-/**
- * Class to write Kolab Mime files
- * 
- */
-class KOLAB_EXPORT KolabObjectWriter {
-public:
-
-    static KMime::Message::Ptr writeEvent(const KCalCore::Event::Ptr &, Version v = KolabV3, const QString &productId = QString(), const QString &tz = QString());
-    static KMime::Message::Ptr writeTodo(const KCalCore::Todo::Ptr &, Version v = KolabV3, const QString &productId = QString(),const QString &tz = QString());
-    static KMime::Message::Ptr writeJournal(const KCalCore::Journal::Ptr &, Version v = KolabV3, const QString &productId = QString(),const QString &tz = QString());
-    static KMime::Message::Ptr writeIncidence(const KCalCore::Incidence::Ptr &, Version v = KolabV3, const QString &productId = QString(),const QString &tz = QString());
-    static KMime::Message::Ptr writeContact(const KABC::Addressee &, Version v = KolabV3, const QString &productId = QString());
-    static KMime::Message::Ptr writeDistlist(const KABC::ContactGroup &, Version v = KolabV3, const QString &productId = QString());
-    static KMime::Message::Ptr writeNote(const KMime::Message::Ptr &, Version v = KolabV3, const QString &productId = QString());
-    static KMime::Message::Ptr writeDictionary(const QStringList &, const QString &lang, Version v = KolabV3, const QString &productId = QString());
-    static KMime::Message::Ptr writeFreebusy(const Kolab::Freebusy &, Version v = KolabV3, const QString &productId = QString());
-    static KMime::Message::Ptr writeTag(const Akonadi::Tag &, const QStringList &items, Version v = KolabV3, const QString &productId = QString());
-    
-};
-
-} //Namespace
-
-#endif // KOLABOBJECT_H
diff --git a/kolabformat/kolabobject.i b/kolabformat/kolabobject.i
deleted file mode 100644
index 6de018d..0000000
--- a/kolabformat/kolabobject.i
+++ /dev/null
@@ -1,18 +0,0 @@
-%{
-    /* This macro ensures that return vectors remain a vector also in python and are not converted to tuples */
-    #define SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
-    
-    #include "../kolabformat/xmlobject.h"
-    #include "../kolabformat/kolabdefinitions.h"
-    #include "../kolabformat/mimeobject.h"
-%}
-
-%include "std_string.i"
-%include "std_vector.i"
-
-%import(module="kolabformat") <kolabevent.h>
-%import "../shared.i"
-
-%include "../kolabformat/xmlobject.h"
-%include "../kolabformat/kolabdefinitions.h"
-%include "../kolabformat/mimeobject.h"
diff --git a/kolabformat/mimeobject.cpp b/kolabformat/mimeobject.cpp
deleted file mode 100644
index 559cf75..0000000
--- a/kolabformat/mimeobject.cpp
+++ /dev/null
@@ -1,162 +0,0 @@
-/*
- * Copyright (C) 2012  Sofia Balicka <balicka@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "mimeobject.h"
-#include "conversion/kcalconversion.h"
-#include "conversion/kolabconversion.h"
-#include "conversion/kabcconversion.h"
-#include "kolabformat/kolabobject.h"
-#include <QString>
-
-namespace Kolab
-{
-
-MIMEObject::MIMEObject()
-{
-
-}
-
-std::string MIMEObject::writeEvent(const Event &event, Version version, const std::string &productId)
-{
-
-    KCalCore::Event::Ptr KEvent = Conversion::toKCalCore(event);
-
-    KMime::Message::Ptr msg = KolabObjectWriter().writeEvent(KEvent, version, QString::fromStdString(productId));
-    msg->assemble();
-
-    return msg->encodedContent().data();
-}
-
-Event MIMEObject::readEvent(const std::string &s)
-{
-
-    KMime::Message::Ptr msg(new KMime::Message);
-    msg->setContent(QByteArray(s.c_str()));
-    msg->parse();
-    
-    KCalCore::Event::Ptr event = KolabObjectReader(msg).getEvent();
-    
-    return Conversion::fromKCalCore(*event); 
-}
-
-std::string MIMEObject::writeTodo(const Todo &todo, Version version, const std::string &productId){
-    KCalCore::Todo::Ptr kTodo = Conversion::toKCalCore(todo);
-
-    KMime::Message::Ptr msg = KolabObjectWriter().writeTodo(kTodo, version, QString::fromStdString(productId));
-    msg->assemble();
-
-    return msg->encodedContent().data();
-}
-
-
-Todo MIMEObject::readTodo(const std::string &s){
-
-    KMime::Message::Ptr msg(new KMime::Message);
-    msg->setContent(QByteArray(s.c_str()));
-    msg->parse();
-    
-    KCalCore::Todo::Ptr todo = KolabObjectReader(msg).getTodo();
-    
-    return Conversion::fromKCalCore(*todo);
-}
-
-
-std::string MIMEObject::writeJournal(const Journal &journal, Version version, const std::string &productId){
-    KCalCore::Journal::Ptr kJournal = Conversion::toKCalCore(journal);
-
-    KMime::Message::Ptr msg = KolabObjectWriter().writeJournal(kJournal, version, QString::fromStdString(productId));
-    msg->assemble();
-
-    return msg->encodedContent().data();
-}
-
-
-Journal MIMEObject::readJournal(const std::string &s){
-
-    KMime::Message::Ptr msg(new KMime::Message);
-    msg->setContent(QByteArray(s.c_str()));
-    msg->parse();
-    
-    KCalCore::Journal::Ptr journal = KolabObjectReader(msg).getJournal();
-    
-    return Conversion::fromKCalCore(*journal);
-}
-
-std::string MIMEObject::writeNote(const Note &note, Version version, const std::string &productId){
-    KMime::Message::Ptr kNote = Conversion::toNote(note);
-
-    KMime::Message::Ptr msg = KolabObjectWriter().writeNote(kNote, version, QString::fromStdString(productId));
-    msg->assemble();
-
-    return msg->encodedContent().data();
-}
-
-
-Note MIMEObject::readNote(const std::string &s){
-
-    KMime::Message::Ptr msg(new KMime::Message);
-    msg->setContent(QByteArray(s.c_str()));
-    msg->parse();
-    
-    KMime::Message::Ptr note = KolabObjectReader(msg).getNote();
-    
-    return Conversion::fromNote(note);
-}
-
-std::string MIMEObject::writeContact(const Contact &contact, Version version, const std::string &productId){
-    KABC::Addressee kContact = Conversion::toKABC(contact);
-
-    KMime::Message::Ptr msg = KolabObjectWriter().writeContact(kContact, version, QString::fromStdString(productId));
-    msg->assemble();
-
-    return msg->encodedContent().data();
-}
-
-
-Contact MIMEObject::readContact(const std::string &s){
-
-    KMime::Message::Ptr msg(new KMime::Message);
-    msg->setContent(QByteArray(s.c_str()));
-    msg->parse();
-    
-    KABC::Addressee contact = KolabObjectReader(msg).getContact();
-    
-    return Conversion::fromKABC(contact);
-}
-
-std::string MIMEObject::writeDistlist(const DistList &distlist, Version version, const std::string &productId){
-    KABC::ContactGroup kDistlist = Conversion::toKABC(distlist);
-
-    KMime::Message::Ptr msg = KolabObjectWriter().writeDistlist(kDistlist, version, QString::fromStdString(productId));
-    msg->assemble();
-
-    return msg->encodedContent().data();
-}
-
-
-DistList MIMEObject::readDistlist(const std::string &s){
-
-    KMime::Message::Ptr msg(new KMime::Message);
-    msg->setContent(QByteArray(s.c_str()));
-    msg->parse();
-    
-    KABC::ContactGroup distlist = KolabObjectReader(msg).getDistlist();
-    
-    return Conversion::fromKABC(distlist);
-}
-}
-
diff --git a/kolabformat/mimeobject.h b/kolabformat/mimeobject.h
deleted file mode 100644
index 89ff788..0000000
--- a/kolabformat/mimeobject.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (C) 2012  Sofia Balicka <balicka@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef MIMEOBJECT_H
-#define MIMEOBJECT_H
-
-#ifndef SWIG
-#include "kolab_export.h"
-#else
-/* No export/import SWIG interface files */
-#define KOLAB_EXPORT
-#endif
-
-#include <kolabformat.h>
-#include "kolabdefinitions.h"
-
-
-namespace Kolab
-{
-
-class KOLAB_EXPORT MIMEObject
-{
-public:
-    MIMEObject();
-
-    std::string writeEvent(const Kolab::Event  &event, Version version, const std::string &productId = std::string());
-    Kolab::Event readEvent(const std::string &s);
-
-    std::string writeTodo(const Kolab::Todo &todo, Version version, const std::string &productId = std::string());
-    Kolab::Todo readTodo(const std::string &s);
-
-    std::string writeJournal(const Kolab::Journal &journal, Version version, const std::string &productId = std::string());
-    Kolab::Journal readJournal(const std::string &s);
-
-    std::string writeNote(const Kolab::Note &note, Version version, const std::string &productId = std::string());
-    Kolab::Note readNote(const std::string &s);
-
-    std::string writeContact(const Kolab::Contact &contact, Version version, const std::string &productId = std::string());
-    Kolab::Contact readContact(const std::string &s);
-
-    std::string writeDistlist(const Kolab::DistList &distlist, Version version, const std::string &productId = std::string());
-    Kolab::DistList readDistlist(const std::string &s);
-
-};
-}
-#endif  
diff --git a/kolabformat/php/CMakeLists.txt b/kolabformat/php/CMakeLists.txt
deleted file mode 100644
index 2d18e19..0000000
--- a/kolabformat/php/CMakeLists.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-#Generate PHP wrapper
-include_directories(../)
-include(SWIGUtils)
-generatePHPBindings(kolabobject ../kolabobject.i)
diff --git a/kolabformat/php/test.php b/kolabformat/php/test.php
deleted file mode 100644
index ec3d8e4..0000000
--- a/kolabformat/php/test.php
+++ /dev/null
@@ -1,88 +0,0 @@
-<?php
-//run using:
-// php -d enable_dl=On -dextension=/usr/local/lib/php/modules/kolabshared.so -dextension=/usr/local/lib/php/modules/kolabformat.so -dextension=/usr/local/lib/php/modules/kolabobject.so test.php
-
-include("kolabformat.php");
-include("kolabobject.php");
-
-/////// Test Event
-$e = new Event();
-$e->setCreated(new cDateTime(2012,3,14, 9,5,30, true));
-$e->setStart(new cDateTime(2012,7,31));
-$e->setUid("uid");
-$e->setPriority(1);
-
-$xo = new XMLObject;
-print $xo->writeEvent($e, kolabobject::KolabV2, "test.php");
-print $xo->writeEvent($e, kolabobject::KolabV3, "test.php");
-
-////// Test Contact
-$c = new Contact();
-$nc = new NameComponents;
-$sn = new vectors;
-$sn->push("Contact");
-$nc->setSurnames($sn);
-$gn = new vectors;
-$gn->push("Sample");
-$nc->setGiven($gn);
-$c->setNameComponents($nc);
-$c->setName("Sample Contact");
-$em = new vectors;
-$em->push("sample.v2@localhost");
-$c->setEmailAddresses($em);
-
-$xo = new XMLObject;
-print $xo->writeContact($c, kolabobject::KolabV2, "test.php");
-print "UID = " . $xo->getSerializedUID() . "\n\n";
-
-print $xo->writeContact($c, kolabobject::KolabV3, "test.php");
-print "UID = " . $xo->getSerializedUID() . "\n\n";
-
-
-$dlxml = <<<EOL
-<?xml version="1.0"?>
-<distribution-list version="1.0">
-  <uid>ebb1774429a2e03afafb31f233e23b42</uid>
-  <body></body>
-  <categories></categories>
-  <creation-date>2010-11-25T18:02:32Z</creation-date>
-  <last-modification-date>2011-07-23T09:06:38Z</last-modification-date>
-  <sensitivity>public</sensitivity>
-  <product-id>Horde::Kolab</product-id>
-  <display-name>Another lista</display-name>
-  <member>
-    <display-name>Another  User</display-name>
-    <smtp-address>other@debian-vm.local</smtp-address>
-    <uid>a2cfdc52365ef429042413bf7717dc85</uid>
-  </member>
-  <member>
-    <display-name>Sample A. User Jr.</display-name>
-    <smtp-address>sample@debian-vm.local</smtp-address>
-    <uid>f538c7e9ad5a63e4452b7db3bc291231</uid>
-  </member>
-</distribution-list>
-EOL;
-
-$xo = new XMLObject;
-$dl = new DistList($xo->readDistList($dlxml, kolabobject::KolabV2));
-
-echo $dl->uid() . "\n\n";
-$ml = $dl->members();
-for ($i=0; $i < $ml->size(); $i++) {
-    $m = $ml->get($i);
-    echo "Member [" . $m->type() . "]: " . $m->uid() . "; " . $m->email() . "\n";
-}
-
-
-$dl2 = new DistList();
-$ml = new vectorcontactref;
-$m1 = new ContactReference(ContactReference::UidReference, 'some-uid-value');
-$ml->push($m1);
-$m2 = new ContactReference(ContactReference::EmailReference, 'sample@localhost');
-$ml->push($m2);
-
-$dl2->setMembers($ml);
-echo $xo->writeDistList($dl2, kolabobject::KolabV2);
-echo $xo->writeDistList($dl2, kolabobject::KolabV3);
-
-?>
diff --git a/kolabformat/python/CMakeLists.txt b/kolabformat/python/CMakeLists.txt
deleted file mode 100644
index 5ff8bfe..0000000
--- a/kolabformat/python/CMakeLists.txt
+++ /dev/null
@@ -1,4 +0,0 @@
-include_directories(../)
-include(SWIGUtils)
-generatePythonBindings(kolabobject ../kolabobject.i)
-
diff --git a/kolabformat/v2helpers.cpp b/kolabformat/v2helpers.cpp
deleted file mode 100644
index 03b4b19..0000000
--- a/kolabformat/v2helpers.cpp
+++ /dev/null
@@ -1,279 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "v2helpers.h"
-
-#include "kolabdefinitions.h"
-
-#include "kolabformatV2/kolabbase.h"
-#include "kolabformatV2/journal.h"
-#include "kolabformatV2/task.h"
-#include "kolabformatV2/event.h"
-#include "kolabformatV2/contact.h"
-#include "kolabformatV2/distributionlist.h"
-#include "kolabformatV2/note.h"
-#include "mime/mimeutils.h"
-#include "kolabformat/errorhandler.h"
-
-#include <kabc/contactgroup.h>
-
-#include <qdom.h>
-#include <kdebug.h>
-#include <qbuffer.h>
-#include <akonadi/notes/noteutils.h>
-
-namespace Kolab {
-
-static QImage getPicture(const QString &pictureAttachmentName, const KMime::Message::Ptr &data, QByteArray &type)
-{
-    if (!data) {
-        Critical() << "empty message";
-        return QImage();
-    }
-    KMime::Content *imgContent = Mime::findContentByName(data, pictureAttachmentName/*"kolab-picture.png"*/, type);
-    if (!imgContent) {
-        Warning() << "could not find picture: " << pictureAttachmentName;
-        return QImage();
-    }
-    QByteArray imgData = imgContent->decodedContent();
-    QBuffer buffer(&imgData);
-    buffer.open(QIODevice::ReadOnly);
-    QImage image;
-    bool success = false;
-    if (type == "image/jpeg") {
-        success = image.load(&buffer, "JPEG");
-        //FIXME I tried getting the code to interpret the picture as PNG, but the VCard implementation writes it as JPEG anyways...
-//         if (success) {
-//             QByteArray pic;
-//             QBuffer b(&pic);
-//             b.open(QIODevice::ReadWrite);
-//             Q_ASSERT(image.save(&b, "PNG"));
-//             b.close();
-//             Debug() << pic.toBase64();
-//             QBuffer b2(&pic);
-//             b2.open(QIODevice::ReadOnly);
-//             success = image.load(&b2, "PNG");
-//             b2.close();
-//             Q_ASSERT(success);
-//         }
-    } else {
-        type = "image/png";
-        success = image.load(&buffer, "PNG");
-    }
-    buffer.close();
-    if (!success) {
-        Warning() << "failed to load picture";
-    }
-    return image;
-}
-
-KABC::Addressee addresseeFromKolab( const QByteArray &xmlData, const KMime::Message::Ptr &data)
-{
-    if (!data) {
-        Critical() << "empty message";
-        return KABC::Addressee();
-    }
-    KABC::Addressee addressee;
-//     Debug() << "xmlData " << xmlData;
-    KolabV2::Contact contact(QString::fromUtf8(xmlData));
-    QByteArray type;
-    const QString &pictureAttachmentName = contact.pictureAttachmentName();
-    if (!pictureAttachmentName.isEmpty()) {
-        const QImage &img = getPicture(pictureAttachmentName, data, type);
-        contact.setPicture(img, type);
-    }
-    
-    const QString &logoAttachmentName = contact.logoAttachmentName();
-    if (!logoAttachmentName.isEmpty()) {
-        contact.setLogo(getPicture(logoAttachmentName, data, type), type);
-    }
-    
-    const QString &soundAttachmentName = contact.soundAttachmentName();
-    if (!soundAttachmentName.isEmpty()) {
-        QByteArray type;
-        KMime::Content *content = Mime::findContentByName(data, soundAttachmentName/*"sound"*/, type);
-        if (content) {
-            const QByteArray &sData = content->decodedContent();
-            contact.setSound(sData);
-        } else {
-            Warning() << "could not find sound: " << soundAttachmentName;
-        }
-    }
-    contact.saveTo(&addressee);
-    return addressee;
-}
-
-KABC::Addressee addresseeFromKolab(const QByteArray &xmlData, QString &pictureAttachmentName, QString &logoAttachmentName, QString &soundAttachmentName)
-{
-    KABC::Addressee addressee;
-    KolabV2::Contact contact(QString::fromUtf8(xmlData));
-    pictureAttachmentName = contact.pictureAttachmentName();
-    logoAttachmentName = contact.logoAttachmentName();
-    soundAttachmentName = contact.soundAttachmentName();
-    contact.saveTo(&addressee);
-    return addressee;
-}
-
-static QByteArray createPicture(const QImage &img, const QString &/*format*/, QString &type)
-{
-    QByteArray pic;
-    QBuffer buffer(&pic);
-    buffer.open(QIODevice::WriteOnly);
-    type = "image/png";
-    //FIXME it's not possible to save jpegs lossless, so we always use png. otherwise we would compress the image on every write.
-//     if (format == "image/jpeg") {
-//         type = "image/jpeg";
-//         img.save(&buffer, "JPEG");
-//     } else {
-        img.save(&buffer, "PNG");
-//     }
-    buffer.close();
-    return pic;
-}
-
-KMime::Message::Ptr contactToKolabFormat(const KolabV2::Contact& contact, const QString &productId)
-{
-    KMime::Message::Ptr message = Mime::createMessage( KOLAB_TYPE_CONTACT, false, productId );
-    if (!message) {
-        Critical() << "empty message";
-        return KMime::Message::Ptr();
-    }
-    message->subject()->fromUnicodeString( contact.uid(), "utf-8" );
-    message->from()->fromUnicodeString( contact.fullEmail(), "utf-8" );
-    
-    KMime::Content* content = Mime::createMainPart( KOLAB_TYPE_CONTACT, contact.saveXML().toUtf8() );
-    message->addContent( content );
-    
-    if ( !contact.picture().isNull() ) {
-        QString type;
-        const QByteArray &pic = createPicture(contact.picture(), contact.pictureFormat(), type);
-        content = Mime::createAttachmentPart(QByteArray(), type, /*"kolab-picture.png"*/contact.pictureAttachmentName(), pic );
-        message->addContent(content);
-    }
-    
-    if ( !contact.logo().isNull() ) {
-        QString type;
-        const QByteArray &pic = createPicture(contact.logo(), contact.logoFormat(), type);
-        content = Mime::createAttachmentPart(QByteArray(), type, /*"kolab-logo.png"*/contact.logoAttachmentName(), pic );
-        message->addContent(content);
-    }
-    
-    if ( !contact.sound().isEmpty() ) {
-        content = Mime::createAttachmentPart(QByteArray(), "audio/unknown", /*"sound"*/contact.soundAttachmentName(), contact.sound() );
-        message->addContent(content);
-    }
-    
-    message->assemble();
-    return message;
-}
-
-KABC::ContactGroup contactGroupFromKolab(const QByteArray &xmlData)
-{
-    KABC::ContactGroup contactGroup;
-    //     kDebug() << "xmlData " << xmlData;
-    KolabV2::DistributionList distList(QString::fromUtf8(xmlData));
-    distList.saveTo(&contactGroup);
-    return contactGroup;
-}
-
-KMime::Message::Ptr distListToKolabFormat(const KolabV2::DistributionList& distList, const QString &productId)
-{    
-    KMime::Message::Ptr message = Mime::createMessage( KOLAB_TYPE_DISTLIST_V2, false, productId );
-    if (!message) {
-        Critical() << "empty message";
-        return KMime::Message::Ptr();
-    }
-    message->subject()->fromUnicodeString( distList.uid(), "utf-8" );
-    message->from()->fromUnicodeString( distList.uid(), "utf-8" );
-    
-    KMime::Content* content = Mime::createMainPart( KOLAB_TYPE_DISTLIST_V2, distList.saveXML().toUtf8() );
-    message->addContent( content );
-    
-    message->assemble();
-    return message;
-}
-
-KMime::Message::Ptr noteFromKolab(const QByteArray &xmlData, const KDateTime &creationDate)
-{
-    KolabV2::Note j;
-    if ( !j.load( xmlData ) ) {
-        Warning() << "failed to read note";
-        return KMime::Message::Ptr();
-    }
-    
-    Akonadi::NoteUtils::NoteMessageWrapper note;
-    note.setTitle(j.summary());
-    note.setText(j.body().toUtf8());
-    note.setFrom("kolab@kde4");
-    note.setCreationDate(creationDate);
-    return note.message();
-}
-
-KMime::Message::Ptr noteToKolab(const KMime::Message::Ptr& msg, const QString &productId)
-{
-    if (!msg) {
-        Critical() << "empty message";
-        return KMime::Message::Ptr();
-    }
-    Akonadi::NoteUtils::NoteMessageWrapper note(msg);
-    return Mime::createMessage(note.title(), KOLAB_TYPE_NOTE, KOLAB_TYPE_NOTE, noteToKolabXML(msg), false, productId);
-}
-
-QByteArray noteToKolabXML(const KMime::Message::Ptr& msg)
-{
-    if (!msg) {
-        Critical() << "empty message";
-        return QByteArray();
-    }
-    Akonadi::NoteUtils::NoteMessageWrapper note(msg);
-    KolabV2::Note j;
-    j.setSummary( note.title() );
-    j.setBody( note.text() );
-    return j.saveXML().toUtf8();
-}
-
-QStringList readLegacyDictionaryConfiguration(const QByteArray &xmlData, QString &language)
-{
-    QStringList dictionary;
-    const QDomDocument xmlDoc = KolabV2::KolabBase::loadDocument( QString::fromUtf8(xmlData) ); //TODO extract function from V2 format
-    if ( xmlDoc.isNull() ) {
-        Error() << "Failed to read the xml document";
-        return QStringList();
-    }
-
-    QDomElement top = xmlDoc.documentElement();
-
-    if ( top.tagName() != "configuration" ) {
-        qWarning( "XML error: Top tag was %s instead of the expected configuration",
-                top.tagName().toAscii().data() );
-        return QStringList();
-    }
-
-    for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-        if ( n.isComment() || !n.isElement() )
-            continue;
-        QDomElement e = n.toElement();
-        if (e.tagName() == "language") {
-            language = e.text();
-        } else if (e.tagName() == "e") {
-            dictionary.append(e.text());
-        }
-    }
-    return dictionary;
-}
-
-}
diff --git a/kolabformat/v2helpers.h b/kolabformat/v2helpers.h
deleted file mode 100644
index e047d35..0000000
--- a/kolabformat/v2helpers.h
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef V2HELPERS_H
-#define V2HELPERS_H
-
-#include "kolabdefinitions.h"
-
-#include "kolabformatV2/kolabbase.h"
-#include "kolabformatV2/journal.h"
-#include "kolabformatV2/task.h"
-#include "kolabformatV2/event.h"
-#include "kolabformatV2/contact.h"
-#include "kolabformatV2/distributionlist.h"
-#include "kolabformatV2/note.h"
-#include "mime/mimeutils.h"
-#include "kolabformat/errorhandler.h"
-
-#include <kabc/contactgroup.h>
-
-#include <qdom.h>
-#include <qbuffer.h>
-#include <akonadi/notes/noteutils.h>
-
-namespace Kolab {
-
-
-/*
- * Parse XML, create KCalCore container and extract attachments
- */
-template <typename KCalPtr, typename Container>
-static KCalPtr fromXML(const QByteArray &xmlData, QStringList &attachments)
-{
-    const QDomDocument xmlDoc = KolabV2::KolabBase::loadDocument( QString::fromUtf8(xmlData) ); //TODO extract function from V2 format
-    if ( xmlDoc.isNull() ) {
-        Critical() << "Failed to read the xml document";
-        return KCalPtr();
-    }
-    const KCalPtr i = Container::fromXml( xmlDoc, QString() ); //For parsing we don't need the timezone, so we don't set one
-    Q_ASSERT ( i );
-    QDomNodeList nodes = xmlDoc.elementsByTagName("inline-attachment");
-    for (int i = 0; i < nodes.size(); i++ ) {
-        attachments.append(nodes.at(i).toElement().text());
-    }
-    return i;
-}
-
-template <typename IncidencePtr, typename Converter>
-static inline IncidencePtr incidenceFromKolabImpl( const KMime::Message::Ptr &data, const QByteArray &mimetype, const QString &timezoneId )
-{
-    KMime::Content *xmlContent = Mime::findContentByType( data, mimetype );
-    if ( !xmlContent ) {
-        Critical() << "couldn't find part";
-        return IncidencePtr();
-    }
-    const QByteArray &xmlData = xmlContent->decodedContent();
-    
-    QStringList attachments;
-    IncidencePtr ptr = fromXML<IncidencePtr, Converter>(xmlData, attachments); //TODO do we care about timezone?
-    Mime::getAttachments(ptr, attachments, data);
-    
-    return ptr;
-}
-
-KABC::Addressee addresseeFromKolab( const QByteArray &xmlData, const KMime::Message::Ptr &data);
-KABC::Addressee addresseeFromKolab( const QByteArray &xmlData, QString &pictureAttachmentName, QString &logoAttachmentName, QString &soundAttachmentName);
-
-KMime::Message::Ptr contactToKolabFormat(const KolabV2::Contact& contact, const QString &productId);
-
-KABC::ContactGroup contactGroupFromKolab(const QByteArray &xmlData);
-
-KMime::Message::Ptr distListToKolabFormat(const KolabV2::DistributionList& distList, const QString &productId);
-KMime::Message::Ptr noteFromKolab(const QByteArray &xmlData, const KDateTime &creationDate);
-
-KMime::Message::Ptr noteToKolab(const KMime::Message::Ptr& msg, const QString &productId);
-QByteArray noteToKolabXML(const KMime::Message::Ptr& msg);
-
-QStringList readLegacyDictionaryConfiguration(const QByteArray &xmlData, QString &language);
-
-}
-
-#endif
diff --git a/kolabformat/xmlobject.cpp b/kolabformat/xmlobject.cpp
deleted file mode 100644
index e9e2f7a..0000000
--- a/kolabformat/xmlobject.cpp
+++ /dev/null
@@ -1,352 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "xmlobject.h"
-#include "v2helpers.h"
-#include "kolabformatV2/event.h"
-#include "conversion/kcalconversion.h"
-#include "conversion/kolabconversion.h"
-#include "conversion/commonconversion.h"
-#include "conversion/kabcconversion.h"
-#include <QUuid>
-
-namespace Kolab {
-
-static QString createUuid()
-{
-    const QString uuid = QUuid::createUuid().toString();
-    return uuid.mid(1, uuid.size()-2);
-}
-
-XMLObject::XMLObject()
-{
-
-}
-
-std::string XMLObject::getSerializedUID() const
-{
-    return mWrittenUID;
-}
-    
-std::vector< std::string > XMLObject::getAttachments() const
-{
-    return mAttachments;
-}
-
-std::string XMLObject::writeEvent(const Event &event, Version version, const std::string& productId)
-{
-    mWrittenUID.clear();
-    if (version == KolabV2) {
-        const KCalCore::Event::Ptr i = Conversion::toKCalCore(event);
-        if (!i) {
-            Critical() << "invalid incidence";
-            return std::string();
-        }
-        if (i->uid().isEmpty()) {
-            i->setUid(createUuid());
-        }
-        mWrittenUID = Conversion::toStdString(i->uid());
-        //The timezone is used for created and last modified dates
-        const QString &xml = KolabV2::Event::eventToXML(i, QLatin1String("UTC"));
-        return Conversion::toStdString(xml);
-    }
-    const std::string result = Kolab::writeEvent(event, productId);
-    mWrittenUID = Kolab::getSerializedUID();
-    return result;
-}
-
-Event XMLObject::readEvent(const std::string& s, Version version)
-{
-    if (version == KolabV2) {
-        QStringList attachments;
-        const KCalCore::Event::Ptr event = Kolab::fromXML<KCalCore::Event::Ptr, KolabV2::Event>(QString::fromUtf8(s.c_str()).toUtf8(), attachments);
-        if (!event || Kolab::ErrorHandler::errorOccured()) {
-            Critical() << "failed to read xml";
-            return Event();
-        }
-        mAttachments.clear();
-        foreach (const QString &attachment, attachments) {
-            mAttachments.push_back(Conversion::toStdString(attachment));
-        }
-        return Conversion::fromKCalCore(*event);
-    }
-    return Kolab::readEvent(s, false);
-}
-
-std::string XMLObject::writeTodo(const Todo &event, Version version, const std::string& productId)
-{
-    mWrittenUID.clear();
-    if (version == KolabV2) {
-        const KCalCore::Todo::Ptr i = Conversion::toKCalCore(event);
-        if (!i) {
-            Critical() << "invalid incidence";
-            return std::string();
-        }
-        if (i->uid().isEmpty()) {
-            i->setUid(createUuid());
-        }
-        mWrittenUID = Conversion::toStdString(i->uid());
-        //The timezone is used for created and last modified dates
-        const QString &xml = KolabV2::Task::taskToXML(i, QLatin1String("UTC"));
-        return Conversion::toStdString(xml);
-    }
-    const std::string result = Kolab::writeTodo(event, productId);
-    mWrittenUID = Kolab::getSerializedUID();
-    return result;
-}
-
-Todo XMLObject::readTodo(const std::string& s, Version version)
-{
-    if (version == KolabV2) {
-        QStringList attachments;
-        const KCalCore::Todo::Ptr event = Kolab::fromXML<KCalCore::Todo::Ptr, KolabV2::Task>(QString::fromUtf8(s.c_str()).toUtf8(), attachments);
-        if (!event || Kolab::ErrorHandler::errorOccured()) {
-            Error() << "failed to read xml";
-            return Todo();
-        }
-        mAttachments.clear();
-        foreach (const QString &attachment, attachments) {
-            mAttachments.push_back(Conversion::toStdString(attachment));
-        }
-        return Conversion::fromKCalCore(*event);
-    }
-    return Kolab::readTodo(s, false);
-}
-
-std::string XMLObject::writeJournal(const Journal &event, Version version, const std::string& productId)
-{
-    mWrittenUID.clear();
-    if (version == KolabV2) {
-        const KCalCore::Journal::Ptr i = Conversion::toKCalCore(event);
-        if (!i) {
-            Critical() << "invalid journal";
-            return std::string();
-        }
-        if (i->uid().isEmpty()) {
-            i->setUid(createUuid());
-        }
-        mWrittenUID = Conversion::toStdString(i->uid());
-        //The timezone is used for created and last modified dates
-        const QString &xml = KolabV2::Journal::journalToXML(i, QLatin1String("UTC"));
-        return Conversion::toStdString(xml);
-    }
-    const std::string result = Kolab::writeJournal(event, productId);
-    mWrittenUID = Kolab::getSerializedUID();
-    return result;
-}
-
-Journal XMLObject::readJournal(const std::string& s, Version version)
-{
-    if (version == KolabV2) {
-        QStringList attachments;
-        const KCalCore::Journal::Ptr event = Kolab::fromXML<KCalCore::Journal::Ptr, KolabV2::Journal>(QString::fromUtf8(s.c_str()).toUtf8(), attachments);
-        if (!event || Kolab::ErrorHandler::errorOccured()) {
-            Critical() << "failed to read xml";
-            return Journal();
-        }
-        mAttachments.clear();
-        foreach (const QString &attachment, attachments) {
-            mAttachments.push_back(Conversion::toStdString(attachment));
-        }
-        return Conversion::fromKCalCore(*event);
-    }
-    return Kolab::readJournal(s, false);
-}
-
-std::string XMLObject::writeFreebusy(const Freebusy &event, Version version, const std::string& productId)
-{
-    mWrittenUID.clear();
-    if (version != KolabV3) {
-        Critical() << "only v3 implementation available";
-        return std::string();
-    }
-    const std::string result = Kolab::writeFreebusy(event, productId);
-    mWrittenUID = Kolab::getSerializedUID();
-    return result;
-}
-
-Freebusy XMLObject::readFreebusy(const std::string& s, Version version)
-{
-    if (version != KolabV3) {
-        Critical() << "only v3 implementation available";
-        return Freebusy();
-    }
-    return Kolab::readFreebusy(s, false);
-}
-
-std::string XMLObject::logoAttachmentName() const
-{
-    return mLogoAttachmentName;
-}
-
-std::string XMLObject::pictureAttachmentName() const
-{
-    return mPictureAttachmentName;
-}
-
-std::string XMLObject::soundAttachmentName() const
-{
-    return mSoundAttachmentName;
-}
-
-Contact XMLObject::readContact(const std::string& s, Version version)
-{
-    if (version == KolabV2) {        
-        const QByteArray xmlData(s.c_str(), s.size());
-        QString pictureAttachmentName;
-        QString logoAttachmentName;
-        QString soundAttachmentName;
-        const KABC::Addressee addressee = addresseeFromKolab(xmlData, pictureAttachmentName, logoAttachmentName, soundAttachmentName);
-        mPictureAttachmentName = Conversion::toStdString(pictureAttachmentName);
-        mLogoAttachmentName = Conversion::toStdString(logoAttachmentName);
-        mSoundAttachmentName = Conversion::toStdString(soundAttachmentName);
-        return Conversion::fromKABC(addressee);
-    }
-    return Kolab::readContact(s, false);
-}
-
-std::string XMLObject::writeContact(const Contact &contact, Version version, const std::string& productId)
-{
-    mWrittenUID.clear();
-    if (version == KolabV2) {
-        //FIXME attachment names are hardcoded for now
-        KABC::Addressee addressee = Conversion::toKABC(contact);
-        if (addressee.uid().isEmpty()) {
-            addressee.setUid(createUuid());
-        }
-        mWrittenUID = Conversion::toStdString(addressee.uid());
-        const KolabV2::Contact contact(&addressee);
-        return Conversion::toStdString(contact.saveXML());
-    }
-    const std::string result = Kolab::writeContact(contact, productId);
-    mWrittenUID = Kolab::getSerializedUID();
-    return result;
-}
-
-DistList XMLObject::readDistlist(const std::string& s, Version version)
-{
-    if (version == KolabV2) {        
-        const QByteArray xmlData(s.c_str(), s.size());
-        const KABC::ContactGroup contactGroup = contactGroupFromKolab(xmlData);
-        return Conversion::fromKABC(contactGroup);
-    }
-    return Kolab::readDistlist(s, false);
-}
-
-std::string XMLObject::writeDistlist(const DistList &distlist, Version version, const std::string& productId)
-{
-    mWrittenUID.clear();
-    if (version == KolabV2) {
-        KABC::ContactGroup contactGroup = Conversion::toKABC(distlist);
-        if (contactGroup.id().isEmpty()) {
-            contactGroup.setId(createUuid());
-        }
-        mWrittenUID = Conversion::toStdString(contactGroup.id());
-        const KolabV2::DistributionList d(&contactGroup);
-        return Conversion::toStdString(d.saveXML());
-    }
-    const std::string result = Kolab::writeDistlist(distlist, productId);
-    mWrittenUID = Kolab::getSerializedUID();
-    return result;
-}
-
-Note XMLObject::readNote(const std::string& s, Version version)
-{
-    if (version == KolabV2) {
-        const KMime::Message::Ptr msg = noteFromKolab(QByteArray(s.c_str(), s.length()), KDateTime());
-        if (!msg || Kolab::ErrorHandler::errorOccured()) {
-            Critical() << "failed to read xml";
-            return Note();
-        }
-        return Conversion::fromNote(msg);
-    }
-    return Kolab::readNote(s, false);
-}
-
-std::string XMLObject::writeNote(const Note &note, Version version, const std::string& productId)
-{
-    mWrittenUID.clear();
-    if (version == KolabV2) {
-        Note noteWithUID = note;
-        if (noteWithUID.uid().empty()) {
-            noteWithUID.setUid(Conversion::toStdString(createUuid()));
-        }
-        mWrittenUID = noteWithUID.uid();
-        const KMime::Message::Ptr n = Conversion::toNote(noteWithUID);
-        const QByteArray &xml = noteToKolabXML(n);
-        return std::string(xml.constData());
-    }
-    const std::string result = Kolab::writeNote(note, productId);
-    mWrittenUID = Kolab::getSerializedUID();
-    return result;
-}
-
-Configuration XMLObject::readConfiguration(const std::string& s, Version version)
-{
-    if (version == KolabV2) {
-        QString lang;
-        const QStringList dict = readLegacyDictionaryConfiguration(QByteArray(s.c_str(), s.length()), lang);
-        if (lang.isEmpty()) {
-            Critical() << "not a dictionary or not a v2 configuration object";
-            return Kolab::Configuration();
-        }
-        std::vector<std::string> entries;
-        foreach (const QString e, dict) {
-            entries.push_back(Conversion::toStdString(e));
-        }
-        Kolab::Dictionary dictionary(Conversion::toStdString(lang));
-        dictionary.setEntries(entries);
-        return Configuration(dictionary);
-    }
-    return Kolab::readConfiguration(s, false);
-}
-
-std::string XMLObject::writeConfiguration(const Configuration &configuration, Version version, const std::string& productId)
-{
-    mWrittenUID.clear();
-    if (version != KolabV3) {
-        Critical() << "only v3 implementation available";
-        return std::string();
-    }
-    const std::string result = Kolab::writeConfiguration(configuration, productId);
-    mWrittenUID = Kolab::getSerializedUID();
-    return result;
-}
-
-File XMLObject::readFile(const std::string& s, Version version)
-{
-    if (version == KolabV2) {
-        Critical() << "only v3 implementation available";
-        return File();
-    }
-    return Kolab::readFile(s, false);
-}
-
-std::string XMLObject::writeFile(const File &file, Version version, const std::string& productId)
-{
-    mWrittenUID.clear();
-    if (version != KolabV3) {
-        Critical() << "only v3 implementation available";
-        return std::string();
-    }
-    const std::string result = Kolab::writeFile(file, productId);
-    mWrittenUID = Kolab::getSerializedUID();
-    return result;
-}
-
-    
-};
diff --git a/kolabformat/xmlobject.h b/kolabformat/xmlobject.h
deleted file mode 100644
index 5066e8f..0000000
--- a/kolabformat/xmlobject.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Affero General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Affero General Public License for more details.
- *
- * You should have received a copy of the GNU Affero General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef KOLABXMLOBJECT_H
-#define KOLABXMLOBJECT_H
-
-#ifndef SWIG
-#include "kolab_export.h"
-#else
-/* No export/import SWIG interface files */
-#define KOLAB_EXPORT
-#endif
-
-#include <kolabformat.h>
-
-#include "kolabdefinitions.h"
-
-namespace Kolab {
-
-class KOLAB_EXPORT XMLObject
-{
-public:
-    XMLObject();
-
-    std::string getSerializedUID() const;
-    
-    ///List of attachment names to be retrieved from the mime message (only when reading v2, for v3 attachments containing the cid: of the attachment-part are created )
-    std::vector<std::string> getAttachments() const;
-    
-    Kolab::Event readEvent(const std::string& s, Kolab::Version version);
-    std::string writeEvent(const Kolab::Event &, Kolab::Version version, const std::string& productId = std::string());
-    
-    Kolab::Todo readTodo(const std::string& s, Kolab::Version version);
-    std::string writeTodo(const Kolab::Todo &, Kolab::Version version, const std::string& productId = std::string());
-
-    Kolab::Journal readJournal(const std::string& s, Kolab::Version version);
-    std::string writeJournal(const Kolab::Journal &, Kolab::Version version, const std::string& productId = std::string());
-
-    Kolab::Freebusy readFreebusy(const std::string& s, Kolab::Version version);
-    std::string writeFreebusy(const Kolab::Freebusy &, Kolab::Version version, const std::string& productId = std::string());
-
-    std::string pictureAttachmentName() const;
-    std::string logoAttachmentName() const;
-    std::string soundAttachmentName() const;
-    /**
-     * Find the attachments and set them on the read Contact object.
-     *
-     * V2 Notes:
-     * Picture, logo and sound must be retrieved from Mime Message attachments using they're corresponding attachment name.
-     */
-    Kolab::Contact readContact(const std::string& s, Kolab::Version version);
-    
-    /**
-     * V2 Notes:
-     * * Uses the following attachment names:
-     * ** kolab-picture.png
-     * ** kolab-logo.png
-     * ** sound
-     */
-    std::string writeContact(const Kolab::Contact &, Kolab::Version version, const std::string& productId = std::string());
-    
-    Kolab::DistList readDistlist(const std::string& s, Kolab::Version version);
-    std::string writeDistlist(const Kolab::DistList &, Kolab::Version version, const std::string& productId = std::string());
-
-    /**
-     * V2 notes:
-     * * set the creation date from the mime date header.
-     */
-    Kolab::Note readNote(const std::string& s, Kolab::Version version);
-    std::string writeNote(const Kolab::Note &, Kolab::Version version, const std::string& productId = std::string());
-
-    Kolab::Configuration readConfiguration(const std::string& s, Kolab::Version version);
-    std::string writeConfiguration(const Kolab::Configuration &, Kolab::Version version, const std::string& productId = std::string());
-
-    Kolab::File readFile(const std::string& s, Kolab::Version version);
-    std::string writeFile(const Kolab::File &, Kolab::Version version, const std::string& productId = std::string());
-    
-private:
-    std::vector<std::string> mAttachments;
-    std::string mLogoAttachmentName;
-    std::string mSoundAttachmentName;
-    std::string mPictureAttachmentName;
-    std::string mWrittenUID;
-};
-
-}
-#endif // KOLABXMLOBJECT_H
diff --git a/kolabformatV2/CMakeLists.txt b/kolabformatV2/CMakeLists.txt
deleted file mode 100644
index 7c3071f..0000000
--- a/kolabformatV2/CMakeLists.txt
+++ /dev/null
@@ -1,12 +0,0 @@
-
-set( kolabformatv2_SRCS
-    ${CMAKE_CURRENT_SOURCE_DIR}/kolabbase.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/contact.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/distributionlist.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/event.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/task.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/journal.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/incidence.cpp
-    ${CMAKE_CURRENT_SOURCE_DIR}/note.cpp
-#     kolabformatv2.cpp
-    PARENT_SCOPE)
diff --git a/kolabformatV2/contact.cpp b/kolabformatV2/contact.cpp
deleted file mode 100644
index a788130..0000000
--- a/kolabformatV2/contact.cpp
+++ /dev/null
@@ -1,1214 +0,0 @@
-/*
-    This file is part of libkabc and/or kaddressbook.
-    Copyright (c) 2004 Klarlvdalens Datakonsult AB
-        <info@klaralvdalens-datakonsult.se>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#include "contact.h"
-
-#include <kabc/addressee.h>
-#include <kdebug.h>
-#include <QFile>
-#include <float.h>
-
-using namespace KolabV2;
-
-static const char* s_pictureAttachmentName = "kolab-picture.png";
-static const char* s_logoAttachmentName = "kolab-logo.png";
-static const char* s_soundAttachmentName = "sound";
-static const char* s_unhandledTagAppName = "KOLABUNHANDLED"; // no hyphens in appnames!
-
-// saving (addressee->xml)
-Contact::Contact( const KABC::Addressee* addr )
-  : mHasGeo( false )
-{
-  setFields( addr );
-}
-
-// loading (xml->addressee)
-Contact::Contact( const QString& xml )
-  : mHasGeo( false )
-{
-  load( xml );
-}
-
-Contact::~Contact()
-{
-}
-
-void Contact::setGivenName( const QString& name )
-{
-  mGivenName = name;
-}
-
-QString Contact::givenName() const
-{
-  return mGivenName;
-}
-
-void Contact::setMiddleNames( const QString& names )
-{
-  mMiddleNames = names;
-}
-
-QString Contact::middleNames() const
-{
-  return mMiddleNames;
-}
-
-void Contact::setLastName( const QString& name )
-{
-  mLastName = name;
-}
-
-QString Contact::lastName() const
-{
-  return mLastName;
-}
-
-void Contact::setFullName( const QString& name )
-{
-  mFullName = name;
-}
-
-QString Contact::fullName() const
-{
-  return mFullName;
-}
-
-void Contact::setInitials( const QString& initials )
-{
-  mInitials = initials;
-}
-
-QString Contact::initials() const
-{
-  return mInitials;
-}
-
-void Contact::setPrefix( const QString& prefix )
-{
-  mPrefix = prefix;
-}
-
-QString Contact::prefix() const
-{
-  return mPrefix;
-}
-
-void Contact::setSuffix( const QString& suffix )
-{
-  mSuffix = suffix;
-}
-
-QString Contact::suffix() const
-{
-  return mSuffix;
-}
-
-void Contact::setRole( const QString& role )
-{
-  mRole = role;
-}
-
-QString Contact::role() const
-{
-  return mRole;
-}
-
-void Contact::setFreeBusyUrl( const QString& fbUrl )
-{
-  mFreeBusyUrl = fbUrl;
-}
-
-QString Contact::freeBusyUrl() const
-{
-  return mFreeBusyUrl;
-}
-
-void Contact::setOrganization( const QString& organization )
-{
-  mOrganization = organization;
-}
-
-QString Contact::organization() const
-{
-  return mOrganization;
-}
-
-void Contact::setWebPage( const QString& url )
-{
-  mWebPage = url;
-}
-
-QString Contact::webPage() const
-{
-  return mWebPage;
-}
-
-void Contact::setIMAddress( const QString& imAddress )
-{
-  mIMAddress = imAddress;
-}
-
-QString Contact::imAddress() const
-{
-  return mIMAddress;
-}
-
-void Contact::setDepartment( const QString& department )
-{
-  mDepartment = department;
-}
-
-QString Contact::department() const
-{
-  return mDepartment;
-}
-
-void Contact::setOfficeLocation( const QString& location )
-{
-  mOfficeLocation = location;
-}
-
-QString Contact::officeLocation() const
-{
-  return mOfficeLocation;
-}
-
-void Contact::setProfession( const QString& profession )
-{
-  mProfession = profession;
-}
-
-QString Contact::profession() const
-{
-  return mProfession;
-}
-
-void Contact::setTitle( const QString& title )
-{
-  mTitle = title;
-}
-
-QString Contact::title() const
-{
-  return mTitle;
-}
-
-void Contact::setManagerName( const QString& name )
-{
-  mManagerName = name;
-}
-
-QString Contact::managerName() const
-{
-  return mManagerName;
-}
-
-void Contact::setAssistant( const QString& name )
-{
-  mAssistant = name;
-}
-
-QString Contact::assistant() const
-{
-  return mAssistant;
-}
-
-void Contact::setNickName( const QString& name )
-{
-  mNickName = name;
-}
-
-QString Contact::nickName() const
-{
-  return mNickName;
-}
-
-void Contact::setSpouseName( const QString& name )
-{
-  mSpouseName = name;
-}
-
-QString Contact::spouseName() const
-{
-  return mSpouseName;
-}
-
-void Contact::setBirthday( const QDate& date )
-{
-  mBirthday = date;
-}
-
-QDate Contact::birthday() const
-{
-  return mBirthday;
-}
-
-void Contact::setAnniversary( const QDate& date )
-{
-  mAnniversary = date;
-}
-
-QDate Contact::anniversary() const
-{
-  return mAnniversary;
-}
-
-void Contact::setChildren( const QString& children )
-{
-  mChildren = children;
-}
-
-QString Contact::children() const
-{
-  return mChildren;
-}
-
-void Contact::setGender( const QString& gender )
-{
-  mGender = gender;
-}
-
-QString Contact::gender() const
-{
-  return mGender;
-}
-
-void Contact::setLanguage( const QString& language )
-{
-  mLanguage = language;
-}
-
-QString Contact::language() const
-{
-  return mLanguage;
-}
-
-void Contact::addPhoneNumber( const PhoneNumber& number )
-{
-  mPhoneNumbers.append( number );
-}
-
-QList<Contact::PhoneNumber>& Contact::phoneNumbers()
-{
-  return mPhoneNumbers;
-}
-
-const QList<Contact::PhoneNumber>& Contact::phoneNumbers() const
-{
-  return mPhoneNumbers;
-}
-
-void Contact::addEmail( const Email& email )
-{
-  mEmails.append( email );
-}
-
-QList<Contact::Email>& Contact::emails()
-{
-  return mEmails;
-}
-
-QString Contact::fullEmail() const
-{
-  return mFullEmail;
-}
-
-const QList<Contact::Email>& Contact::emails() const
-{
-  return mEmails;
-}
-
-void Contact::addAddress( const Contact::Address& address )
-{
-  mAddresses.append( address );
-}
-
-QList<Contact::Address>& Contact::addresses()
-{
-  return mAddresses;
-}
-
-const QList<Contact::Address>& Contact::addresses() const
-{
-  return mAddresses;
-}
-
-void Contact::setPreferredAddress( const QString& address )
-{
-  mPreferredAddress = address;
-}
-
-QString Contact::preferredAddress() const
-{
-  return mPreferredAddress;
-}
-
-bool Contact::loadNameAttribute( QDomElement& element )
-{
-  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      QString tagName = e.tagName();
-
-      if ( tagName == "given-name" )
-        setGivenName( e.text() );
-      else if ( tagName == "middle-names" )
-        setMiddleNames( e.text() );
-      else if ( tagName == "last-name" )
-        setLastName( e.text() );
-      else if ( tagName == "full-name" )
-        setFullName( e.text() );
-      else if ( tagName == "initials" )
-        setInitials( e.text() );
-      else if ( tagName == "prefix" )
-        setPrefix( e.text() );
-      else if ( tagName == "suffix" )
-        setSuffix( e.text() );
-      else
-        // TODO: Unhandled tag - save for later storage
-        kDebug() <<"Warning: Unhandled tag" << e.tagName();
-    } else
-      kDebug() <<"Node is not a comment or an element???";
-  }
-
-  return true;
-}
-
-void Contact::saveNameAttribute( QDomElement& element ) const
-{
-  QDomElement e = element.ownerDocument().createElement( "name" );
-  element.appendChild( e );
-
-  writeString( e, "given-name", givenName() );
-  writeString( e, "middle-names", middleNames() );
-  writeString( e, "last-name", lastName() );
-  writeString( e, "full-name", fullName() );
-  writeString( e, "initials", initials() );
-  writeString( e, "prefix", prefix() );
-  writeString( e, "suffix", suffix() );
-}
-
-bool Contact::loadPhoneAttribute( QDomElement& element )
-{
-  PhoneNumber number;
-  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      QString tagName = e.tagName();
-
-      if ( tagName == "type" )
-        number.type = e.text();
-      else if ( tagName == "number" )
-        number.number = e.text();
-      else
-        // TODO: Unhandled tag - save for later storage
-        kDebug() <<"Warning: Unhandled tag" << e.tagName();
-    } else
-      kDebug() <<"Node is not a comment or an element???";
-  }
-
-  addPhoneNumber( number );
-  return true;
-}
-
-void Contact::savePhoneAttributes( QDomElement& element ) const
-{
-  QList<PhoneNumber>::ConstIterator it = mPhoneNumbers.constBegin();
-  for ( ; it != mPhoneNumbers.constEnd(); ++it ) {
-    QDomElement e = element.ownerDocument().createElement( "phone" );
-    element.appendChild( e );
-    const PhoneNumber& p = *it;
-    writeString( e, "type", p.type );
-    writeString( e, "number", p.number );
-  }
-}
-
-void Contact::saveEmailAttributes( QDomElement& element ) const
-{
-  QList<Email>::ConstIterator it = mEmails.constBegin();
-  for ( ; it != mEmails.constEnd(); ++it )
-    saveEmailAttribute( element, *it );
-}
-
-void Contact::loadCustomAttributes( QDomElement& element )
-{
-  Custom custom;
-  custom.app = element.attribute( "app" );
-  custom.name = element.attribute( "name" );
-  custom.value = element.attribute( "value" );
-  mCustomList.append( custom );
-}
-
-void Contact::saveCustomAttributes( QDomElement& element ) const
-{
-  QList<Custom>::ConstIterator it = mCustomList.constBegin();
-  for ( ; it != mCustomList.constEnd(); ++it ) {
-    Q_ASSERT( !(*it).name.isEmpty() );
-    if ( (*it).app == s_unhandledTagAppName ) {
-      writeString( element, (*it).name, (*it).value );
-    } else {
-      // Let's use attributes so that other tag-preserving-code doesn't need sub-elements
-      QDomElement e = element.ownerDocument().createElement( "x-custom" );
-      element.appendChild( e );
-      e.setAttribute( "app", (*it).app );
-      e.setAttribute( "name", (*it).name );
-      e.setAttribute( "value", (*it).value );
-    }
-  }
-}
-
-bool Contact::loadAddressAttribute( QDomElement& element )
-{
-  Address address;
-
-  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      QString tagName = e.tagName();
-
-      if ( tagName == "type" )
-        address.type = e.text();
-      else if ( tagName == "x-kde-type" )
-        address.kdeAddressType = e.text().toInt();
-      else if ( tagName == "street" )
-        address.street = e.text();
-      else if ( tagName == "pobox" )
-        address.pobox = e.text();
-      else if ( tagName == "locality" )
-        address.locality = e.text();
-      else if ( tagName == "region" )
-        address.region = e.text();
-      else if ( tagName == "postal-code" )
-        address.postalCode = e.text();
-      else if ( tagName == "country" )
-        address.country = e.text();
-      else
-        // TODO: Unhandled tag - save for later storage
-        kDebug() <<"Warning: Unhandled tag" << e.tagName();
-    } else
-      kDebug() <<"Node is not a comment or an element???";
-  }
-
-  addAddress( address );
-  return true;
-}
-
-void Contact::saveAddressAttributes( QDomElement& element ) const
-{
-  QList<Address>::ConstIterator it = mAddresses.constBegin();
-  for ( ; it != mAddresses.constEnd(); ++it ) {
-    QDomElement e = element.ownerDocument().createElement( "address" );
-    element.appendChild( e );
-    const Address& a = *it;
-    writeString( e, "type", a.type );
-    writeString( e, "x-kde-type", QString::number( a.kdeAddressType ) );
-    if ( !a.street.isEmpty() )
-      writeString( e, "street", a.street );
-    if ( !a.pobox.isEmpty() )
-      writeString( e, "pobox", a.pobox );
-    if ( !a.locality.isEmpty() )
-    writeString( e, "locality", a.locality );
-    if ( !a.region.isEmpty() )
-      writeString( e, "region", a.region );
-    if ( !a.postalCode.isEmpty() )
-      writeString( e, "postal-code", a.postalCode );
-    if ( !a.country.isEmpty() )
-      writeString( e, "country", a.country );
-  }
-}
-
-bool Contact::loadAttribute( QDomElement& element )
-{
-  const QString tagName = element.tagName();
-  switch ( tagName[0].toLatin1() ) {
-  case 'a':
-    if ( tagName == "address" )
-      return loadAddressAttribute( element );
-    if ( tagName == "assistant" ) {
-      setAssistant( element.text() );
-      return true;
-    }
-    if ( tagName == "anniversary" ) {
-      if ( !element.text().isEmpty() )
-        setAnniversary( stringToDate( element.text() ) );
-      return true;
-    }
-    break;
-  case 'b':
-    if ( tagName == "birthday" ) {
-      if ( !element.text().isEmpty() )
-        setBirthday( stringToDate( element.text() ) );
-      return true;
-    }
-    break;
-  case 'c':
-    if ( tagName == "children" ) {
-      setChildren( element.text() );
-      return true;
-    }
-    break;
-  case 'd':
-    if ( tagName == "department" ) {
-      setDepartment( element.text() );
-      return true;
-    }
-    break;
-  case 'e':
-    if ( tagName == "email" ) {
-      Email email;
-      if ( loadEmailAttribute( element, email ) ) {
-        addEmail( email );
-        return true;
-      } else
-        return false;
-    }
-    break;
-  case 'f':
-    if ( tagName == "free-busy-url" ) {
-      setFreeBusyUrl( element.text() );
-      return true;
-    }
-    break;
-  case 'g':
-    if ( tagName == "gender" ) {
-      setGender( element.text() );
-      return true;
-    }
-    break;
-  case 'i':
-    if ( tagName == "im-address" ) {
-      setIMAddress( element.text() );
-      return true;
-    }
-    break;
-  case 'j':
-   if ( tagName == "job-title" ) {
-     // see saveAttributes: <job-title> is mapped to the Role field
-      setTitle( element.text() );
-      return true;
-    }
-    break;
-  case 'l':
-    if ( tagName == "language" ) {
-      setLanguage( element.text() );
-      return true;
-    }
-    if ( tagName == "latitude" ) {
-      setLatitude( element.text().toFloat() );
-      mHasGeo = true;
-      return true;
-    }
-    if ( tagName == "longitude" ) {
-      setLongitude( element.text().toFloat() );
-      mHasGeo = true;
-    }
-    break;
-  case 'm':
-    if ( tagName == "manager-name" ) {
-      setManagerName( element.text() );
-      return true;
-    }
-  case 'n':
-    if ( tagName == "name" )
-      return loadNameAttribute( element );
-    if ( tagName == "nick-name" ) {
-      setNickName( element.text() );
-      return true;
-    }
-    break;
-  case 'o':
-    if ( tagName == "organization" ) {
-      setOrganization( element.text() );
-      return true;
-    }
-    if ( tagName == "office-location" ) {
-      setOfficeLocation( element.text() );
-      return true;
-    }
-    break;
-  case 'p':
-    if ( tagName == "profession" ) {
-      setProfession( element.text() );
-      return true;
-    }
-    if ( tagName == "picture" ) {
-      mPictureAttachmentName = element.text();
-      return true;
-    }
-    if ( tagName == "phone" ) {
-      return loadPhoneAttribute( element );
-      return true;
-    }
-    if ( tagName == "preferred-address" ) {
-      setPreferredAddress( element.text() );
-      return true;
-    }
-    break;
-  case 'r':
-    if ( tagName == "role" ) {
-      setRole( element.text() );
-      return true;
-    }
-    break;
-  case 's':
-    if ( tagName == "spouse-name" ) {
-      setSpouseName( element.text() );
-      return true;
-    }
-    break;
-  case 'x':
-    if ( tagName == "x-logo" ) {
-      mLogoAttachmentName = element.text();
-      return true;
-    }
-    if ( tagName == "x-sound" ) {
-      mSoundAttachmentName = element.text();
-      return true;
-    }
-    if ( tagName == "x-custom" ) {
-      loadCustomAttributes( element );
-      return true;
-    }
-    if ( tagName == "x-title" ) {
-      setTitle( element.text() );
-      return true;
-    }
-    break;
-  case 'w':
-    if ( tagName == "web-page" ) {
-      setWebPage( element.text() );
-      return true;
-    }
-    break;
-  default:
-    break;
-  }
-  return KolabBase::loadAttribute( element );
-}
-
-bool Contact::saveAttributes( QDomElement& element ) const
-{
-  // Save the base class elements
-  KolabBase::saveAttributes( element );
-  saveNameAttribute( element );
-  writeString( element, "free-busy-url", freeBusyUrl() );
-  writeString( element, "organization", organization() );
-  writeString( element, "web-page", webPage() );
-  writeString( element, "im-address", imAddress() );
-  writeString( element, "department", department() );
-  writeString( element, "office-location", officeLocation() );
-  writeString( element, "profession", profession() );
-  writeString( element, "role", role() );
-  writeString( element, "job-title", title() );
-  writeString( element, "manager-name", managerName() );
-  writeString( element, "assistant", assistant() );
-  writeString( element, "nick-name", nickName() );
-  writeString( element, "spouse-name", spouseName() );
-  writeString( element, "birthday", dateToString( birthday() ) );
-  writeString( element, "anniversary", dateToString( anniversary() ) );
-  if ( !picture().isNull() )
-    writeString( element, "picture", mPictureAttachmentName );
-  if ( !logo().isNull() )
-    writeString( element, "x-logo", mLogoAttachmentName );
-  if ( !sound().isNull() )
-    writeString( element, "x-sound", mSoundAttachmentName );
-  writeString( element, "children", children() );
-  writeString( element, "gender", gender() );
-  writeString( element, "language", language() );
-  savePhoneAttributes( element );
-  saveEmailAttributes( element );
-  saveAddressAttributes( element );
-  writeString( element, "preferred-address", preferredAddress() );
-  if ( mHasGeo ) {
-    writeString( element, "latitude", QString::number( latitude(), 'g', DBL_DIG ) );
-    writeString( element, "longitude", QString::number( longitude(), 'g', DBL_DIG ) );
-  }
-  saveCustomAttributes( element );
-
-  return true;
-}
-
-bool Contact::loadXML( const QDomDocument& document )
-{
-  QDomElement top = document.documentElement();
-
-  if ( top.tagName() != "contact" ) {
-    qWarning( "XML error: Top tag was %s instead of the expected contact",
-              top.tagName().toAscii().data() );
-    return false;
-  }
-
-  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      if ( !loadAttribute( e ) ) {
-        // Unhandled tag - save for later storage
-        //kDebug() <<"Saving unhandled tag" << e.tagName();
-        Custom c;
-        c.app = s_unhandledTagAppName;
-        c.name = e.tagName();
-        c.value = e.text();
-        mCustomList.append( c );
-      }
-    } else
-      kDebug() <<"Node is not a comment or an element???";
-  }
-
-  return true;
-}
-
-QString Contact::saveXML() const
-{
-  QDomDocument document = domTree();
-  QDomElement element = document.createElement("contact" );
-  element.setAttribute( "version", "1.0" );
-  saveAttributes( element );
-  document.appendChild( element );
-  return document.toString();
-}
-
-static QString addressTypeToString( int /*KABC::Address::Type*/ type )
-{
-  if ( type & KABC::Address::Home )
-    return "home";
-  if ( type & KABC::Address::Work )
-    return "business";
-  return "other";
-}
-
-static int addressTypeFromString( const QString& type )
-{
-  if ( type == "home" )
-    return KABC::Address::Home;
-  if ( type == "business" )
-    return KABC::Address::Work;
-  // well, this shows "other" in the editor, which is what we want...
-  return KABC::Address::Dom | KABC::Address::Intl | KABC::Address::Postal | KABC::Address::Parcel;
-}
-
-static QStringList phoneTypeToString( KABC::PhoneNumber::Type type )
-{
-  // KABC has a bitfield, i.e. the same phone number can be used for work and home
-  // and fax and cellphone etc. etc.
-  // So when saving we need to create as many tags as bits that were set.
-  QStringList types;
-  if ( type & KABC::PhoneNumber::Fax ) {
-    if ( type & KABC::PhoneNumber::Home )
-      types << "homefax";
-    else // assume work -- if ( type & KABC::PhoneNumber::Work )
-      types << "businessfax";
-    type = type & ~KABC::PhoneNumber::Home;
-    type = type & ~KABC::PhoneNumber::Work;
-  }
-
-  // To support both "home1" and "home2", map Home+Pref to home1
-  if ( ( type & KABC::PhoneNumber::Home ) && ( type & KABC::PhoneNumber::Pref ) )
-  {
-      types << "home1";
-      type = type & ~KABC::PhoneNumber::Home;
-      type = type & ~KABC::PhoneNumber::Pref;
-  }
-  // To support both "business1" and "business2", map Work+Pref to business1
-  if ( ( type & KABC::PhoneNumber::Work ) && ( type & KABC::PhoneNumber::Pref ) )
-  {
-      types << "business1";
-      type = type & ~KABC::PhoneNumber::Work;
-      type = type & ~KABC::PhoneNumber::Pref;
-  }
-
-
-  if ( type & KABC::PhoneNumber::Home )
-    types << "home2";
-  if ( type & KABC::PhoneNumber::Msg ) // Msg==messaging
-    types << "company";
-  if ( type & KABC::PhoneNumber::Work )
-    types << "business2";
-  if ( type & KABC::PhoneNumber::Pref )
-    types << "primary";
-  if ( type & KABC::PhoneNumber::Voice )
-    types << "callback"; // ##
-  if ( type & KABC::PhoneNumber::Cell )
-    types << "mobile";
-  if ( type & KABC::PhoneNumber::Video )
-    types << "radio"; // ##
-  if ( type & KABC::PhoneNumber::Bbs )
-    types << "ttytdd";
-  if ( type & KABC::PhoneNumber::Modem )
-    types << "telex"; // #
-  if ( type & KABC::PhoneNumber::Car )
-    types << "car";
-  if ( type & KABC::PhoneNumber::Isdn )
-    types << "isdn";
-  if ( type & KABC::PhoneNumber::Pcs )
-    types << "assistant"; // ## Assistant is e.g. secretary
-  if ( type & KABC::PhoneNumber::Pager )
-    types << "pager";
-  return types;
-}
-
-static KABC::PhoneNumber::Type phoneTypeFromString( const QString& type )
-{
-  if ( type == "homefax" )
-    return KABC::PhoneNumber::Home | KABC::PhoneNumber::Fax;
-  if ( type == "businessfax" )
-    return KABC::PhoneNumber::Work | KABC::PhoneNumber::Fax;
-  if ( type == "business1" )
-    return KABC::PhoneNumber::Work | KABC::PhoneNumber::Pref;
-  if ( type == "business2" )
-    return KABC::PhoneNumber::Work;
-  if ( type == "home1" )
-    return KABC::PhoneNumber::Home | KABC::PhoneNumber::Pref;
-  if ( type == "home2" )
-    return KABC::PhoneNumber::Home;
-  if ( type == "company" )
-    return KABC::PhoneNumber::Msg;
-  if ( type == "primary" )
-    return KABC::PhoneNumber::Pref;
-  if ( type == "callback" )
-    return KABC::PhoneNumber::Voice;
-  if ( type == "mobile" )
-    return KABC::PhoneNumber::Cell;
-  if ( type == "radio" )
-    return KABC::PhoneNumber::Video;
-  if ( type == "ttytdd" )
-    return KABC::PhoneNumber::Bbs;
-  if ( type == "telex" )
-    return KABC::PhoneNumber::Modem;
-  if ( type == "car" )
-    return KABC::PhoneNumber::Car;
-  if ( type == "isdn" )
-    return KABC::PhoneNumber::Isdn;
-  if ( type == "assistant" )
-    return KABC::PhoneNumber::Pcs;
-  if ( type == "pager" )
-    return KABC::PhoneNumber::Pager;
-  return KABC::PhoneNumber::Home; // whatever
-}
-
-static const char* s_knownCustomFields[] = {
-  "X-IMAddress",
-  "X-Office",
-  "X-Profession",
-  "X-ManagersName",
-  "X-AssistantsName",
-  "X-SpousesName",
-  "X-Anniversary",
-  "DistributionList",
-  0
-};
-
-
-// The saving is addressee -> Contact -> xml, this is the first part
-void Contact::setFields( const KABC::Addressee* addressee )
-{
-  KolabBase::setFields( addressee );
-
-  setGivenName( addressee->givenName() );
-  setMiddleNames( addressee->additionalName() );
-  setLastName( addressee->familyName() );
-  setFullName( addressee->formattedName() );
-  setPrefix( addressee->prefix() );
-  setSuffix( addressee->suffix() );
-  setOrganization( addressee->organization() );
-  setWebPage( addressee->url().url() );
-  setIMAddress( addressee->custom( "KADDRESSBOOK", "X-IMAddress" ) );
-  setDepartment( addressee->department());
-  setOfficeLocation( addressee->custom( "KADDRESSBOOK", "X-Office" ) );
-  setProfession( addressee->custom( "KADDRESSBOOK", "X-Profession" ) );
-  setRole( addressee->role() );
-  setTitle( addressee->title() );
-  setManagerName( addressee->custom( "KADDRESSBOOK", "X-ManagersName" ) );
-  setAssistant( addressee->custom( "KADDRESSBOOK", "X-AssistantsName" ) );
-  setNickName( addressee->nickName() );
-  setSpouseName( addressee->custom( "KADDRESSBOOK", "X-SpousesName" ) );
-  if ( !addressee->birthday().isNull() )
-    setBirthday( addressee->birthday().date() );
-  const QString& anniversary = addressee->custom( "KADDRESSBOOK", "X-Anniversary" );
-  if ( !anniversary.isEmpty() )
-    setAnniversary( stringToDate( anniversary  ) );
-
-  const QStringList emails = addressee->emails();
-  // Conversion problem here:
-  // KABC::Addressee has only one full name and N addresses, but the XML format
-  // has N times (fullname+address). So we just copy the fullname over and ignore it on loading.
-  for ( QStringList::ConstIterator it = emails.constBegin(); it != emails.constEnd(); ++it ) {
-    Email email;
-    email.displayName = fullName();
-    email.smtpAddress = *it;
-    addEmail( email );
-  }
-
-  // save formatted full email for later usage
-  mFullEmail = addressee->fullEmail();
-
-  // Now the real-world addresses
-  QString preferredAddress = "home";
-  const KABC::Address::List addresses = addressee->addresses();
-  for ( KABC::Address::List::ConstIterator it = addresses.constBegin() ; it != addresses.constEnd(); ++it ) {
-    Address address;
-    address.kdeAddressType = (*it).type();
-    address.type = addressTypeToString( address.kdeAddressType );
-    address.street = (*it).street();
-    address.pobox = (*it).postOfficeBox();
-    address.locality = (*it).locality();
-    address.region = (*it).region();
-    address.postalCode = (*it).postalCode();
-    address.country = (*it).country();
-    // ## TODO not in the XML format: extended address info.
-    // ## KDE-specific tags? Or hiding those fields? Or adding a warning?
-    addAddress( address );
-    if ( address.kdeAddressType & KABC::Address::Pref ) {
-      preferredAddress = address.type; // home, business or other
-    }
-  }
-  setPreferredAddress( preferredAddress );
-
-  const KABC::PhoneNumber::List phones = addressee->phoneNumbers();
-  for ( KABC::PhoneNumber::List::ConstIterator it = phones.constBegin(); it != phones.constEnd(); ++it ) {
-    // Create a tag per phone type set in the bitfield
-    QStringList types = phoneTypeToString( (*it).type() );
-    for( QStringList::ConstIterator typit = types.constBegin(); typit != types.constEnd(); ++typit ) {
-      PhoneNumber phoneNumber;
-      phoneNumber.type = *typit;
-      phoneNumber.number = (*it).number();
-      addPhoneNumber( phoneNumber );
-    }
-  }
-
-  setPicture( loadPictureFromAddressee( addressee->photo() ), addressee->photo().type() );
-  mPictureAttachmentName = addressee->custom( "KOLAB", "PictureAttachmentName" );
-  if ( mPictureAttachmentName.isEmpty() )
-    mPictureAttachmentName = s_pictureAttachmentName;
-
-  setLogo( loadPictureFromAddressee( addressee->logo() ), addressee->logo().type() );
-  mLogoAttachmentName = addressee->custom( "KOLAB", "LogoAttachmentName" );
-  if ( mLogoAttachmentName.isEmpty() )
-    mLogoAttachmentName = s_logoAttachmentName;
-
-  setSound( loadSoundFromAddressee( addressee->sound() ) );
-  mSoundAttachmentName = addressee->custom( "KOLAB", "SoundAttachmentName" );
-  if ( mSoundAttachmentName.isEmpty() )
-    mSoundAttachmentName = s_soundAttachmentName;
-
-  if ( addressee->geo().isValid() ) {
-    setLatitude( addressee->geo().latitude() );
-    setLongitude( addressee->geo().longitude() );
-    mHasGeo = true;
-  }
-
-  // Other KADDRESSBOOK custom fields than those already handled
-  //    (includes e.g. crypto settings, and extra im addresses)
-  QStringList knownCustoms;
-  for ( const char** p = s_knownCustomFields; *p; ++p )
-    knownCustoms << QString::fromLatin1( *p );
-  QStringList customs = addressee->customs();
-  for( QStringList::ConstIterator it = customs.constBegin(); it != customs.constEnd(); ++it ) {
-    // KABC::Addressee doesn't offer a real way to iterate over customs, other than splitting strings ourselves
-    // The format is "app-name:value".
-    int pos = (*it).indexOf( '-' );
-    if ( pos == -1 ) continue;
-    QString app = (*it).left( pos );
-    if ( app == "KOLAB" ) continue;
-    QString name = (*it).mid( pos + 1 );
-    pos = name.indexOf( ':' );
-    if ( pos == -1 ) continue;
-    QString value = name.mid( pos + 1 );
-    name = name.left( pos );
-    if ( !knownCustoms.contains( name ) ) {
-      //kDebug() <<"app=" << app <<" name=" << name <<" value=" << value;
-      Custom c;
-      if ( app != "KADDRESSBOOK" ) // that's the default
-        c.app = app;
-      c.name = name;
-      c.value = value;
-      mCustomList.append( c );
-    }
-  }
-
-  const QString url = addressee->custom("KOLAB", "FreebusyUrl");
-  if ( !url.isEmpty() ) {
-    setFreeBusyUrl( url );
-  }
-
-  // Those fields, although defined in Addressee, are not used in KDE
-  // (e.g. not visible in kaddressbook/addresseeeditorwidget.cpp)
-  // So it doesn't matter much if we don't have them in the XML.
-  // mailer, timezone, productId, sortString, agent, rfc2426 name()
-
-  // Things KAddressBook can't handle, so they are saved as unhandled tags:
-  // initials, children, gender, language
-}
-
-
-// The loading is: xml -> Contact -> addressee, this is the second part
-void Contact::saveTo( KABC::Addressee* addressee )
-{
-  // TODO: This needs the same set of TODOs as the setFields method
-  KolabBase::saveTo( addressee );
-
-  addressee->setGivenName( givenName() );
-  addressee->setAdditionalName( middleNames() );
-  addressee->setFamilyName( lastName() );
-  addressee->setFormattedName( fullName() );
-  addressee->setPrefix( prefix() );
-  addressee->setSuffix( suffix() );
-  addressee->setOrganization( organization() );
-  addressee->setUrl( webPage() );
-  addressee->insertCustom( "KADDRESSBOOK", "X-IMAddress", imAddress() );
-  addressee->setDepartment( department() );
-  addressee->insertCustom( "KADDRESSBOOK", "X-Office", officeLocation() );
-  addressee->insertCustom( "KADDRESSBOOK", "X-Profession", profession() );
-  addressee->setRole( role() );
-  addressee->setTitle( title() );
-  addressee->insertCustom( "KADDRESSBOOK", "X-ManagersName", managerName() );
-  addressee->insertCustom( "KADDRESSBOOK", "X-AssistantsName", assistant() );
-  addressee->setNickName( nickName() );
-  addressee->insertCustom( "KADDRESSBOOK", "X-SpousesName", spouseName() );
-  if ( birthday().isValid() )
-    addressee->setBirthday( QDateTime( birthday() ) );
-
-  if ( anniversary().isValid() )
-    addressee->insertCustom( "KADDRESSBOOK", "X-Anniversary",
-                             dateToString( anniversary() ) );
-  else
-    addressee->removeCustom( "KADDRESSBOOK", "X-Anniversary" );
-  
-  addressee->insertCustom( "KOLAB", "FreebusyUrl", freeBusyUrl() );
-
-  // We need to store both the original attachment name and the picture data into the addressee.
-  // This is important, otherwise we would save the image under another attachment name w/o deleting the original one!
-  if ( !mPicture.isNull() ) {
-    KABC::Picture picture( mPicture );
-    addressee->setPhoto( picture );
-  }
-  // Note that we must save the filename in all cases, so that removing the picture
-  // actually deletes the attachment.
-  addressee->insertCustom( "KOLAB", "PictureAttachmentName", mPictureAttachmentName );
-  if ( !mLogo.isNull() ) {
-    KABC::Picture picture( mLogo );
-    addressee->setLogo( picture );
-  }
-  addressee->insertCustom( "KOLAB", "LogoAttachmentName", mLogoAttachmentName );
-  if ( !mSound.isNull() )
-    addressee->setSound( KABC::Sound( mSound ) );
-  addressee->insertCustom( "KOLAB", "SoundAttachmentName", mSoundAttachmentName );
-
-  if ( mHasGeo )
-    addressee->setGeo( KABC::Geo( mLatitude, mLongitude ) );
-
-  QStringList emailAddresses;
-  for ( QList<Email>::ConstIterator it = mEmails.constBegin(); it != mEmails.constEnd(); ++it ) {
-    // we can't do anything with (*it).displayName
-    emailAddresses.append( (*it).smtpAddress );
-  }
-  addressee->setEmails( emailAddresses );
-
-  for ( QList<Address>::ConstIterator it = mAddresses.constBegin(); it != mAddresses.constEnd(); ++it ) {
-    KABC::Address address;
-    int type = (*it).kdeAddressType;
-    if ( type == -1 ) { // no kde-specific type available
-      type = addressTypeFromString( (*it).type );
-      if ( (*it).type == mPreferredAddress )
-        type |= KABC::Address::Pref;
-    }
-    address.setType( static_cast<KABC::Address::Type>(type) );
-    address.setStreet( (*it).street );
-    address.setPostOfficeBox( (*it).pobox );
-    address.setLocality( (*it).locality );
-    address.setRegion( (*it).region );
-    address.setPostalCode( (*it).postalCode );
-    address.setCountry( (*it).country );
-    addressee->insertAddress( address );
-  }
-
-  for ( QList<PhoneNumber>::ConstIterator it = mPhoneNumbers.constBegin(); it != mPhoneNumbers.constEnd(); ++it ) {
-    KABC::PhoneNumber number;
-    number.setType( phoneTypeFromString( (*it).type ) );
-    number.setNumber( (*it).number );
-    addressee->insertPhoneNumber( number );
-  }
-
-  for( QList<Custom>::ConstIterator it = mCustomList.constBegin(); it != mCustomList.constEnd(); ++it ) {
-    QString app = (*it).app.isEmpty() ? QString::fromLatin1( "KADDRESSBOOK" ) : (*it).app;
-    addressee->insertCustom( app, (*it).name, (*it).value );
-  }
-  //kDebug() << addressee->customs();
-}
-
-QImage Contact::loadPictureFromAddressee( const KABC::Picture& picture )
-{
-  QImage img;
-  if ( !picture.isIntern() && !picture.url().isEmpty() ) {
-    QString tmpFile;
-    kWarning() << "external pictures are currently not supported";
-    //FIXME add kio support to libcalendaring or use libcurl
-//     if ( KIO::NetAccess::download( picture.url(), tmpFile, 0 /*no widget known*/ ) ) {
-//       img.load( tmpFile );
-//       KIO::NetAccess::removeTempFile( tmpFile );
-//     }
-  } else
-    img = picture.data();
-  return img;
-}
-
-QByteArray KolabV2::Contact::loadSoundFromAddressee( const KABC::Sound& sound )
-{
-  QByteArray data;
-  if ( !sound.isIntern() && !sound.url().isEmpty() ) {
-    QString tmpFile;
-//     if ( KIO::NetAccess::download( sound.url(), tmpFile, 0 /*no widget known*/ ) ) {
-//       QFile f( tmpFile );
-//       if ( f.open( QIODevice::ReadOnly ) ) {
-//         data = f.readAll();
-//         f.close();
-//       }
-//       KIO::NetAccess::removeTempFile( tmpFile );
-//     }
-  } else
-    data = sound.data();
-  return data;
-}
-
-QString KolabV2::Contact::productID() const
-{
-  // TODO: When KAB has the version number in a header file, don't hardcode (Bo)
-  // Or we could use Addressee::productID? (David)
-  return "KAddressBook 3.3, Kolab resource";
-}
diff --git a/kolabformatV2/contact.h b/kolabformatV2/contact.h
deleted file mode 100644
index 44ef26d..0000000
--- a/kolabformatV2/contact.h
+++ /dev/null
@@ -1,278 +0,0 @@
-/*
-    This file is part of libkabc and/or kaddressbook.
-    Copyright (c) 2002 - 2004 Klarlvdalens Datakonsult AB
-        <info@klaralvdalens-datakonsult.se>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#ifndef KOLABV2CONTACT_H
-#define KOLABV2CONTACT_H
-
-#include "kolabbase.h"
-#include <qimage.h>
-
-namespace KABC {
-  class Addressee;
-  class Picture;
-  class Sound;
-}
-
-namespace KolabV2 {
-
-class Contact : public KolabBase {
-public:
-  struct PhoneNumber {
-  public:
-    QString type;
-    QString number;
-  };
-
-  struct Address {
-  public:
-    Address() : kdeAddressType( -1 )
-    {
-    }
-    int kdeAddressType; // KABC::Address::Type
-    QString type;       // kolab-compliant address type: home, work or other
-    QString street;
-    QString pobox;
-    QString locality;
-    QString region;
-    QString postalCode;
-    QString country;
-  };
-
-  explicit Contact( const KABC::Addressee* address );
-  Contact( const QString& xml );
-  ~Contact();
-
-  void saveTo( KABC::Addressee* address );
-
-  QString type() const { return "Contact"; }
-
-  void setGivenName( const QString& name );
-  QString givenName() const;
-
-  void setMiddleNames( const QString& names );
-  QString middleNames() const;
-
-  void setLastName( const QString& name );
-  QString lastName() const;
-
-  void setFullName( const QString& name );
-  QString fullName() const;
-
-  void setInitials( const QString& initials );
-  QString initials() const;
-
-  void setPrefix( const QString& prefix );
-  QString prefix() const;
-
-  void setSuffix( const QString& suffix );
-  QString suffix() const;
-
-  void setRole( const QString& role );
-  QString role() const;
-
-  void setFreeBusyUrl( const QString& fbUrl );
-  QString freeBusyUrl() const;
-
-  void setOrganization( const QString& organization );
-  QString organization() const;
-
-  void setWebPage( const QString& url );
-  QString webPage() const;
-
-  void setIMAddress( const QString& imAddress );
-  QString imAddress() const;
-
-  void setDepartment( const QString& department );
-  QString department() const;
-
-  void setOfficeLocation( const QString& location );
-  QString officeLocation() const;
-
-  void setProfession( const QString& profession );
-  QString profession() const;
-
-  void setTitle( const QString& title );
-  QString title() const;
-
-  void setManagerName( const QString& name );
-  QString managerName() const;
-
-  void setAssistant( const QString& name );
-  QString assistant() const;
-
-  void setNickName( const QString& name );
-  QString nickName() const;
-
-  void setSpouseName( const QString& name );
-  QString spouseName() const;
-
-  void setBirthday( const QDate& date );
-  QDate birthday() const;
-
-  void setAnniversary( const QDate& date );
-  QDate anniversary() const;
-
-  void setPicture( const QImage& image, const QString &format) { mPicture = image; mPictureFormat = format; }
-  QString pictureAttachmentName() const { return mPictureAttachmentName; }
-  QString pictureFormat() const { return mPictureFormat; }
-  QImage picture() const { return mPicture; }
-
-  void setLogo( const QImage& image, const QString &format ) { mLogo = image; mLogoFormat = format; }
-  QString logoAttachmentName() const { return mLogoAttachmentName; }
-  QString logoFormat() const { return mLogoFormat; }
-  QImage logo() const { return mLogo; }
-
-  void setSound( const QByteArray& sound ) { mSound = sound; }
-  QString soundAttachmentName() const { return mSoundAttachmentName; }
-  QByteArray sound() const { return mSound; }
-
-  void setChildren( const QString& children );
-  QString children() const;
-
-  void setGender( const QString& gender );
-  QString gender() const;
-
-  void setLanguage( const QString& language );
-  QString language() const;
-
-  void addPhoneNumber( const PhoneNumber& number );
-  QList<PhoneNumber>& phoneNumbers();
-  const QList<PhoneNumber>& phoneNumbers() const;
-
-  void addEmail( const Email& email );
-  QList<Email>& emails();
-  const QList<Email>& emails() const;
-
-  QString fullEmail() const;
-
-  void addAddress( const Address& address );
-  QList<Address>& addresses();
-  const QList<Address>& addresses() const;
-
-  // which address is preferred: home or business or other
-  void setPreferredAddress( const QString& address );
-  QString preferredAddress() const;
-
-  float latitude() const { return mLatitude; }
-  void setLatitude( float latitude ) { mLatitude = latitude; }
-
-  float longitude() const { return mLongitude; }
-  void setLongitude( float longitude ) { mLongitude = longitude; }
-
-  // Load the attributes of this class
-  bool loadAttribute( QDomElement& );
-
-  // Save the attributes of this class
-  bool saveAttributes( QDomElement& ) const;
-
-  // Load this note by reading the XML file
-  bool loadXML( const QDomDocument& xml );
-
-  // Serialize this note to an XML string
-  QString saveXML() const;
-
-protected:
-  void setFields( const KABC::Addressee* );
-
-private:
-  bool loadNameAttribute( QDomElement& element );
-  void saveNameAttribute( QDomElement& element ) const;
-
-  bool loadPhoneAttribute( QDomElement& element );
-  void savePhoneAttributes( QDomElement& element ) const;
-
-  void saveEmailAttributes( QDomElement& element ) const;
-
-  bool loadAddressAttribute( QDomElement& element );
-  void saveAddressAttributes( QDomElement& element ) const;
-
-  void loadCustomAttributes( QDomElement& element );
-  void saveCustomAttributes( QDomElement& element ) const;
-
-  QImage loadPictureFromAddressee( const KABC::Picture& picture );
-
-  QByteArray loadSoundFromAddressee( const KABC::Sound& sound );
-
-  QString productID() const;
-
-  QString mGivenName;
-  QString mMiddleNames;
-  QString mLastName;
-  QString mFullName;
-  QString mInitials;
-  QString mPrefix;
-  QString mSuffix;
-  QString mRole;
-  QString mFreeBusyUrl;
-  QString mOrganization;
-  QString mWebPage;
-  QString mIMAddress;
-  QString mDepartment;
-  QString mOfficeLocation;
-  QString mProfession;
-  QString mTitle;
-  QString mManagerName;
-  QString mAssistant;
-  QString mNickName;
-  QString mSpouseName;
-  QDate mBirthday;
-  QDate mAnniversary;
-  QImage mPicture;
-  QString mPictureFormat;
-  QImage mLogo;
-  QString mLogoFormat;
-  QByteArray mSound;
-  QString mPictureAttachmentName;
-  QString mLogoAttachmentName;
-  QString mSoundAttachmentName;
-  QString mChildren;
-  QString mGender;
-  QString mLanguage;
-  QList<PhoneNumber> mPhoneNumbers;
-  QList<Email> mEmails;
-  QString mFullEmail;
-  QList<Address> mAddresses;
-  QString mPreferredAddress;
-  float mLatitude;
-  float mLongitude;
-  bool mHasGeo;
-  struct Custom {
-    QString app;
-    QString name;
-    QString value;
-  };
-  QList<Custom> mCustomList;
-};
-
-}
-
-#endif // KOLABCONTACT_H
diff --git a/kolabformatV2/distributionlist.cpp b/kolabformatV2/distributionlist.cpp
deleted file mode 100644
index 6fe6873..0000000
--- a/kolabformatV2/distributionlist.cpp
+++ /dev/null
@@ -1,231 +0,0 @@
-/*
-    This file is part of Akonadi KolabProxy.
-    Copyright (c) 2009 Kevin Krammer <kevin.krammer@gmx.at>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#include "distributionlist.h"
-
-#include <kabc/addressee.h>
-#include <kabc/contactgroup.h>
-#include <kdebug.h>
-
-using namespace KolabV2;
-
-static const char* s_unhandledTagAppName = "KOLABUNHANDLED"; // no hyphens in appnames!
-
-// saving (contactgroup->xml)
-DistributionList::DistributionList( const KABC::ContactGroup* contactGroup )
-{
-  setFields( contactGroup );
-}
-
-// loading (xml->contactgroup)
-DistributionList::DistributionList( const QString& xml )
-{
-  load( xml );
-}
-
-DistributionList::~DistributionList()
-{
-}
-
-void DistributionList::setName( const QString& name )
-{
-  mName = name;
-}
-
-QString DistributionList::name() const
-{
-  return mName;
-}
-
-void KolabV2::DistributionList::loadDistrListMember( const QDomElement& element )
-{
-  Member member;
-  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      QString tagName = e.tagName();
-      if ( tagName == "display-name" )
-        member.displayName = e.text();
-      else if ( tagName == "smtp-address" )
-        member.email = e.text();
-      else if ( tagName == "uid" )
-        member.uid = e.text();
-    }
-  }
-  mDistrListMembers.append( member );
-}
-
-void DistributionList::saveDistrListMembers( QDomElement& element ) const
-{
-  QList<Member>::ConstIterator it = mDistrListMembers.constBegin();
-  for( ; it != mDistrListMembers.constEnd(); ++it ) {
-    QDomElement e = element.ownerDocument().createElement( "member" );
-    element.appendChild( e );
-    const Member& m = *it;
-    if (!m.uid.isEmpty()) {
-      writeString( e, "uid", m.uid );
-    } else {
-      writeString( e, "display-name", m.displayName );
-      writeString( e, "smtp-address", m.email );
-    }
-  }
-}
-
-bool DistributionList::loadAttribute( QDomElement& element )
-{
-  const QString tagName = element.tagName();
-  switch ( tagName[0].toLatin1() ) {
-  case 'd':
-    if ( tagName == "display-name" ) {
-      setName( element.text() );
-      return true;
-    }
-    break;
-  case 'm':
-    if ( tagName == "member" ) {
-      loadDistrListMember( element );
-      return true;
-    }
-    break;
-  default:
-    break;
-  }
-  return KolabBase::loadAttribute( element );
-}
-
-bool DistributionList::saveAttributes( QDomElement& element ) const
-{
-  // Save the base class elements
-  KolabBase::saveAttributes( element );
-  writeString( element, "display-name", name() );
-  saveDistrListMembers( element );
-
-  return true;
-}
-
-bool DistributionList::loadXML( const QDomDocument& document )
-{
-  QDomElement top = document.documentElement();
-
-  if ( top.tagName() != "distribution-list" ) {
-    qWarning( "XML error: Top tag was %s instead of the expected distribution-list",
-              top.tagName().toAscii().data() );
-    return false;
-  }
-
-
-  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      if ( !loadAttribute( e ) ) {
-        // Unhandled tag - save for later storage
-        //kDebug() <<"Saving unhandled tag" << e.tagName();
-        Custom c;
-        c.app = s_unhandledTagAppName;
-        c.name = e.tagName();
-        c.value = e.text();
-        mCustomList.append( c );
-      }
-    } else
-      kDebug() <<"Node is not a comment or an element???";
-  }
-
-  return true;
-}
-
-QString DistributionList::saveXML() const
-{
-  QDomDocument document = domTree();
-  QDomElement element = document.createElement( "distribution-list" );
-  element.setAttribute( "version", "1.0" );
-  saveAttributes( element );
-  document.appendChild( element );
-  return document.toString();
-}
-
-QString DistributionList::productID() const
-{
-  // TODO should we get name/version from desktop file?
-  return QLatin1String( "Akonadi Kolab Proxy" );
-}
-
-// The saving is contactgroup -> DistributionList -> xml, this is the first part
-void DistributionList::setFields( const KABC::ContactGroup* contactGroup )
-{
-  KolabBase::setFields( contactGroup );
-
-  setName( contactGroup->name() );
-
-  // explicit contact data
-  for ( uint index = 0; index < contactGroup->dataCount(); ++index ) {
-    const KABC::ContactGroup::Data& data = contactGroup->data( index );
-
-    Member m;
-    m.displayName = data.name();
-    m.email = data.email();
-
-    mDistrListMembers.append( m );
-  }
-  for ( uint index = 0; index < contactGroup->contactReferenceCount(); ++index ) {
-    const KABC::ContactGroup::ContactReference& data = contactGroup->contactReference( index );
-
-    Member m;
-    m.uid = data.uid();
-
-    mDistrListMembers.append( m );
-  }
-  if (contactGroup->contactGroupReferenceCount() > 0) {
-    kWarning() << "Tried to save contact group references, which should have been resolved already";
-  }
-}
-
-// The loading is: xml -> DistributionList -> contactgroup, this is the second part
-void DistributionList::saveTo( KABC::ContactGroup* contactGroup )
-{
-  KolabBase::saveTo( contactGroup );
-
-  contactGroup->setName( name() );
-
-  QList<Member>::ConstIterator mit = mDistrListMembers.constBegin();
-  for ( ; mit != mDistrListMembers.constEnd(); ++mit ) {
-    if (!(*mit).uid.isEmpty()) {
-      contactGroup->append(KABC::ContactGroup::ContactReference( (*mit).uid ));
-    } else {
-      contactGroup->append(KABC::ContactGroup::Data( (*mit).displayName, (*mit).email ));
-    }
-  }
-}
-
-// kate: space-indent on; indent-width 2; replace-tabs on;
diff --git a/kolabformatV2/distributionlist.h b/kolabformatV2/distributionlist.h
deleted file mode 100644
index f646540..0000000
--- a/kolabformatV2/distributionlist.h
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
-    This file is part of Akonadi KolabProxy
-    Copyright (c) 2009 <kevin.krammer@gmx.at>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#ifndef KOLABV2DISTRIBUTIONLIST_H
-#define KOLABV2DISTRIBUTIONLIST_H
-
-#include "kolabbase.h"
-
-namespace KABC {
-  class ContactGroup;
-}
-
-namespace KolabV2 {
-
-class DistributionList : public KolabBase {
-public:
-  explicit DistributionList( const KABC::ContactGroup* contactGroup );
-  DistributionList( const QString& xml );
-  ~DistributionList();
-
-  void saveTo( KABC::ContactGroup* contactGroup );
-
-  QString type() const { return "DistributionList"; }
-
-  void setName( const QString& name );
-  QString name() const;
-
-  // Load the attributes of this class
-  bool loadAttribute( QDomElement& );
-
-  // Save the attributes of this class
-  bool saveAttributes( QDomElement& ) const;
-
-  // Load this note by reading the XML file
-  bool loadXML( const QDomDocument& xml );
-
-  // Serialize this note to an XML string
-  QString saveXML() const;
-
-  QString productID() const;
-
-protected:
-  void setFields( const KABC::ContactGroup* );
-
-private:
-  void loadDistrListMember( const QDomElement& element );
-  void saveDistrListMembers( QDomElement& element ) const;
-
-  QString mName;
-
-  struct Custom {
-    QString app;
-    QString name;
-    QString value;
-  };
-  QList<Custom> mCustomList;
-
-  struct Member {
-    QString displayName;
-    QString email;
-    QString uid;
-  };
-  QList<Member> mDistrListMembers;
-};
-
-}
-
-#endif // KOLABDISTRIBUTIONLIST_H
-// kate: space-indent on; indent-width 2; replace-tabs on;
diff --git a/kolabformatV2/event.cpp b/kolabformatV2/event.cpp
deleted file mode 100644
index b09612d..0000000
--- a/kolabformatV2/event.cpp
+++ /dev/null
@@ -1,221 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#include "event.h"
-
-#include <kcalcore/event.h>
-#include <kdebug.h>
-
-using namespace KolabV2;
-
-
-KCalCore::Event::Ptr Event::fromXml( const QDomDocument& xmlDoc, const QString& tz)
-{
-  Event event( tz );
-  event.loadXML( xmlDoc );
-  KCalCore::Event::Ptr kcalEvent( new KCalCore::Event() );
-  event.saveTo( kcalEvent );
-  return kcalEvent;
-}
-
-QString Event::eventToXML( const KCalCore::Event::Ptr &kcalEvent, const QString& tz  )
-{
-  Event event( tz, kcalEvent );
-  return event.saveXML();
-}
-
-Event::Event( const QString& tz, const KCalCore::Event::Ptr &event )
-  : Incidence( tz, event ),
-  mShowTimeAs( KCalCore::Event::Opaque ), mHasEndDate( false )
-{
-  if ( event ) {
-    setFields( event );
-  }
-}
-
-Event::~Event()
-{
-}
-
-void Event::setTransparency( KCalCore::Event::Transparency transparency )
-{
-  mShowTimeAs = transparency;
-}
-
-KCalCore::Event::Transparency Event::transparency() const
-{
-  return mShowTimeAs;
-}
-
-void Event::setEndDate( const KDateTime& date )
-{
-  mEndDate = date;
-  mHasEndDate = true;
-  if ( mFloatingStatus == AllDay )
-    kDebug() <<"ERROR: Time on end date but no time on the event";
-  mFloatingStatus = HasTime;
-}
-
-void Event::setEndDate( const QDate& date )
-{
-  mEndDate = KDateTime( date );
-  mHasEndDate = true;
-  if ( mFloatingStatus == HasTime )
-    kDebug() <<"ERROR: No time on end date but time on the event";
-  mFloatingStatus = AllDay;
-}
-
-void Event::setEndDate( const QString& endDate )
-{
-  if ( endDate.length() > 10 )
-    // This is a date + time
-    setEndDate( stringToDateTime( endDate ) );
-  else
-    // This is only a date
-    setEndDate( stringToDate( endDate ) );
-}
-
-KDateTime Event::endDate() const
-{
-  return mEndDate;
-}
-
-bool Event::loadAttribute( QDomElement& element )
-{
-  // This method doesn't handle the color-label tag yet
-  QString tagName = element.tagName();
-
-  if ( tagName == "show-time-as" ) {
-    // TODO: Support tentative and outofoffice
-    if ( element.text() == "free" )
-      setTransparency( KCalCore::Event::Transparent );
-    else
-      setTransparency( KCalCore::Event::Opaque );
-  } else if ( tagName == "end-date" )
-    setEndDate( element.text() );
-  else
-    return Incidence::loadAttribute( element );
-
-  // We handled this
-  return true;
-}
-
-bool Event::saveAttributes( QDomElement& element ) const
-{
-  // Save the base class elements
-  Incidence::saveAttributes( element );
-
-  // TODO: Support tentative and outofoffice
-  if ( transparency() == KCalCore::Event::Transparent )
-    writeString( element, "show-time-as", "free" );
-  else
-    writeString( element, "show-time-as", "busy" );
-  if ( mHasEndDate ) {
-    if ( mFloatingStatus == HasTime )
-      writeString( element, "end-date", dateTimeToString( endDate() ) );
-    else
-      writeString( element, "end-date", dateToString( endDate().date() ) );
-  }
-
-  return true;
-}
-
-
-bool Event::loadXML( const QDomDocument& document )
-{
-  QDomElement top = document.documentElement();
-
-  if ( top.tagName() != "event" ) {
-    qWarning( "XML error: Top tag was %s instead of the expected event",
-              top.tagName().toAscii().data() );
-    return false;
-  }
-
-  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      loadAttribute( e );
-    } else
-      kDebug() <<"Node is not a comment or an element???";
-  }
-
-  return true;
-}
-
-QString Event::saveXML() const
-{
-  QDomDocument document = domTree();
-  QDomElement element = document.createElement( "event" );
-  element.setAttribute( "version", "1.0" );
-  saveAttributes( element );
-  document.appendChild( element );
-  return document.toString();
-}
-
-void Event::setFields( const KCalCore::Event::Ptr &event )
-{
-  Incidence::setFields( event );
-
-  // note: if hasEndDate() is false and hasDuration() is true
-  // dtEnd() returns start+duration
-  if ( event->hasEndDate() || event->hasDuration() ) {
-    if ( event->allDay() ) {
-      // This is an all-day event. Don't timezone move this one
-      mFloatingStatus = AllDay;
-      setEndDate( event->dtEnd().date() );
-    } else {
-      mFloatingStatus = HasTime;
-      setEndDate( localToUTC( event->dtEnd() ) );
-    }
-  } else {
-    mHasEndDate = false;
-  }
-  setTransparency( event->transparency() );
-}
-
-void Event::saveTo( const KCalCore::Event::Ptr &event )
-{
-  Incidence::saveTo( event );
-
-  event->setHasEndDate( mHasEndDate );
-  if ( mHasEndDate ) {
-    if ( mFloatingStatus == AllDay )
-      // This is an all-day event. Don't timezone move this one
-      event->setDtEnd( endDate() );
-    else
-      event->setDtEnd( utcToLocal( endDate() ) );
-  }
-  event->setTransparency( transparency() );
-}
diff --git a/kolabformatV2/event.h b/kolabformatV2/event.h
deleted file mode 100644
index be0d4bf..0000000
--- a/kolabformatV2/event.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#ifndef KOLABV2_EVENT_H
-#define KOLABV2_EVENT_H
-
-#include "incidence.h"
-
-#include <kcalcore/event.h>
-
-class QDomElement;
-
-
-namespace KolabV2 {
-
-/**
- * This class represents an event, and knows how to load/save it
- * from/to XML, and from/to a KCalCore::Event.
- * The instances of this class are temporary, only used to convert
- * one to the other.
- */
-class Event : public Incidence {
-public:
-  /// Use this to parse an xml string to a event entry
-  /// The caller is responsible for deleting the returned event
-  static KCalCore::Event::Ptr fromXml( const QDomDocument& xmlDoc, const QString& tz);
-
-  /// Use this to get an xml string describing this event entry
-  static QString eventToXML( const KCalCore::Event::Ptr &, const QString& tz );
-
-  /// Create a event object and
-  explicit Event( const QString& tz,
-                  const KCalCore::Event::Ptr &event = KCalCore::Event::Ptr() );
-  virtual ~Event();
-
-  void saveTo( const KCalCore::Event::Ptr &event );
-
-  virtual QString type() const { return "Event"; }
-
-  virtual void setTransparency( KCalCore::Event::Transparency transparency );
-  virtual KCalCore::Event::Transparency transparency() const;
-
-  virtual void setEndDate( const KDateTime& date );
-  virtual void setEndDate( const QDate& date );
-  virtual void setEndDate( const QString& date );
-  virtual KDateTime endDate() const;
-
-  // Load the attributes of this class
-  virtual bool loadAttribute( QDomElement& );
-
-  // Save the attributes of this class
-  virtual bool saveAttributes( QDomElement& ) const;
-
-  // Load this event by reading the XML file
-  virtual bool loadXML( const QDomDocument& xml );
-
-  // Serialize this event to an XML string
-  virtual QString saveXML() const;
-
-protected:
-  // Read all known fields from this ical incidence
-  void setFields( const KCalCore::Event::Ptr & );
-
-  KCalCore::Event::Transparency mShowTimeAs;
-  KDateTime mEndDate;
-  bool mHasEndDate;
-};
-
-}
-
-#endif // KOLAB_EVENT_H
diff --git a/kolabformatV2/incidence.cpp b/kolabformatV2/incidence.cpp
deleted file mode 100644
index 9f0e381..0000000
--- a/kolabformatV2/incidence.cpp
+++ /dev/null
@@ -1,1010 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#include "incidence.h"
-#include "libkolab-version.h"
-
-#include <QList>
-
-#include <kcalcore/journal.h>
-#include <kdebug.h>
-#include <kurl.h>
-
-#include <QBitArray>
-
-using namespace KolabV2;
-
-Incidence::Incidence( const QString& tz, const KCalCore::Incidence::Ptr &incidence )
-  : KolabBase( tz ), mFloatingStatus( Unset ), mHasAlarm( false ), mPriority( 0 )
-{
-  Q_UNUSED( incidence );
-}
-
-Incidence::~Incidence()
-{
-}
-
-void Incidence::setPriority( int priority )
-{
-  mPriority = priority;
-}
-
-int Incidence::priority() const
-{
-  return mPriority;
-}
-
-void Incidence::setSummary( const QString& summary )
-{
-  mSummary = summary;
-}
-
-QString Incidence::summary() const
-{
-  return mSummary;
-}
-
-void Incidence::setLocation( const QString& location )
-{
-  mLocation = location;
-}
-
-QString Incidence::location() const
-{
-  return mLocation;
-}
-
-void Incidence::setOrganizer( const Email& organizer )
-{
-  mOrganizer = organizer;
-}
-
-KolabBase::Email Incidence::organizer() const
-{
-  return mOrganizer;
-}
-
-void Incidence::setStartDate( const KDateTime& startDate )
-{
-  mStartDate = startDate;
-  if ( mFloatingStatus == AllDay )
-    kDebug() <<"ERROR: Time on start date but no time on the event";
-  mFloatingStatus = HasTime;
-}
-
-void Incidence::setStartDate( const QDate& startDate )
-{
-  mStartDate = KDateTime( startDate );
-  if ( mFloatingStatus == HasTime )
-    kDebug() <<"ERROR: No time on start date but time on the event";
-  mFloatingStatus = AllDay;
-}
-
-void Incidence::setStartDate( const QString& startDate )
-{
-  if ( startDate.length() > 10 )
-    // This is a date + time
-    setStartDate( stringToDateTime( startDate ) );
-  else
-    // This is only a date
-    setStartDate( stringToDate( startDate ) );
-}
-
-KDateTime Incidence::startDate() const
-{
-  return mStartDate;
-}
-
-void Incidence::setAlarm( float alarm )
-{
-  mAlarm = alarm;
-  mHasAlarm = true;
-}
-
-float Incidence::alarm() const
-{
-  return mAlarm;
-}
-
-Incidence::Recurrence Incidence::recurrence() const
-{
-  return mRecurrence;
-}
-
-void Incidence::addAttendee( const Attendee& attendee )
-{
-  mAttendees.append( attendee );
-}
-
-QList<Incidence::Attendee>& Incidence::attendees()
-{
-  return mAttendees;
-}
-
-const QList<Incidence::Attendee>& Incidence::attendees() const
-{
-  return mAttendees;
-}
-
-void Incidence::setInternalUID( const QString& iuid )
-{
-  mInternalUID = iuid;
-}
-
-QString Incidence::internalUID() const
-{
-  return mInternalUID;
-}
-
-bool Incidence::loadAttendeeAttribute( QDomElement& element,
-                                       Attendee& attendee )
-{
-  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      QString tagName = e.tagName();
-
-      if ( tagName == "display-name" )
-        attendee.displayName = e.text();
-      else if ( tagName == "smtp-address" )
-        attendee.smtpAddress = e.text();
-      else if ( tagName == "status" )
-        attendee.status = e.text();
-      else if ( tagName == "request-response" )
-        // This sets reqResp to false, if the text is "false". Otherwise it
-        // sets it to true. This means the default setting is true.
-        attendee.requestResponse = ( e.text().toLower() != "false" );
-      else if ( tagName == "invitation-sent" )
-        // Like above, only this defaults to false
-        attendee.invitationSent = ( e.text().toLower() != "true" );
-      else if ( tagName == "role" )
-        attendee.role = e.text();
-      else if ( tagName == "delegated-to" )
-        attendee.delegate = e.text();
-      else if ( tagName == "delegated-from" )
-        attendee.delegator = e.text();
-      else
-        // TODO: Unhandled tag - save for later storage
-        kDebug() <<"Warning: Unhandled tag" << e.tagName();
-    } else
-      kDebug() <<"Node is not a comment or an element???";
-  }
-
-  return true;
-}
-
-void Incidence::saveAttendeeAttribute( QDomElement& element,
-                                       const Attendee& attendee ) const
-{
-  QDomElement e = element.ownerDocument().createElement( "attendee" );
-  element.appendChild( e );
-  writeString( e, "display-name", attendee.displayName );
-  writeString( e, "smtp-address", attendee.smtpAddress );
-  writeString( e, "status", attendee.status );
-  writeString( e, "request-response",
-               ( attendee.requestResponse ? "true" : "false" ) );
-  writeString( e, "invitation-sent",
-               ( attendee.invitationSent ? "true" : "false" ) );
-  writeString( e, "role", attendee.role );
-  writeString( e, "delegated-to", attendee.delegate );
-  writeString( e, "delegated-from", attendee.delegator );
-}
-
-void Incidence::saveAttendees( QDomElement& element ) const
-{
-  foreach ( const Attendee& attendee, mAttendees )
-    saveAttendeeAttribute( element, attendee );
-}
-
-void Incidence::saveAttachments( QDomElement& element ) const
-{
-  foreach ( KCalCore::Attachment::Ptr a, mAttachments ) {
-    if ( a->isUri() ) {
-      writeString( element, "link-attachment", a->uri() );
-    } else if ( a->isBinary() ) {
-      writeString( element, "inline-attachment", a->label() );
-    }
-  }
-}
-
-void Incidence::saveAlarms( QDomElement& element ) const
-{
-  if ( mAlarms.isEmpty() ) return;
-
-  QDomElement list = element.ownerDocument().createElement( "advanced-alarms" );
-  element.appendChild( list );
-  foreach ( KCalCore::Alarm::Ptr a, mAlarms ) {
-    QDomElement e = list.ownerDocument().createElement( "alarm" );
-    list.appendChild( e );
-
-    writeString( e, "enabled", a->enabled() ? "1" : "0" );
-    if ( a->hasStartOffset() ) {
-      writeString( e, "start-offset", QString::number( a->startOffset().asSeconds()/60 ) );
-    }
-    if ( a->hasEndOffset() ) {
-      writeString( e, "end-offset", QString::number( a->endOffset().asSeconds()/60 ) );
-    }
-    if ( a->repeatCount() ) {
-      writeString( e, "repeat-count", QString::number( a->repeatCount() ) );
-      writeString( e, "repeat-interval", QString::number( a->snoozeTime().asSeconds() ) );
-    }
-
-    switch ( a->type() ) {
-    case KCalCore::Alarm::Invalid:
-      break;
-    case KCalCore::Alarm::Display:
-      e.setAttribute( "type", "display" );
-      writeString( e, "text", a->text() );
-      break;
-    case KCalCore::Alarm::Procedure:
-      e.setAttribute( "type", "procedure" );
-      writeString( e, "program", a->programFile() );
-      writeString( e, "arguments", a->programArguments() );
-      break;
-    case KCalCore::Alarm::Email:
-    {
-      e.setAttribute( "type", "email" );
-      QDomElement addresses = e.ownerDocument().createElement( "addresses" );
-      e.appendChild( addresses );
-      foreach ( const KCalCore::Person::Ptr &person, a->mailAddresses() ) {
-        writeString( addresses, "address", person->fullName() );
-      }
-      writeString( e, "subject", a->mailSubject() );
-      writeString( e, "mail-text", a->mailText() );
-      QDomElement attachments = e.ownerDocument().createElement( "attachments" );
-      e.appendChild( attachments );
-      foreach ( const QString &attachment, a->mailAttachments() ) {
-        writeString( attachments, "attachment", attachment );
-      }
-      break;
-    }
-    case KCalCore::Alarm::Audio:
-      e.setAttribute( "type", "audio" );
-      writeString( e, "file", a->audioFile() );
-      break;
-    default:
-      kWarning() << "Unhandled alarm type:" << a->type();
-      break;
-    }
-  }
-}
-
-void Incidence::saveRecurrence( QDomElement& element ) const
-{
-  QDomElement e = element.ownerDocument().createElement( "recurrence" );
-  element.appendChild( e );
-  e.setAttribute( "cycle", mRecurrence.cycle );
-  if ( !mRecurrence.type.isEmpty() )
-    e.setAttribute( "type", mRecurrence.type );
-  writeString( e, "interval", QString::number( mRecurrence.interval ) );
-  foreach ( const QString& recurrence, mRecurrence.days ) {
-    writeString( e, "day", recurrence );
-  }
-  if ( !mRecurrence.dayNumber.isEmpty() )
-    writeString( e, "daynumber", mRecurrence.dayNumber );
-  if ( !mRecurrence.month.isEmpty() )
-    writeString( e, "month", mRecurrence.month );
-  if ( !mRecurrence.rangeType.isEmpty() ) {
-    QDomElement range = element.ownerDocument().createElement( "range" );
-    e.appendChild( range );
-    range.setAttribute( "type", mRecurrence.rangeType );
-    QDomText t = element.ownerDocument().createTextNode( mRecurrence.range );
-    range.appendChild( t );
-  }
-  foreach ( const QDate& date, mRecurrence.exclusions ) {
-    writeString( e, "exclusion", dateToString( date ) );
-  }
-}
-
-void Incidence::loadRecurrence( const QDomElement& element )
-{
-  mRecurrence.interval = 0;
-  mRecurrence.cycle = element.attribute( "cycle" );
-  mRecurrence.type = element.attribute( "type" );
-  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      QString tagName = e.tagName();
-      if ( tagName == "interval" ) {
-        //kolab/issue4229, sometimes  the interval value can be empty
-        if ( e.text().isEmpty() || e.text().toInt() <= 0 ) {
-          mRecurrence.interval = 1;
-        } else {
-          mRecurrence.interval = e.text().toInt();
-        }
-      }
-      else if ( tagName == "day" ) // can be present multiple times
-        mRecurrence.days.append( e.text() );
-      else if ( tagName == "daynumber" )
-        mRecurrence.dayNumber = e.text();
-      else if ( tagName == "month" )
-        mRecurrence.month = e.text();
-      else if ( tagName == "range" ) {
-        mRecurrence.rangeType = e.attribute( "type" );
-        mRecurrence.range = e.text();
-      } else if ( tagName == "exclusion" ) {
-        mRecurrence.exclusions.append( stringToDate( e.text() ) );
-      } else
-        // TODO: Unhandled tag - save for later storage
-        kDebug() <<"Warning: Unhandled tag" << e.tagName();
-    }
-  }
-}
-
-static void loadAddressesHelper( const QDomElement& element, const KCalCore::Alarm::Ptr &a )
-{
-  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      QString tagName = e.tagName();
-
-      if ( tagName == "address" ) {
-        a->addMailAddress( KCalCore::Person::fromFullName( e.text() ) );
-      } else {
-        kWarning() << "Unhandled tag" << tagName;
-      }
-    }
-  }
-}
-
-static void loadAttachmentsHelper( const QDomElement& element, const KCalCore::Alarm::Ptr &a )
-{
-  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      QString tagName = e.tagName();
-
-      if ( tagName == "attachment" ) {
-        a->addMailAttachment( e.text() );
-      } else {
-        kWarning() << "Unhandled tag" << tagName;
-      }
-    }
-  }
-}
-
-static void loadAlarmHelper( const QDomElement& element, const KCalCore::Alarm::Ptr &a )
-{
-  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      QString tagName = e.tagName();
-
-      if ( tagName == "start-offset" ) {
-        a->setStartOffset( e.text().toInt()*60 );
-      } else if ( tagName == "end-offset" ) {
-        a->setEndOffset( e.text().toInt()*60 );
-      } else if ( tagName == "repeat-count" ) {
-        a->setRepeatCount( e.text().toInt() );
-      } else if ( tagName == "repeat-interval" ) {
-        a->setSnoozeTime( e.text().toInt() );
-      } else if ( tagName == "text" ) {
-        a->setText( e.text() );
-      } else if ( tagName == "program" ) {
-        a->setProgramFile( e.text() );
-      } else if ( tagName == "arguments" ) {
-        a->setProgramArguments( e.text() );
-      } else if ( tagName == "addresses" ) {
-        loadAddressesHelper( e, a );
-      } else if ( tagName == "subject" ) {
-        a->setMailSubject( e.text() );
-      } else if ( tagName == "mail-text" ) {
-        a->setMailText( e.text() );
-      } else if ( tagName == "attachments" ) {
-        loadAttachmentsHelper( e, a );
-      } else if ( tagName == "file" ) {
-        a->setAudioFile( e.text() );
-      } else if ( tagName == "enabled" ) {
-        a->setEnabled( e.text().toInt() != 0 );
-      } else {
-        kWarning() << "Unhandled tag" << tagName;
-      }
-    }
-  }
-}
-
-void Incidence::loadAlarms( const QDomElement& element )
-{
-  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      QString tagName = e.tagName();
-
-      if ( tagName == "alarm" ) {
-        KCalCore::Alarm::Ptr a = KCalCore::Alarm::Ptr( new KCalCore::Alarm( 0 ) );
-        a->setEnabled( true ); // default to enabled, unless some XML attribute says otherwise.
-        QString type = e.attribute( "type" );
-        if ( type == "display" ) {
-          a->setType( KCalCore::Alarm::Display );
-        } else if ( type == "procedure" ) {
-          a->setType( KCalCore::Alarm::Procedure );
-        } else if ( type == "email" ) {
-          a->setType( KCalCore::Alarm::Email );
-        } else if ( type == "audio" ) {
-          a->setType( KCalCore::Alarm::Audio );
-        } else {
-          kWarning() << "Unhandled alarm type:" << type;
-        }
-
-        loadAlarmHelper( e, a );
-        mAlarms << a;
-      } else {
-        kWarning() << "Unhandled tag" << tagName;
-      }
-    }
-  }
-}
-
-bool Incidence::loadAttribute( QDomElement& element )
-{
-  QString tagName = element.tagName();
-
-  if ( tagName == "priority" ) {
-    bool ok;
-    int p = element.text().toInt( &ok );
-    if ( !ok || p < 1 || p > 9 ) {
-      kWarning() << "Invalid \"priority\" value:" << element.text();
-    } else {
-      setPriority( p );
-    }
-  } else if ( tagName == "x-kcal-priority" ) { //for backwards compat
-    bool ok;
-    int p = element.text().toInt( &ok );
-    if ( !ok || p < 0 || p > 9 ) {
-      kWarning() << "Invalid \"x-kcal-priority\" value:" << element.text();
-    } else {
-      if ( priority() == 0 ) {
-        setPriority(p);
-      }
-    }
-  } else if ( tagName == "summary" )
-    setSummary( element.text() );
-  else if ( tagName == "location" )
-    setLocation( element.text() );
-  else if ( tagName == "organizer" ) {
-    Email email;
-    if ( loadEmailAttribute( element, email ) ) {
-      setOrganizer( email );
-      return true;
-    } else
-      return false;
-  } else if ( tagName == "start-date" )
-    setStartDate( element.text() );
-  else if ( tagName == "recurrence" )
-    loadRecurrence( element );
-  else if ( tagName == "attendee" ) {
-    Attendee attendee;
-    if ( loadAttendeeAttribute( element, attendee ) ) {
-      addAttendee( attendee );
-      return true;
-    } else
-      return false;
-  } else if ( tagName == "link-attachment" ) {
-    mAttachments.push_back( KCalCore::Attachment::Ptr( new KCalCore::Attachment( element.text() ) ) );
-  } else if ( tagName == "alarm" )
-    // Alarms should be minutes before. Libkcal uses event time + alarm time
-    setAlarm( - element.text().toInt() );
-  else if ( tagName == "advanced-alarms" )
-    loadAlarms( element );
-  else if ( tagName == "x-kde-internaluid" )
-    setInternalUID( element.text() );
-  else if ( tagName == "x-custom" ) {
-    loadCustomAttributes( element );
-  } else if ( tagName == "inline-attachment"  ) {
-    // we handle that separately later on, so no need to create a KolabUnhandled entry for it
-  } else {
-    bool ok = KolabBase::loadAttribute( element );
-    if ( !ok ) {
-        // Unhandled tag - save for later storage
-        kDebug() <<"Saving unhandled tag" << element.tagName();
-        Custom c;
-        c.key = QByteArray( "X-KDE-KolabUnhandled-" ) + element.tagName().toLatin1();
-        c.value = element.text();
-        mCustomList.append( c );
-    }
-  }
-  // We handled this
-  return true;
-}
-
-bool Incidence::saveAttributes( QDomElement& element ) const
-{
-  // Save the base class elements
-  KolabBase::saveAttributes( element );
-
-  if (priority() != 0) {
-    writeString( element, "priority", QString::number( priority() ) );
-  }
-
-  if ( mFloatingStatus == HasTime )
-    writeString( element, "start-date", dateTimeToString( startDate() ) );
-  else
-    writeString( element, "start-date", dateToString( startDate().date() ) );
-  writeString( element, "summary", summary() );
-  writeString( element, "location", location() );
-  saveEmailAttribute( element, organizer(), "organizer" );
-  if ( !mRecurrence.cycle.isEmpty() )
-    saveRecurrence( element );
-  saveAttendees( element );
-  saveAttachments( element );
-  if ( mHasAlarm ) {
-    // Alarms should be minutes before. Libkcal uses event time + alarm time
-    int alarmTime = qRound( -alarm() );
-    writeString( element, "alarm", QString::number( alarmTime ) );
-  }
-  saveAlarms( element );
-  writeString( element, "x-kde-internaluid", internalUID() );
-  saveCustomAttributes( element );
-  return true;
-}
-
-void Incidence::saveCustomAttributes( QDomElement& element ) const
-{
-  foreach ( const Custom& custom, mCustomList ) {
-    QString key( custom.key );
-    Q_ASSERT( !key.isEmpty() );
-    if ( key.startsWith( QLatin1String( "X-KDE-KolabUnhandled-" ) ) ) {
-      key = key.mid( strlen( "X-KDE-KolabUnhandled-" ) );
-      writeString( element, key, custom.value );
-    } else {
-      // Let's use attributes so that other tag-preserving-code doesn't need sub-elements
-      QDomElement e = element.ownerDocument().createElement( "x-custom" );
-      element.appendChild( e );
-      e.setAttribute( "key", key );
-      e.setAttribute( "value", custom.value );
-    }
-  }
-}
-
-void Incidence::loadCustomAttributes( QDomElement& element )
-{
-  Custom custom;
-  custom.key = element.attribute( "key" ).toLatin1();
-  custom.value = element.attribute( "value" );
-  mCustomList.append( custom );
-}
-
-static KCalCore::Attendee::PartStat attendeeStringToStatus( const QString& s )
-{
-  if ( s == "none" )
-    return KCalCore::Attendee::NeedsAction;
-  if ( s == "tentative" )
-    return KCalCore::Attendee::Tentative;
-  if ( s == "declined" )
-    return KCalCore::Attendee::Declined;
-  if ( s == "delegated" )
-    return KCalCore::Attendee::Delegated;
-
-  // Default:
-  return KCalCore::Attendee::Accepted;
-}
-
-static QString attendeeStatusToString( KCalCore::Attendee::PartStat status )
-{
-  switch( status ) {
-  case KCalCore::Attendee::NeedsAction:
-    return "none";
-  case KCalCore::Attendee::Accepted:
-    return "accepted";
-  case KCalCore::Attendee::Declined:
-    return "declined";
-  case KCalCore::Attendee::Tentative:
-    return "tentative";
-  case KCalCore::Attendee::Delegated:
-    return "delegated";
-  case KCalCore::Attendee::Completed:
-  case KCalCore::Attendee::InProcess:
-    // These don't have any meaning in the Kolab format, so just use:
-    return "accepted";
-  default:
-    // Default for the case that there are more added later:
-    return "accepted";
-  }
-}
-
-static KCalCore::Attendee::Role attendeeStringToRole( const QString& s )
-{
-  if ( s == "optional" )
-    return KCalCore::Attendee::OptParticipant;
-  if ( s == "resource" )
-    return KCalCore::Attendee::NonParticipant;
-  return KCalCore::Attendee::ReqParticipant;
-}
-
-static QString attendeeRoleToString( KCalCore::Attendee::Role role )
-{
-  switch( role ) {
-  case KCalCore::Attendee::ReqParticipant:
-    return "required";
-  case KCalCore::Attendee::OptParticipant:
-    return "optional";
-  case KCalCore::Attendee::Chair:
-    // We don't have the notion of chair, so use
-    return "required";
-  case KCalCore::Attendee::NonParticipant:
-    // In Kolab, a non-participant is a resource
-    return "resource";
-  }
-
-  // Default for the case that there are more added later:
-  return "required";
-}
-
-static const char *s_weekDayName[] =
-{
-  "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"
-};
-
-static const char *s_monthName[] =
-{
-  "january", "february", "march", "april", "may", "june", "july",
-  "august", "september", "october", "november", "december"
-};
-
-void Incidence::setRecurrence( KCalCore::Recurrence* recur )
-{
-  mRecurrence.interval = recur->frequency();
-  switch ( recur->recurrenceType() ) {
-  case KCalCore::Recurrence::rMinutely: // Not handled by the kolab XML
-    mRecurrence.cycle = "minutely";
-    break;
-  case KCalCore::Recurrence::rHourly:  // Not handled by the kolab XML
-    mRecurrence.cycle = "hourly";
-    break;
-  case KCalCore::Recurrence::rDaily:
-    mRecurrence.cycle = "daily";
-    break;
-  case KCalCore::Recurrence::rWeekly: // every X weeks
-    mRecurrence.cycle = "weekly";
-    {
-      QBitArray arr = recur->days();
-      for ( uint idx = 0 ; idx < 7 ; ++idx )
-        if ( arr.testBit( idx ) )
-          mRecurrence.days.append( s_weekDayName[idx] );
-    }
-    break;
-  case KCalCore::Recurrence::rMonthlyPos: {
-    mRecurrence.cycle = "monthly";
-    mRecurrence.type = "weekday";
-    QList<KCalCore::RecurrenceRule::WDayPos> monthPositions = recur->monthPositions();
-    if ( !monthPositions.isEmpty() ) {
-      KCalCore::RecurrenceRule::WDayPos monthPos = monthPositions.first();
-      // TODO: Handle multiple days in the same week
-      mRecurrence.dayNumber = QString::number( monthPos.pos() );
-      mRecurrence.days.append( s_weekDayName[ monthPos.day()-1 ] );
-        // Not (properly) handled(?): monthPos.negative (nth days before end of month)
-    }
-    break;
-  }
-  case KCalCore::Recurrence::rMonthlyDay: {
-    mRecurrence.cycle = "monthly";
-    mRecurrence.type = "daynumber";
-    QList<int> monthDays = recur->monthDays();
-    // ####### Kolab XML limitation: only the first month day is used
-    if ( !monthDays.isEmpty() )
-      mRecurrence.dayNumber = QString::number( monthDays.first() );
-    break;
-  }
-  case KCalCore::Recurrence::rYearlyMonth: // (day n of Month Y)
-  {
-    mRecurrence.cycle = "yearly";
-    mRecurrence.type = "monthday";
-    QList<int> rmd = recur->yearDates();
-    int day = !rmd.isEmpty() ? rmd.first() : recur->startDate().day();
-    mRecurrence.dayNumber = QString::number( day );
-    QList<int> months = recur->yearMonths();
-    if ( !months.isEmpty() )
-      mRecurrence.month = s_monthName[ months.first() - 1 ]; // #### Kolab XML limitation: only one month specified
-    break;
-  }
-  case KCalCore::Recurrence::rYearlyDay: // YearlyDay (day N of the year). Not supported by Outlook
-    mRecurrence.cycle = "yearly";
-    mRecurrence.type = "yearday";
-    mRecurrence.dayNumber = QString::number( recur->yearDays().first() );
-    break;
-  case KCalCore::Recurrence::rYearlyPos: // (weekday X of week N of month Y)
-    mRecurrence.cycle = "yearly";
-    mRecurrence.type = "weekday";
-    QList<int> months = recur->yearMonths();
-    if ( !months.isEmpty() )
-      mRecurrence.month = s_monthName[ months.first() - 1 ]; // #### Kolab XML limitation: only one month specified
-    QList<KCalCore::RecurrenceRule::WDayPos> monthPositions = recur->yearPositions();
-    if ( !monthPositions.isEmpty() ) {
-      KCalCore::RecurrenceRule::WDayPos monthPos = monthPositions.first();
-      // TODO: Handle multiple days in the same week
-      mRecurrence.dayNumber = QString::number( monthPos.pos() );
-      mRecurrence.days.append( s_weekDayName[ monthPos.day()-1 ] );
-
-      //mRecurrence.dayNumber = QString::number( *recur->yearNums().getFirst() );
-      // Not handled: monthPos.negative (nth days before end of month)
-    }
-    break;
-  }
-  int howMany = recur->duration();
-  if ( howMany > 0 ) {
-    mRecurrence.rangeType = "number";
-    mRecurrence.range = QString::number( howMany );
-  } else if ( howMany == 0 ) {
-    mRecurrence.rangeType = "date";
-    mRecurrence.range = dateToString( recur->endDate() );
-  } else {
-    mRecurrence.rangeType = "none";
-  }
-}
-
-void Incidence::setFields( const KCalCore::Incidence::Ptr &incidence )
-{
-  KolabBase::setFields( incidence );
-
-  setPriority( incidence->priority() );
-  if ( incidence->allDay() ) {
-    // This is a all-day event. Don't timezone move this one
-    mFloatingStatus = AllDay;
-    setStartDate( incidence->dtStart().date() );
-  } else {
-    mFloatingStatus = HasTime;
-    setStartDate( localToUTC( incidence->dtStart() ) );
-  }
-
-  setSummary( incidence->summary() );
-  setLocation( incidence->location() );
-
-  // Alarm
-  mHasAlarm = false; // Will be set to true, if we actually have one
-  if ( incidence->hasEnabledAlarms() ) {
-    const KCalCore::Alarm::List& alarms = incidence->alarms();
-    if ( !alarms.isEmpty() ) {
-      const KCalCore::Alarm::Ptr alarm = alarms.first();
-      if ( alarm->hasStartOffset() ) {
-        int dur = alarm->startOffset().asSeconds();
-        setAlarm( (float)dur / 60.0 );
-      }
-    }
-  }
-
-  if (incidence->organizer()) {
-    Email org( incidence->organizer()->name(), incidence->organizer()->email() );
-    setOrganizer( org );
-  }
-
-  // Attendees:
-  KCalCore::Attendee::List attendees = incidence->attendees();
-  foreach ( KCalCore::Attendee::Ptr kcalAttendee, attendees ) {
-    Attendee attendee;
-
-    attendee.displayName = kcalAttendee->name();
-    attendee.smtpAddress = kcalAttendee->email();
-    attendee.status = attendeeStatusToString( kcalAttendee->status() );
-    attendee.requestResponse = kcalAttendee->RSVP();
-    // TODO: KCalCore::Attendee::mFlag is not accessible
-    // attendee.invitationSent = kcalAttendee->mFlag;
-    // DF: Hmm? mFlag is set to true and never used at all.... Did you mean another field?
-    attendee.role = attendeeRoleToString( kcalAttendee->role() );
-    attendee.delegate = kcalAttendee->delegate();
-    attendee.delegator = kcalAttendee->delegator();
-
-    addAttendee( attendee );
-  }
-
-  mAttachments.clear();
-
-  // Attachments
-  KCalCore::Attachment::List attachments = incidence->attachments();
-  foreach ( KCalCore::Attachment::Ptr a, attachments ) {
-    mAttachments.push_back( a );
-  }
-
-  mAlarms.clear();
-
-  // Alarms
-  KCalCore::Alarm::List alarms = incidence->alarms();
-  foreach ( KCalCore::Alarm::Ptr a, alarms ) {
-    mAlarms.push_back( a );
-  }
-
-  if ( incidence->recurs() ) {
-    setRecurrence( incidence->recurrence() );
-    mRecurrence.exclusions = incidence->recurrence()->exDates();
-  }
-
-  // Handle the scheduling ID
-  if ( incidence->schedulingID() == incidence->uid() ) {
-    // There is no scheduling ID
-    setInternalUID( QString::null );	//krazy:exclude=nullstrassign for old broken gcc
-  } else {
-    // We've internally been using a different uid, so save that as the
-    // temporary (internal) uid and restore the original uid, the one that
-    // is used in the folder and the outside world
-    setUid( incidence->schedulingID() );
-    setInternalUID( incidence->uid() );
-  }
-
-  // Unhandled tags and other custom properties (see libkcal/customproperties.h)
-  const QMap<QByteArray, QString> map = incidence->customProperties();
-  QMap<QByteArray, QString>::ConstIterator cit = map.begin();
-  for ( ; cit != map.end() ; ++cit ) {
-    Custom c;
-    c.key = cit.key();
-    c.value = cit.value();
-    mCustomList.append( c );
-  }
-}
-
-static QBitArray daysListToBitArray( const QStringList& days )
-{
-  QBitArray arr( 7 );
-  arr.fill( false );
-  foreach ( const QString& day, days ) {
-    for ( uint i = 0; i < 7 ; ++i )
-      if ( day == s_weekDayName[i] )
-        arr.setBit( i, true );
-  }
-  return arr;
-}
-
-
-void Incidence::saveTo( const KCalCore::Incidence::Ptr &incidence )
-{
-  KolabBase::saveTo( incidence );
-
-  incidence->setPriority( priority() );
-  if ( mFloatingStatus == AllDay ) {
-    // This is an all-day event. Don't timezone move this one
-    incidence->setDtStart( startDate() );
-    incidence->setAllDay( true );
-  } else {
-    incidence->setDtStart( utcToLocal( startDate() ) );
-    incidence->setAllDay( false );
-  }
-
-  incidence->setSummary( summary() );
-  incidence->setLocation( location() );
-
-  if ( mHasAlarm && mAlarms.isEmpty() ) {
-    KCalCore::Alarm::Ptr alarm = incidence->newAlarm();
-    alarm->setStartOffset( qRound( mAlarm * 60.0 ) );
-    alarm->setEnabled( true );
-    alarm->setType( KCalCore::Alarm::Display );
-  } else if ( !mAlarms.isEmpty() ) {
-    foreach ( KCalCore::Alarm::Ptr a, mAlarms ) {
-      a->setParent( incidence.data() );
-      incidence->addAlarm( a );
-    }
-  }
-
-  if ( organizer().displayName.isEmpty() )
-    incidence->setOrganizer( organizer().smtpAddress );
-  else
-    incidence->setOrganizer( organizer().displayName + '<'
-                             + organizer().smtpAddress + '>' );
-
-  incidence->clearAttendees();
-  foreach ( const Attendee& attendee, mAttendees ) {
-    KCalCore::Attendee::PartStat status = attendeeStringToStatus( attendee.status );
-    KCalCore::Attendee::Role role = attendeeStringToRole( attendee.role );
-    KCalCore::Attendee::Ptr a( new KCalCore::Attendee( attendee.displayName,
-                                            attendee.smtpAddress,
-                                            attendee.requestResponse,
-                                            status, role ) );
-    a->setDelegate( attendee.delegate );
-    a->setDelegator( attendee.delegator );
-    incidence->addAttendee( a );
-  }
-
-  incidence->clearAttachments();
-  foreach ( KCalCore::Attachment::Ptr a, mAttachments ) {
-    // TODO should we copy?
-    incidence->addAttachment( a );
-  }
-
-  if ( !mRecurrence.cycle.isEmpty() ) {
-    KCalCore::Recurrence* recur = incidence->recurrence(); // yeah, this creates it
-    // done below recur->setFrequency( mRecurrence.interval );
-    if ( mRecurrence.cycle == "minutely" ) {
-      recur->setMinutely( mRecurrence.interval );
-    } else if ( mRecurrence.cycle == "hourly" ) {
-      recur->setHourly( mRecurrence.interval );
-    } else if ( mRecurrence.cycle == "daily" ) {
-      recur->setDaily( mRecurrence.interval );
-    } else if ( mRecurrence.cycle == "weekly" ) {
-      QBitArray rDays = daysListToBitArray( mRecurrence.days );
-      recur->setWeekly( mRecurrence.interval, rDays );
-    } else if ( mRecurrence.cycle == "monthly" ) {
-      recur->setMonthly( mRecurrence.interval );
-      if ( mRecurrence.type == "weekday" ) {
-        recur->addMonthlyPos( mRecurrence.dayNumber.toInt(), daysListToBitArray( mRecurrence.days ) );
-      } else if ( mRecurrence.type == "daynumber" ) {
-        recur->addMonthlyDate( mRecurrence.dayNumber.toInt() );
-      } else kWarning() <<"Unhandled monthly recurrence type" << mRecurrence.type;
-    } else if ( mRecurrence.cycle == "yearly" ) {
-      recur->setYearly( mRecurrence.interval );
-      if ( mRecurrence.type == "monthday" ) {
-        recur->addYearlyDate( mRecurrence.dayNumber.toInt() );
-				for ( int i = 0; i < 12; ++i )
-          if ( s_monthName[ i ] == mRecurrence.month )
-            recur->addYearlyMonth( i+1 );
-      } else if ( mRecurrence.type == "yearday" ) {
-        recur->addYearlyDay( mRecurrence.dayNumber.toInt() );
-      } else if ( mRecurrence.type == "weekday" ) {
-			  for ( int i = 0; i < 12; ++i )
-          if ( s_monthName[ i ] == mRecurrence.month )
-            recur->addYearlyMonth( i+1 );
-        recur->addYearlyPos( mRecurrence.dayNumber.toInt(), daysListToBitArray( mRecurrence.days ) );
-      } else kWarning() <<"Unhandled yearly recurrence type" << mRecurrence.type;
-    } else kWarning() <<"Unhandled recurrence cycle" << mRecurrence.cycle;
-
-    if ( mRecurrence.rangeType == "number" ) {
-      recur->setDuration( mRecurrence.range.toInt() );
-    } else if ( mRecurrence.rangeType == "date" ) {
-      recur->setEndDate( stringToDate( mRecurrence.range ) );
-    } // "none" is default since tje set*ly methods set infinite recurrence
-
-    incidence->recurrence()->setExDates( mRecurrence.exclusions );
-
-  }
-  /* If we've stored a uid to be used internally instead of the real one
-   * (to deal with duplicates of events in different folders) before, then
-   * restore it, so it does not change. Keep the original uid around for
-   * scheduling purposes. */
-  if ( !internalUID().isEmpty() ) {
-    incidence->setUid( internalUID() );
-    incidence->setSchedulingID( uid() );
-  }
-
-  foreach ( const Custom& custom, mCustomList ) {
-    incidence->setNonKDECustomProperty( custom.key, custom.value );
-  }
-
-}
-
-QString Incidence::productID() const
-{
-  return QString( "%1, Kolab resource" ).arg( LIBKOLAB_LIB_VERSION_STRING );
-}
-
-// Unhandled KCalCore::Incidence fields:
-// revision, status (unused), attendee.uid,
-// mComments, mReadOnly
-
diff --git a/kolabformatV2/incidence.h b/kolabformatV2/incidence.h
deleted file mode 100644
index b918bd0..0000000
--- a/kolabformatV2/incidence.h
+++ /dev/null
@@ -1,172 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#ifndef KOLABV2_INCIDENCE_H
-#define KOLABV2_INCIDENCE_H
-
-#include <kcalcore/incidence.h>
-
-#include "kolabbase.h"
-
-class QDomElement;
-
-namespace KolabV2 {
-
-/**
- * This abstract class represents an incidence which has the shared
- * fields, of events and tasks and knows how to load/save these
- * from/to XML, and from/to a KCalCore::Incidence.
- */
-class Incidence : public KolabBase {
-public:
-  struct Recurrence {
-    QString cycle;
-    QString type;
-    int interval;
-    QStringList days; // list of days-of-the-week
-    QString dayNumber;
-    QString month;
-    QString rangeType;
-    QString range; // date or number or nothing
-    QList<QDate> exclusions;
-  };
-
-  struct Attendee : Email {
-    Attendee() : requestResponse( true ), invitationSent( false ) {}
-    QString status;
-    bool requestResponse;
-    bool invitationSent;
-    QString role;
-    QString delegate;
-    QString delegator;
-  };
-
-  explicit Incidence( const QString& tz, const KCalCore::Incidence::Ptr &incidence = KCalCore::Incidence::Ptr() );
-
-public:
-  virtual ~Incidence();
-
-  void saveTo( const KCalCore::Incidence::Ptr &incidence );
-
-  virtual void setPriority( int priority );
-  virtual int priority() const;
-
-  virtual void setSummary( const QString& summary );
-  virtual QString summary() const;
-
-  virtual void setLocation( const QString& location );
-  virtual QString location() const;
-
-  virtual void setOrganizer( const Email& organizer );
-  virtual Email organizer() const;
-
-  virtual void setStartDate( const KDateTime& startDate );
-  virtual void setStartDate( const QDate& startDate );
-  virtual void setStartDate( const QString& startDate );
-  virtual KDateTime startDate() const;
-
-  virtual void setAlarm( float alarm );
-  virtual float alarm() const;
-
-  virtual void setRecurrence( KCalCore::Recurrence* recur );
-  virtual Recurrence recurrence() const;
-
-  virtual void addAttendee( const Attendee& attendee );
-  QList<Attendee>& attendees();
-  const QList<Attendee>& attendees() const;
-
-   virtual QString type() const { return "Incidence"; }
- /**
-   * The internal uid is used as the uid inside KOrganizer whenever
-   * two or more events with the same uid appear, which KOrganizer
-   * can't handle. To avoid keep that interal uid from changing all the
-   * time, it is persisted in the XML between a save and the next load.
-   */
-  void setInternalUID( const QString& iuid );
-  QString internalUID() const;
-
-  // Load the attributes of this class
-  virtual bool loadAttribute( QDomElement& );
-
-  // Save the attributes of this class
-  virtual bool saveAttributes( QDomElement& ) const;
-
-protected:
-  enum FloatingStatus { Unset, AllDay, HasTime };
-
-  // Read all known fields from this ical incidence
-  void setFields( const KCalCore::Incidence::Ptr & );
-
-  bool loadAttendeeAttribute( QDomElement&, Attendee& );
-  void saveAttendeeAttribute( QDomElement& element,
-                              const Attendee& attendee ) const;
-  void saveAttendees( QDomElement& element ) const;
-  void saveAttachments( QDomElement& element ) const;
-
-  void loadAlarms( const QDomElement& element );
-  void saveAlarms( QDomElement& element ) const;
-
-  void loadRecurrence( const QDomElement& element );
-  void saveRecurrence( QDomElement& element ) const;
-  void saveCustomAttributes( QDomElement& element ) const;
-  void loadCustomAttributes( QDomElement& element );
-
-  QString productID() const;
-
-  QString mSummary;
-  QString mLocation;
-  Email mOrganizer;
-  KDateTime mStartDate;
-  FloatingStatus mFloatingStatus;
-  float mAlarm;
-  bool mHasAlarm;
-  Recurrence mRecurrence;
-  QList<Attendee> mAttendees;
-  QList<KCalCore::Alarm::Ptr> mAlarms;
-  QList<KCalCore::Attachment::Ptr> mAttachments;
-  QString mInternalUID;
-
-  struct Custom {
-    QByteArray key;
-    QString value;
-  };
-  QList<Custom> mCustomList;
-
-  // This is the KCal priority, not the Kolab priority.
-  // See kcalPriorityToKolab() and kolabPrioritytoKCal().
-  int mPriority;
-};
-
-}
-
-#endif // KOLAB_INCIDENCE_H
diff --git a/kolabformatV2/journal.cpp b/kolabformatV2/journal.cpp
deleted file mode 100644
index 7568c1f..0000000
--- a/kolabformatV2/journal.cpp
+++ /dev/null
@@ -1,184 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#include "journal.h"
-#include "libkolab-version.h"
-
-#include <kdebug.h>
-
-using namespace KolabV2;
-
-
-KCalCore::Journal::Ptr Journal::fromXml( const QDomDocument& xmlDoc, const QString& tz )
-{
-  Journal journal( tz );
-  journal.loadXML( xmlDoc );
-  KCalCore::Journal::Ptr kcalJournal( new KCalCore::Journal() );
-  journal.saveTo( kcalJournal );
-  return kcalJournal;
-}
-
-QString Journal::journalToXML( const KCalCore::Journal::Ptr &kcalJournal, const QString& tz )
-{
-  Journal journal( tz, kcalJournal );
-  return journal.saveXML();
-}
-
-Journal::Journal( const QString& tz, const KCalCore::Journal::Ptr &journal )
-  : KolabBase( tz )
-{
-  if ( journal ) {
-    setFields( journal );
-  }
-}
-
-Journal::~Journal()
-{
-}
-
-void Journal::setSummary( const QString& summary )
-{
-  mSummary = summary;
-}
-
-QString Journal::summary() const
-{
-  return mSummary;
-}
-
-void Journal::setStartDate( const KDateTime& startDate )
-{
-  mStartDate = startDate;
-}
-
-KDateTime Journal::startDate() const
-{
-  return mStartDate;
-}
-
-void Journal::setEndDate( const KDateTime& endDate )
-{
-  mEndDate = endDate;
-}
-
-KDateTime Journal::endDate() const
-{
-  return mEndDate;
-}
-
-bool Journal::loadAttribute( QDomElement& element )
-{
-  QString tagName = element.tagName();
-
-  if ( tagName == "summary" )
-    setSummary( element.text() );
-  else if ( tagName == "start-date" )
-    setStartDate( stringToDateTime( element.text() ) );
-  else
-    // Not handled here
-    return KolabBase::loadAttribute( element );
-
-  // We handled this
-  return true;
-}
-
-bool Journal::saveAttributes( QDomElement& element ) const
-{
-  // Save the base class elements
-  KolabBase::saveAttributes( element );
-
-  writeString( element, "summary", summary() );
-  writeString( element, "start-date", dateTimeToString( startDate() ) );
-
-  return true;
-}
-
-
-bool Journal::loadXML( const QDomDocument& document )
-{
-  QDomElement top = document.documentElement();
-
-  if ( top.tagName() != "journal" ) {
-    qWarning( "XML error: Top tag was %s instead of the expected Journal",
-              top.tagName().toAscii().data() );
-    return false;
-  }
-
-  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      if ( !loadAttribute( e ) ) {
-        // Unhandled tag - save for later storage
-        //qDebug( "Unhandled tag: %s", e.toCString().data() );
-      }
-    } else
-      qDebug( "Node is not a comment or an element???" );
-  }
-
-  return true;
-}
-
-QString Journal::saveXML() const
-{
-  QDomDocument document = domTree();
-  QDomElement element = document.createElement( "journal" );
-  element.setAttribute( "version", "1.0" );
-  saveAttributes( element );
-  document.appendChild( element );
-  return document.toString();
-}
-
-void Journal::saveTo( const KCalCore::Journal::Ptr &journal )
-{
-  KolabBase::saveTo( journal );
-
-  journal->setSummary( summary() );
-  journal->setDtStart( utcToLocal( startDate() ) );
-}
-
-void Journal::setFields( const KCalCore::Journal::Ptr &journal )
-{
-  // Set baseclass fields
-  KolabBase::setFields( journal );
-
-  // Set our own fields
-  setSummary( journal->summary() );
-  setStartDate( localToUTC( journal->dtStart() ) );
-}
-
-QString Journal::productID() const
-{
-  return QString::fromLatin1(LIBKOLAB_LIB_VERSION_STRING) + ", Kolab resource";
-}
diff --git a/kolabformatV2/journal.h b/kolabformatV2/journal.h
deleted file mode 100644
index 670c67a..0000000
--- a/kolabformatV2/journal.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#ifndef KOLABV2_JOURNAL_H
-#define KOLABV2_JOURNAL_H
-
-#include <kcalcore/journal.h>
-
-#include "kolabbase.h"
-
-class QDomElement;
-
-namespace KolabV2 {
-
-/**
- * This class represents a journal entry, and knows how to load/save it
- * from/to XML, and from/to a KCalCore::Journal.
- * The instances of this class are temporary, only used to convert
- * one to the other.
- */
-class Journal : public KolabBase {
-public:
-  /// Use this to parse an xml string to a journal entry
-  /// The caller is responsible for deleting the returned journal
-  static KCalCore::Journal::Ptr fromXml( const QDomDocument& xmlDoc, const QString& tz );
-
-  /// Use this to get an xml string describing this journal entry
-  static QString journalToXML( const KCalCore::Journal::Ptr &, const QString& tz );
-
-  explicit Journal( const QString& tz, const KCalCore::Journal::Ptr &journal = KCalCore::Journal::Ptr() );
-  virtual ~Journal();
-
-  virtual QString type() const { return "Journal"; }
-
-  void saveTo( const KCalCore::Journal::Ptr &journal );
-
-  virtual void setSummary( const QString& summary );
-  virtual QString summary() const;
-
-  virtual void setStartDate( const KDateTime& startDate );
-  virtual KDateTime startDate() const;
-
-  virtual void setEndDate( const KDateTime& endDate );
-  virtual KDateTime endDate() const;
-
-  // Load the attributes of this class
-  virtual bool loadAttribute( QDomElement& );
-
-  // Save the attributes of this class
-  virtual bool saveAttributes( QDomElement& ) const;
-
-  // Load this journal by reading the XML file
-  virtual bool loadXML( const QDomDocument& xml );
-
-  // Serialize this journal to an XML string
-  virtual QString saveXML() const;
-
-protected:
-  // Read all known fields from this ical journal
-  void setFields( const KCalCore::Journal::Ptr & );
-
-  QString productID() const;
-
-  QString mSummary;
-  KDateTime mStartDate;
-  KDateTime mEndDate;
-};
-
-}
-
-#endif // KOLAB_JOURNAL_H
diff --git a/kolabformatV2/kolabbase.cpp b/kolabformatV2/kolabbase.cpp
deleted file mode 100644
index a51d254..0000000
--- a/kolabformatV2/kolabbase.cpp
+++ /dev/null
@@ -1,500 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#include "kolabbase.h"
-
-#include <kabc/addressee.h>
-#include <kabc/contactgroup.h>
-#include <kcalcore/incidence.h>
-#include <kcalcore/journal.h>
-#include <ksystemtimezone.h>
-#include <kdebug.h>
-
-using namespace KolabV2;
-
-KolabBase::KolabBase( const QString& tz )
-  : mCreationDate( QDateTime::currentDateTime() ),
-    mLastModified( KDateTime::currentUtcDateTime() ),
-    mSensitivity( Public ),
-    mTimeZone( KSystemTimeZones::zone( tz ) ),
-    mHasPilotSyncId( false ),  mHasPilotSyncStatus( false )
-{
-}
-
-KolabBase::~KolabBase()
-{
-}
-
-void KolabBase::setFields( const KCalCore::Incidence::Ptr &incidence )
-{
-  // So far unhandled KCalCore::IncidenceBase fields:
-  // mPilotID, mSyncStatus, mFloats
-
-  setUid( incidence->uid() );
-  setBody( incidence->description() );
-  setCategories( incidence->categoriesStr() );
-  setCreationDate( localToUTC( incidence->created() ) );
-  setLastModified( incidence->lastModified() );
-  setSensitivity( static_cast<Sensitivity>( incidence->secrecy() ) );
-  // TODO: Attachments
-}
-
-void KolabBase::saveTo( const KCalCore::Incidence::Ptr &incidence ) const
-{
-  incidence->setUid( uid() );
-  incidence->setDescription( body() );
-  incidence->setCategories( categories() );
-  incidence->setCreated( utcToLocal( creationDate() ) );
-  incidence->setLastModified( lastModified() );
-  switch( sensitivity() ) {
-  case 1:
-    incidence->setSecrecy( KCalCore::Incidence::SecrecyPrivate );
-    break;
-  case 2:
-    incidence->setSecrecy( KCalCore::Incidence::SecrecyConfidential );
-    break;
-  default:
-    incidence->setSecrecy( KCalCore::Incidence::SecrecyPublic );
-    break;
-  }
-
-  // TODO: Attachments
-}
-
-void KolabBase::setFields( const KABC::Addressee* addressee )
-{
-  // An addressee does not have a creation date, so somehow we should
-  // make one, if this is a new entry
-
-  setUid( addressee->uid() );
-  setBody( addressee->note() );
-  setCategories( addressee->categories().join( "," ) );
-
-  // Set creation-time and last-modification-time
-  const QString creationString = addressee->custom( "KOLAB", "CreationDate" );
-  kDebug() <<"Creation time string:" << creationString;
-  KDateTime creationDate;
-  if ( creationString.isEmpty() ) {
-    creationDate = KDateTime::currentDateTime(KDateTime::Spec( mTimeZone ) );
-    kDebug() <<"Creation date set to current time";
-  }
-  else {
-    creationDate = stringToDateTime( creationString );
-    kDebug() <<"Creation date loaded";
-  }
-  KDateTime modified = KDateTime( addressee->revision(), mTimeZone );
-  if ( !modified.isValid() )
-    modified = KDateTime::currentUtcDateTime();
-  setLastModified( modified );
-  if ( modified < creationDate ) {
-    // It's not possible that the modification date is earlier than creation
-    creationDate = modified;
-    kDebug() <<"Creation date set to modification date";
-  }
-  setCreationDate( creationDate );
-  const QString newCreationDate = dateTimeToString( creationDate );
-  if ( creationString != newCreationDate ) {
-    // We modified the creation date, so store it for future reference
-    const_cast<KABC::Addressee*>( addressee )
-      ->insertCustom( "KOLAB", "CreationDate", newCreationDate );
-    kDebug() <<"Creation date modified. New one:" << newCreationDate;
-  }
-
-  switch( addressee->secrecy().type() ) {
-  case KABC::Secrecy::Private:
-    setSensitivity( Private );
-    break;
-  case KABC::Secrecy::Confidential:
-    setSensitivity( Confidential );
-    break;
-  default:
-    setSensitivity( Public );
-  }
-
-  // TODO: Attachments
-}
-
-void KolabBase::saveTo( KABC::Addressee* addressee ) const
-{
-  addressee->setUid( uid() );
-  addressee->setNote( body() );
-  addressee->setCategories( categories().split( ',', QString::SkipEmptyParts ) );
-  addressee->setRevision( lastModified().toZone( mTimeZone ).dateTime() );
-  addressee->insertCustom( "KOLAB", "CreationDate",
-                           dateTimeToString( creationDate() ) );
-
-  switch( sensitivity() ) {
-  case Private:
-    addressee->setSecrecy( KABC::Secrecy( KABC::Secrecy::Private ) );
-    break;
-  case Confidential:
-    addressee->setSecrecy( KABC::Secrecy( KABC::Secrecy::Confidential ) );
-    break;
-  default:
-    addressee->setSecrecy( KABC::Secrecy( KABC::Secrecy::Public ) );
-    break;
-  }
-  // TODO: Attachments
-}
-
-void KolabBase::setFields( const KABC::ContactGroup* contactGroup )
-{
-  // A contactgroup does not have a creation date, so somehow we should
-  // make one, if this is a new entry
-
-  setUid( contactGroup->id() );
-
-  // Set creation-time and last-modification-time
-  KDateTime creationDate = KDateTime::currentDateTime( KDateTime::Spec( mTimeZone ) );
-  kDebug() <<"Creation date set to current time";
-
-  KDateTime modified = KDateTime::currentUtcDateTime();
-  setLastModified( modified );
-  if ( modified < creationDate ) {
-    // It's not possible that the modification date is earlier than creation
-    creationDate = modified;
-    kDebug() <<"Creation date set to modification date";
-  }
-  setCreationDate( creationDate );
-}
-
-void KolabBase::saveTo( KABC::ContactGroup* contactGroup ) const
-{
-  contactGroup->setId( uid() );
-}
-
-void KolabBase::setUid( const QString& uid )
-{
-  mUid = uid;
-}
-
-QString KolabBase::uid() const
-{
-  return mUid;
-}
-
-void KolabBase::setBody( const QString& body )
-{
-  mBody = body;
-}
-
-QString KolabBase::body() const
-{
-  return mBody;
-}
-
-void KolabBase::setCategories( const QString& categories )
-{
-  mCategories = categories;
-}
-
-QString KolabBase::categories() const
-{
-  return mCategories;
-}
-
-void KolabBase::setCreationDate( const KDateTime& date )
-{
-  mCreationDate = date;
-}
-
-KDateTime KolabBase::creationDate() const
-{
-  return mCreationDate;
-}
-
-void KolabBase::setLastModified( const KDateTime& date )
-{
-  mLastModified = date;
-}
-
-KDateTime KolabBase::lastModified() const
-{
-  return mLastModified;
-}
-
-void KolabBase::setSensitivity( Sensitivity sensitivity )
-{
-  mSensitivity = sensitivity;
-}
-
-KolabBase::Sensitivity KolabBase::sensitivity() const
-{
-  return mSensitivity;
-}
-
-void KolabBase::setPilotSyncId( unsigned long id )
-{
-  mHasPilotSyncId = true;
-  mPilotSyncId = id;
-}
-
-bool KolabBase::hasPilotSyncId() const
-{
-  return mHasPilotSyncId;
-}
-
-unsigned long KolabBase::pilotSyncId() const
-{
-  return mPilotSyncId;
-}
-
-void KolabBase::setPilotSyncStatus( int status )
-{
-  mHasPilotSyncStatus = true;
-  mPilotSyncStatus = status;
-}
-
-bool KolabBase::hasPilotSyncStatus() const
-{
-  return mHasPilotSyncStatus;
-}
-
-int KolabBase::pilotSyncStatus() const
-{
-  return mPilotSyncStatus;
-}
-
-bool KolabBase::loadEmailAttribute( QDomElement& element, Email& email )
-{
-  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      const QString tagName = e.tagName();
-
-      if ( tagName == "display-name" )
-        email.displayName = e.text();
-      else if ( tagName == "smtp-address" )
-        email.smtpAddress = e.text();
-      else
-        // TODO: Unhandled tag - save for later storage
-        kDebug() <<"Warning: Unhandled tag" << e.tagName();
-    } else
-      kDebug() <<"Node is not a comment or an element???";
-  }
-
-  return true;
-}
-
-void KolabBase::saveEmailAttribute( QDomElement& element, const Email& email,
-                                    const QString& tagName ) const
-{
-  QDomElement e = element.ownerDocument().createElement( tagName );
-  element.appendChild( e );
-  writeString( e, "display-name", email.displayName );
-  writeString( e, "smtp-address", email.smtpAddress );
-}
-
-bool KolabBase::loadAttribute( QDomElement& element )
-{
-  const QString tagName = element.tagName();
-  switch ( tagName[0].toLatin1() ) {
-  case 'u':
-    if ( tagName == "uid" ) {
-      setUid( element.text() );
-      return true;
-    }
-    break;
-  case 'b':
-    if ( tagName == "body" ) {
-      setBody( element.text() );
-      return true;
-    }
-    break;
-  case 'c':
-    if ( tagName == "categories" ) {
-      setCategories( element.text() );
-      return true;
-    }
-    if ( tagName == "creation-date" ) {
-      setCreationDate( stringToDateTime( element.text() ) );
-      return true;
-    }
-    break;
-  case 'l':
-    if ( tagName == "last-modification-date" ) {
-      setLastModified( stringToDateTime( element.text() ) );
-      return true;
-    }
-    break;
-  case 's':
-    if ( tagName == "sensitivity" ) {
-      setSensitivity( stringToSensitivity( element.text() ) );
-      return true;
-    }
-    break;
-  case 'p':
-    if ( tagName == "product-id" )
-      return true; // ignore this field
-    if ( tagName == "pilot-sync-id" ) {
-      setPilotSyncId( element.text().toULong() );
-      return true;
-    }
-    if ( tagName == "pilot-sync-status" ) {
-      setPilotSyncStatus( element.text().toInt() );
-      return true;
-    }
-    break;
-  default:
-    break;
-  }
-  return false;
-}
-
-bool KolabBase::saveAttributes( QDomElement& element ) const
-{
-  writeString( element, "product-id", productID() );
-  writeString( element, "uid", uid() );
-  writeString( element, "body", body() );
-  writeString( element, "categories", categories() );
-  writeString( element, "creation-date", dateTimeToString( creationDate().toUtc() ) );
-  writeString( element, "last-modification-date", dateTimeToString( lastModified().toUtc() ) );
-  writeString( element, "sensitivity", sensitivityToString( sensitivity() ) );
-  if ( hasPilotSyncId() )
-    writeString( element, "pilot-sync-id", QString::number( pilotSyncId() ) );
-  if ( hasPilotSyncStatus() )
-    writeString( element, "pilot-sync-status", QString::number( pilotSyncStatus() ) );
-  return true;
-}
-
-bool KolabBase::load( const QString& xml )
-{
-  const QDomDocument document = loadDocument( xml );
-  if ( document.isNull() )
-    return false;
-  // XML file loaded into tree. Now parse it
-  return loadXML( document );
-}
-
-QDomDocument KolabBase::loadDocument( const QString& xmlData )
-{
-  QString errorMsg;
-  int errorLine, errorColumn;
-  QDomDocument document;
-  bool ok = document.setContent( xmlData, &errorMsg, &errorLine, &errorColumn );
-
-  if ( !ok ) {
-    qWarning( "Error loading document: %s, line %d, column %d", qPrintable( errorMsg ), errorLine, errorColumn );
-    return QDomDocument();
-  }
-
-  return document;
-}
-
-QDomDocument KolabBase::domTree()
-{
-  QDomDocument document;
-
-  QString p = "version=\"1.0\" encoding=\"UTF-8\"";
-  document.appendChild(document.createProcessingInstruction( "xml", p ) );
-
-  return document;
-}
-
-
-QString KolabBase::dateTimeToString( const KDateTime& time )
-{
-  return time.toString( KDateTime::ISODate );
-}
-
-QString KolabBase::dateToString( const QDate& date )
-{
-  return date.toString( Qt::ISODate );
-}
-
-KDateTime KolabBase::stringToDateTime( const QString& _date )
-{
-  const QString date( _date );
-  return KDateTime::fromString( date, KDateTime::ISODate );
-}
-
-QDate KolabBase::stringToDate( const QString& date )
-{
-  return QDate::fromString( date, Qt::ISODate );
-}
-
-QString KolabBase::sensitivityToString( Sensitivity s )
-{
-  switch( s ) {
-  case Private: return "private";
-  case Confidential: return "confidential";
-  case Public: return "public";
-  }
-
-  return "What what what???";
-}
-
-KolabBase::Sensitivity KolabBase::stringToSensitivity( const QString& s )
-{
-  if ( s == "private" )
-    return Private;
-  if ( s == "confidential" )
-    return Confidential;
-  return Public;
-}
-
-QString KolabBase::colorToString( const QColor& color )
-{
-  // Color is in the format "#RRGGBB"
-  return color.name();
-}
-
-QColor KolabBase::stringToColor( const QString& s )
-{
-  return QColor( s );
-}
-
-void KolabBase::writeString( QDomElement& element, const QString& tag,
-                             const QString& tagString )
-{
-  if ( !tagString.isEmpty() ) {
-    QDomElement e = element.ownerDocument().createElement( tag );
-    QDomText t = element.ownerDocument().createTextNode( tagString );
-    e.appendChild( t );
-    element.appendChild( e );
-  }
-}
-
-KDateTime KolabBase::localToUTC( const KDateTime& time ) const
-{
-  return time.toUtc();
-}
-
-KDateTime KolabBase::utcToLocal( const KDateTime& time ) const
-{
-  KDateTime dt = time;
-  dt.setTimeSpec( KDateTime::UTC );
-  return dt;
-}
diff --git a/kolabformatV2/kolabbase.h b/kolabformatV2/kolabbase.h
deleted file mode 100644
index 5bdfdec..0000000
--- a/kolabformatV2/kolabbase.h
+++ /dev/null
@@ -1,183 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#ifndef KOLABV2BASE_H
-#define KOLABV2BASE_H
-
-
-#include <kcalcore/incidence.h>
-
-#include <kdatetime.h>
-#include <ktimezone.h>
-
-#include <QColor>
-#include <qdom.h>
-
-namespace KABC {
-  class Addressee;
-  class ContactGroup;
-}
-
-namespace KolabV2 {
-
-class KolabBase {
-public:
-  struct Email {
-  public:
-    Email( const QString& name = QString(),
-           const QString& email = QString() )
-      : displayName( name ), smtpAddress( email )
-    {
-    }
-
-    QString displayName;
-    QString smtpAddress;
-  };
-
-  enum Sensitivity { Public = 0, Private = 1, Confidential = 2 };
-
-  explicit KolabBase( const QString& time_zone = QString() );
-  virtual ~KolabBase();
-
-  // Return a string identifying this type
-  virtual QString type() const = 0;
-
-  virtual void setUid( const QString& uid );
-  virtual QString uid() const;
-
-  virtual void setBody( const QString& body );
-  virtual QString body() const;
-
-  virtual void setCategories( const QString& categories );
-  virtual QString categories() const;
-
-  virtual void setCreationDate( const KDateTime& date );
-  virtual KDateTime creationDate() const;
-
-  virtual void setLastModified( const KDateTime& date );
-  virtual KDateTime lastModified() const;
-
-  virtual void setSensitivity( Sensitivity sensitivity );
-  virtual Sensitivity sensitivity() const;
-
-  virtual void setPilotSyncId( unsigned long id );
-  virtual bool hasPilotSyncId() const;
-  virtual unsigned long pilotSyncId() const;
-
-  virtual void setPilotSyncStatus( int status );
-  virtual bool hasPilotSyncStatus() const;
-  virtual int pilotSyncStatus() const;
-
-  // String - Date conversion methods
-  static QString dateTimeToString( const KDateTime& time );
-  static QString dateToString( const QDate& date );
-  static KDateTime stringToDateTime( const QString& time );
-  static QDate stringToDate( const QString& date );
-
-  // String - Sensitivity conversion methods
-  static QString sensitivityToString( Sensitivity );
-  static Sensitivity stringToSensitivity( const QString& );
-
-  // String - Color conversion methods
-  static QString colorToString( const QColor& );
-  static QColor stringToColor( const QString& );
-
-  // Load this object by reading the XML file
-  bool load( const QString& xml );
-  static QDomDocument loadDocument( const QString& xmlData );
-
-  // Load this QDomDocument
-  virtual bool loadXML( const QDomDocument& xml ) = 0;
-
-  // Serialize this object to an XML string
-  virtual QString saveXML() const = 0;
-
-protected:
-  /// Read all known fields from this ical incidence
-  void setFields( const KCalCore::Incidence::Ptr & );
-
-  /// Save all known fields into this ical incidence
-  void saveTo( const KCalCore::Incidence::Ptr & ) const;
-
-  /// Read all known fields from this contact
-  void setFields( const KABC::Addressee* );
-
-  /// Save all known fields into this contact
-  void saveTo( KABC::Addressee* ) const;
-
-  /// Read all known fields from this contact group
-  void setFields( const KABC::ContactGroup* );
-
-  /// Save all known fields into this contact groupd
-  void saveTo( KABC::ContactGroup* ) const;
-
-  // This just makes the initial dom tree with version and doctype
-  static QDomDocument domTree();
-
-  bool loadEmailAttribute( QDomElement& element, Email& email );
-
-  void saveEmailAttribute( QDomElement& element, const Email& email,
-                           const QString& tagName = "email" ) const;
-
-  // Load the attributes of this class
-  virtual bool loadAttribute( QDomElement& );
-
-  // Save the attributes of this class
-  virtual bool saveAttributes( QDomElement& ) const;
-
-  // Return the product ID
-  virtual QString productID() const = 0;
-
-  // Write a string tag
-  static void writeString( QDomElement&, const QString&, const QString& );
-
-  KDateTime localToUTC( const KDateTime& time ) const;
-  KDateTime utcToLocal( const KDateTime& time ) const;
-
-  QString mUid;
-  QString mBody;
-  QString mCategories;
-  KDateTime mCreationDate;
-  KDateTime mLastModified;
-  Sensitivity mSensitivity;
-  KTimeZone mTimeZone;
-
-  // KPilot synchronization stuff
-  bool mHasPilotSyncId,  mHasPilotSyncStatus;
-  unsigned long mPilotSyncId;
-  int mPilotSyncStatus;
-};
-
-}
-
-#endif // KOLABBASE_H
diff --git a/kolabformatV2/note.cpp b/kolabformatV2/note.cpp
deleted file mode 100644
index 612a1a8..0000000
--- a/kolabformatV2/note.cpp
+++ /dev/null
@@ -1,230 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#include "note.h"
-#include "libkolab-version.h"
-
-#include <kcalcore/journal.h>
-#include <kdebug.h>
-
-using namespace KolabV2;
-
-
-KCalCore::Journal::Ptr Note::xmlToJournal( const QString& xml )
-{
-  Note note;
-  note.load( xml );
-  KCalCore::Journal::Ptr journal( new KCalCore::Journal() );
-  note.saveTo( journal );
-  return journal;
-}
-
-QString Note::journalToXML( const KCalCore::Journal::Ptr &journal )
-{
-  Note note( journal );
-  return note.saveXML();
-}
-
-Note::Note( const KCalCore::Journal::Ptr &journal ) : mRichText( false )
-{
-  if ( journal )
-    setFields( journal );
-}
-
-Note::~Note()
-{
-}
-
-void Note::setSummary( const QString& summary )
-{
-  mSummary = summary;
-}
-
-QString Note::summary() const
-{
-  return mSummary;
-}
-
-void Note::setBackgroundColor( const QColor& bgColor )
-{
-  mBackgroundColor = bgColor;
-}
-
-QColor Note::backgroundColor() const
-{
-  return mBackgroundColor;
-}
-
-void Note::setForegroundColor( const QColor& fgColor )
-{
-  mForegroundColor = fgColor;
-}
-
-QColor Note::foregroundColor() const
-{
-  return mForegroundColor;
-}
-
-void Note::setRichText( bool richText )
-{
-  mRichText = richText;
-}
-
-bool Note::richText() const
-{
-  return mRichText;
-}
-
-bool Note::loadAttribute( QDomElement& element )
-{
-  QString tagName = element.tagName();
-  if ( tagName == "summary" )
-    setSummary( element.text() );
-  else if ( tagName == "foreground-color" )
-    setForegroundColor( stringToColor( element.text() ) );
-  else if ( tagName == "background-color" )
-    setBackgroundColor( stringToColor( element.text() ) );
-  else if ( tagName == "knotes-richtext" )
-    mRichText = ( element.text() == "true" );
-  else
-    return KolabBase::loadAttribute( element );
-
-  // We handled this
-  return true;
-}
-
-bool Note::saveAttributes( QDomElement& element ) const
-{
-  // Save the base class elements
-  KolabBase::saveAttributes( element );
-
-  // Save the elements
-#if 0
-  QDomComment c = element.ownerDocument().createComment( "Note specific attributes" );
-  element.appendChild( c );
-#endif
-
-  writeString( element, "summary", summary() );
-  if ( foregroundColor().isValid() )
-    writeString( element, "foreground-color", colorToString( foregroundColor() ) );
-  if ( backgroundColor().isValid() )
-    writeString( element, "background-color", colorToString( backgroundColor() ) );
-  writeString( element, "knotes-richtext", mRichText ? "true" : "false" );
-
-  return true;
-}
-
-
-bool Note::loadXML( const QDomDocument& document )
-{
-  QDomElement top = document.documentElement();
-
-  if ( top.tagName() != "note" ) {
-    qWarning( "XML error: Top tag was %s instead of the expected note",
-              top.tagName().toAscii().data() );
-    return false;
-  }
-
-  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      if ( !loadAttribute( e ) )
-        // TODO: Unhandled tag - save for later storage
-        kDebug() <<"Warning: Unhandled tag" << e.tagName();
-    } else
-      kDebug() <<"Node is not a comment or an element???";
-  }
-
-  return true;
-}
-
-QString Note::saveXML() const
-{
-  QDomDocument document = domTree();
-  QDomElement element = document.createElement( "note" );
-  element.setAttribute( "version", "1.0" );
-  saveAttributes( element );
-  document.appendChild( element );
-  return document.toString();
-}
-
-void Note::setFields( const KCalCore::Journal::Ptr &journal )
-{
-  KolabBase::setFields( journal );
-
-  setSummary( journal->summary() );
-
-  QString property = journal->customProperty( "KNotes", "BgColor" );
-  if ( !property.isEmpty() ) {
-    setBackgroundColor( property );
-  } else {
-    setBackgroundColor( "yellow" );
-  }
-
-  property = journal->customProperty( "KNotes", "FgColor" );
-  if ( !property.isEmpty() ) {
-    setForegroundColor( property );
-  } else {
-    setForegroundColor( "black" );
-  }
-
-  property = journal->customProperty( "KNotes", "RichText" );
-  if ( !property.isEmpty() ) {
-    setRichText( property == "true" ? true : false );
-  } else {
-    setRichText( "false" );
-  }
-}
-
-void Note::saveTo( const KCalCore::Journal::Ptr &journal )
-{
-  KolabBase::saveTo( journal );
-
-  // TODO: background and foreground
-  journal->setSummary( summary() );
-  if ( foregroundColor().isValid() )
-    journal->setCustomProperty( "KNotes", "FgColor",
-                                colorToString( foregroundColor() ) );
-  if ( backgroundColor().isValid() )
-    journal->setCustomProperty( "KNotes", "BgColor",
-                                colorToString( backgroundColor() ) );
-  journal->setCustomProperty( "KNotes", "RichText",
-                              richText() ? "true" : "false" );
-}
-
-QString Note::productID() const
-{
-  return QString( "KNotes %1, Kolab resource" ).arg( LIBKOLAB_LIB_VERSION_STRING );
-}
diff --git a/kolabformatV2/note.h b/kolabformatV2/note.h
deleted file mode 100644
index 3406ecc..0000000
--- a/kolabformatV2/note.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#ifndef KOLABV2_NOTE_H
-#define KOLABV2_NOTE_H
-
-#include <kcalcore/journal.h>
-
-#include "kolabbase.h"
-
-class QDomElement;
-
-namespace KolabV2 {
-
-/**
- * This class represents a note, and knows how to load/save it
- * from/to XML, and from/to a KCalCore::Journal.
- * The instances of this class are temporary, only used to convert
- * one to the other.
- */
-class Note : public KolabBase {
-public:
-  /// Use this to parse an xml string to a journal entry
-  /// The caller is responsible for deleting the returned journal
-    static KCalCore::Journal::Ptr xmlToJournal( const QString& xml );
-
-  /// Use this to get an xml string describing this journal entry
-    static QString journalToXML( const KCalCore::Journal::Ptr & );
-
-  /// Create a note object and
-  explicit Note( const KCalCore::Journal::Ptr &journal = KCalCore::Journal::Ptr() );
-  virtual ~Note();
-
-  void saveTo( const KCalCore::Journal::Ptr &journal );
-
-  virtual QString type() const { return "Note"; }
-
-  virtual void setSummary( const QString& summary );
-  virtual QString summary() const;
-
-  virtual void setBackgroundColor( const QColor& bgColor );
-  virtual QColor backgroundColor() const;
-
-  virtual void setForegroundColor( const QColor& fgColor );
-  virtual QColor foregroundColor() const;
-
-  virtual void setRichText( bool richText );
-  virtual bool richText() const;
-
-  // Load the attributes of this class
-  virtual bool loadAttribute( QDomElement& );
-
-  // Save the attributes of this class
-  virtual bool saveAttributes( QDomElement& ) const;
-
-  // Load this note by reading the XML file
-  virtual bool loadXML( const QDomDocument& xml );
-
-  // Serialize this note to an XML string
-  virtual QString saveXML() const;
-
-protected:
-  // Read all known fields from this ical incidence
-  void setFields( const KCalCore::Journal::Ptr & );
-
-  // Save all known fields into this ical incidence
-  void saveTo( const KCalCore::Incidence::Ptr & ) const;
-
-  QString productID() const;
-
-  QString mSummary;
-  QColor mBackgroundColor;
-  QColor mForegroundColor;
-  bool mRichText;
-};
-
-}
-
-#endif // KOLAB_NOTE_H
diff --git a/kolabformatV2/task.cpp b/kolabformatV2/task.cpp
deleted file mode 100644
index 0e6772f..0000000
--- a/kolabformatV2/task.cpp
+++ /dev/null
@@ -1,349 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#include "task.h"
-
-#include <kcalcore/todo.h>
-#include <kdebug.h>
-
-using namespace KolabV2;
-
-KCalCore::Todo::Ptr Task::fromXml( const QDomDocument& xmlDoc, const QString& tz )
-{
-  Task task( tz );
-  task.loadXML( xmlDoc );
-  KCalCore::Todo::Ptr todo(  new KCalCore::Todo() );
-  task.saveTo( todo );
-  return todo;
-}
-
-QString Task::taskToXML( const KCalCore::Todo::Ptr &todo, const QString& tz )
-{
-  Task task( tz, todo );
-  return task.saveXML();
-}
-
-Task::Task( const QString& tz, const KCalCore::Todo::Ptr &task )
-  : Incidence( tz, task ),
-    mPercentCompleted( 0 ),
-    mStatus( KCalCore::Incidence::StatusNone ),
-    mHasStartDate( false ), mHasDueDate( false ),
-    mHasCompletedDate( false )
-{
-  if ( task ) {
-    setFields( task );
-  }
-}
-
-Task::~Task()
-{
-}
-
-void Task::setPercentCompleted( int percent )
-{
-  mPercentCompleted = percent;
-}
-
-int Task::percentCompleted() const
-{
-  return mPercentCompleted;
-}
-
-void Task::setStatus( KCalCore::Incidence::Status status )
-{
-  mStatus = status;
-}
-
-KCalCore::Incidence::Status Task::status() const
-{
-  return mStatus;
-}
-
-void Task::setParent( const QString& parentUid )
-{
-  mParent = parentUid;
-}
-
-QString Task::parent() const
-{
-  return mParent;
-}
-
-void Task::setDueDate( const KDateTime &date )
-{
-  mDueDate = date;
-  mHasDueDate = true;
-}
-
-void Task::setDueDate( const QDate &date )
-{
-  mDueDate = KDateTime( date );
-  mHasDueDate = true;
-  mFloatingStatus = AllDay;
-}
-
-void Task::setDueDate( const QString &date )
-{
-  if ( date.length() > 10 ) {
-    // This is a date + time
-     setDueDate( stringToDateTime( date ) );
-  } else {
-     // This is only a date
-    setDueDate( stringToDate( date ) );
-  }
-}
-
-KDateTime Task::dueDate() const
-{
-  return mDueDate;
-}
-
-void Task::setHasStartDate( bool v )
-{
-  mHasStartDate = v;
-}
-
-bool Task::hasStartDate() const
-{
-  return mHasStartDate;
-}
-
-bool Task::hasDueDate() const
-{
-  return mHasDueDate;
-}
-
-void Task::setCompletedDate( const KDateTime& date )
-{
-  mCompletedDate = date;
-  mHasCompletedDate = true;
-}
-
-KDateTime Task::completedDate() const
-{
-  return mCompletedDate;
-}
-
-bool Task::hasCompletedDate() const
-{
-  return mHasCompletedDate;
-}
-
-bool Task::loadAttribute( QDomElement& element )
-{
-  QString tagName = element.tagName();
-
-  if ( tagName == "completed" ) {
-    bool ok;
-    int percent = element.text().toInt( &ok );
-    if ( !ok || percent < 0 || percent > 100 )
-      percent = 0;
-    setPercentCompleted( percent );
-  } else if ( tagName == "status" ) {
-    if ( element.text() == "in-progress" )
-      setStatus( KCalCore::Incidence::StatusInProcess );
-    else if ( element.text() == "completed" )
-      setStatus( KCalCore::Incidence::StatusCompleted );
-    else if ( element.text() == "waiting-on-someone-else" )
-      setStatus( KCalCore::Incidence::StatusNeedsAction );
-    else if ( element.text() == "deferred" )
-      // Guessing a status here
-      setStatus( KCalCore::Incidence::StatusCanceled );
-    else
-      // Default
-      setStatus( KCalCore::Incidence::StatusNone );
-  } else if ( tagName == "due-date" ) {
-    setDueDate( element.text() );
-  } else if ( tagName == "parent" ) {
-    setParent( element.text() );
-  } else if ( tagName == "x-completed-date" ) {
-    setCompletedDate( stringToDateTime( element.text() ) );
-  } else if ( tagName == "start-date" ) {
-    setHasStartDate( true );
-    setStartDate( element.text() );
-  } else
-    return Incidence::loadAttribute( element );
-
-  // We handled this
-  return true;
-}
-
-bool Task::saveAttributes( QDomElement& element ) const
-{
-  // Save the base class elements
-  Incidence::saveAttributes( element );
-
-  writeString( element, "completed", QString::number( percentCompleted() ) );
-
-  switch( status() ) {
-  case KCalCore::Incidence::StatusInProcess:
-    writeString( element, "status", "in-progress" );
-    break;
-  case KCalCore::Incidence::StatusCompleted:
-    writeString( element, "status", "completed" );
-    break;
-  case KCalCore::Incidence::StatusNeedsAction:
-    writeString( element, "status", "waiting-on-someone-else" );
-    break;
-  case KCalCore::Incidence::StatusCanceled:
-    writeString( element, "status", "deferred" );
-    break;
-  case KCalCore::Incidence::StatusNone:
-    writeString( element, "status", "not-started" );
-    break;
-  case KCalCore::Incidence::StatusTentative:
-  case KCalCore::Incidence::StatusConfirmed:
-  case KCalCore::Incidence::StatusDraft:
-  case KCalCore::Incidence::StatusFinal:
-  case KCalCore::Incidence::StatusX:
-    // All of these are saved as StatusNone.
-    writeString( element, "status", "not-started" );
-    break;
-  }
-
-  if ( hasDueDate() ) {
-    if ( mFloatingStatus == HasTime ) {
-      writeString( element, "due-date", dateTimeToString( dueDate() ) );
-    } else {
-      writeString( element, "due-date", dateToString( dueDate().date() ) );
-    }
-  }
-
-  if ( !parent().isNull() ) {
-    writeString( element, "parent", parent() );
-  }
-
-  if ( hasCompletedDate() && percentCompleted() == 100 ) {
-    writeString( element, "x-completed-date", dateTimeToString( completedDate() ) );
-  }
-
-  return true;
-}
-
-
-bool Task::loadXML( const QDomDocument& document )
-{
-  QDomElement top = document.documentElement();
-
-  if ( top.tagName() != "task" ) {
-    qWarning( "XML error: Top tag was %s instead of the expected task",
-              top.tagName().toAscii().data() );
-    return false;
-  }
-  setHasStartDate( false ); // todo's don't necessarily have one
-
-  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
-    if ( n.isComment() )
-      continue;
-    if ( n.isElement() ) {
-      QDomElement e = n.toElement();
-      if ( !loadAttribute( e ) )
-        // TODO: Unhandled tag - save for later storage
-        kDebug() <<"Warning: Unhandled tag" << e.tagName();
-    } else
-      kDebug() <<"Node is not a comment or an element???";
-  }
-
-  return true;
-}
-
-QString Task::saveXML() const
-{
-  QDomDocument document = domTree();
-  QDomElement element = document.createElement( "task" );
-  element.setAttribute( "version", "1.0" );
-  saveAttributes( element );
-  if ( !hasStartDate() && startDate().isValid() ) {
-    // events and journals always have a start date, but tasks don't.
-    // Remove the entry done by the inherited save above, because we
-    // don't have one.
-    QDomNodeList l = element.elementsByTagName( "start-date" );
-    Q_ASSERT( l.count() == 1 );
-    element.removeChild( l.item( 0 ) );
-  }
-  document.appendChild( element );
-  return document.toString();
-}
-
-void Task::setFields( const KCalCore::Todo::Ptr &task )
-{
-  Incidence::setFields( task );
-
-  setPercentCompleted( task->percentComplete() );
-  setStatus( task->status() );
-  setHasStartDate( task->hasStartDate() );
-
-  if ( task->hasDueDate() ) {
-    if ( task->allDay() ) {
-      // This is a floating task. Don't timezone move this one
-      mFloatingStatus = AllDay;
-      setDueDate( KDateTime( task->dtDue().date() ) );
-    } else {
-      mFloatingStatus = HasTime;
-      setDueDate( localToUTC( task->dtDue() ) );
-    }
-  } else {
-    mHasDueDate = false;
-  }
-
-  if ( !task->relatedTo().isEmpty() ) {
-    setParent( task->relatedTo() );
-  } else{
-    setParent( QString() );
-  }
-
-  if ( task->hasCompletedDate() && task->percentComplete() == 100 ) {
-    setCompletedDate( localToUTC( task->completed() ) );
-  } else {
-    mHasCompletedDate = false;
-  }
-}
-
-void Task::saveTo( const KCalCore::Todo::Ptr &task )
-{
-  Incidence::saveTo( task );
-
-  task->setPercentComplete( percentCompleted() );
-  task->setStatus( status() );
-  task->setHasStartDate( hasStartDate() );
-  task->setHasDueDate( hasDueDate() );
-  if ( hasDueDate() )
-    task->setDtDue( utcToLocal( dueDate() ) );
-
-  if ( !parent().isEmpty() ) {
-    task->setRelatedTo( parent() );
-  }
-
-  if ( hasCompletedDate() && task->percentComplete() == 100 )
-    task->setCompleted( utcToLocal( mCompletedDate ) );
-}
diff --git a/kolabformatV2/task.h b/kolabformatV2/task.h
deleted file mode 100644
index da45caf..0000000
--- a/kolabformatV2/task.h
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
-    This file is part of the kolab resource - the implementation of the
-    Kolab storage format. See www.kolab.org for documentation on this.
-
-    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
-
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Library General Public
-    License as published by the Free Software Foundation; either
-    version 2 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Library General Public License for more details.
-
-    You should have received a copy of the GNU Library General Public License
-    along with this library; see the file COPYING.LIB.  If not, write to
-    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-    Boston, MA 02110-1301, USA.
-
-    In addition, as a special exception, the copyright holders give
-    permission to link the code of this program with any edition of
-    the Qt library by Trolltech AS, Norway (or with modified versions
-    of Qt that use the same license as Qt), and distribute linked
-    combinations including the two.  You must obey the GNU General
-    Public License in all respects for all of the code used other than
-    Qt.  If you modify this file, you may extend this exception to
-    your version of the file, but you are not obligated to do so.  If
-    you do not wish to do so, delete this exception statement from
-    your version.
-*/
-
-#ifndef KOLABV2_TASK_H
-#define KOLABV2_TASK_H
-
-#include "incidence.h"
-
-#include <kcalcore/todo.h>
-#include <kcalcore/incidence.h>
-
-class QDomElement;
-
-namespace KCal {
-  class ResourceKolab;
-}
-
-namespace KolabV2 {
-
-/**
- * This class represents a task, and knows how to load/save it
- * from/to XML, and from/to a KCalCore::Todo.
- * The instances of this class are temporary, only used to convert
- * one to the other.
- */
-class Task : public Incidence {
-public:
-  /// Use this to parse an xml string to a task entry
-  /// The caller is responsible for deleting the returned task
-  static KCalCore::Todo::Ptr fromXml( const QDomDocument& xmlDoc, const QString& tz/*, KCalCore::ResourceKolab *res = 0,
-                                const QString& subResource = QString(), quint32 sernum = 0 */);
-
-  /// Use this to get an xml string describing this task entry
-  static QString taskToXML( const KCalCore::Todo::Ptr &, const QString& tz );
-
-  explicit Task( /*KCalCore::ResourceKolab *res, const QString& subResource, quint32 sernum,*/
-    const QString& tz, const KCalCore::Todo::Ptr &todo = KCalCore::Todo::Ptr() );
-  virtual ~Task();
-
-  virtual QString type() const { return "Task"; }
-
-  void saveTo( const KCalCore::Todo::Ptr &todo );
-
-  virtual void setPercentCompleted( int percent );
-  virtual int percentCompleted() const;
-
-  virtual void setStatus( KCalCore::Incidence::Status status );
-  virtual KCalCore::Incidence::Status status() const;
-
-  virtual void setParent( const QString& parentUid );
-  virtual QString parent() const;
-
-  virtual void setHasStartDate( bool );
-  virtual bool hasStartDate() const;
-
-  virtual void setDueDate( const KDateTime& date );
-  virtual void setDueDate( const QString &date );
-  virtual void setDueDate( const QDate &date );
-  virtual KDateTime dueDate() const;
-  virtual bool hasDueDate() const;
-
-  virtual void setCompletedDate( const KDateTime& date );
-  virtual KDateTime completedDate() const;
-  virtual bool hasCompletedDate() const;
-
-  // Load the attributes of this class
-  virtual bool loadAttribute( QDomElement& );
-
-  // Save the attributes of this class
-  virtual bool saveAttributes( QDomElement& ) const;
-
-  // Load this task by reading the XML file
-  virtual bool loadXML( const QDomDocument& xml );
-
-  // Serialize this task to an XML string
-  virtual QString saveXML() const;
-
-protected:
-  // Read all known fields from this ical todo
-  void setFields( const KCalCore::Todo::Ptr & );
-
-  int mPercentCompleted;
-  KCalCore::Incidence::Status mStatus;
-  QString mParent;
-
-  bool mHasStartDate;
-
-  bool mHasDueDate;
-  KDateTime mDueDate;
-
-  bool mHasCompletedDate;
-  KDateTime mCompletedDate;
-};
-
-}
-
-#endif // KOLAB_TASK_H
diff --git a/libkolab-version.h.cmake b/libkolab-version.h.cmake
deleted file mode 100644
index 1e921f9..0000000
--- a/libkolab-version.h.cmake
+++ /dev/null
@@ -1,25 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef LIBKOLAB_VERSION_H
-#define LIBKOLAB_VERSION_H
-
-#define LIBKOLAB_LIBNAME "@CMAKE_PROJECT_NAME@"
-#define LIBKOLAB_LIB_VERSION "@Libkolab_VERSION@"
-#define LIBKOLAB_LIB_VERSION_STRING "@Libkolab_VERSION_STRING@"
-
-#endif
\ No newline at end of file
diff --git a/mime/mimeutils.cpp b/mime/mimeutils.cpp
deleted file mode 100644
index e259773..0000000
--- a/mime/mimeutils.cpp
+++ /dev/null
@@ -1,303 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include "mimeutils.h"
-#include <quuid.h>
-#include <QtCore/qfile.h>
-#include <qdom.h>
-#include <kdebug.h>
-#include <kabc/addressee.h>
-#include "kolabformat/kolabdefinitions.h"
-#include "kolabformat/errorhandler.h"
-#include "libkolab-version.h"
-
-namespace Kolab {
-    namespace Mime {
-
-KMime::Content* findContentByType(const KMime::Message::Ptr &data, const QByteArray &type)
-{
-    if (type.isEmpty()) {
-        Error() << "Empty type";
-        return 0;
-    }
-    Q_ASSERT(!data->contents().isEmpty());
-    Q_FOREACH(KMime::Content *c, data->contents()) {
-//         qDebug() << c->contentType()->mimeType() << type;
-        if (c->contentType()->mimeType() ==  type) {
-            return c;
-        }
-    }
-    return 0;
-}
-
-KMime::Content* findContentByName(const KMime::Message::Ptr &data, const QString &name, QByteArray &type)
-{
-    Q_ASSERT(!data->contents().isEmpty());
-    Q_FOREACH(KMime::Content *c, data->contents()) {
-//         qDebug() << "searching: " << c->contentType()->name().toUtf8();
-        if ( c->contentType()->name() == name ) {
-            type = c->contentType()->mimeType();
-            return c;
-        }
-    }
-    return 0;
-}
-
-KMime::Content* findContentById(const KMime::Message::Ptr &data, const QByteArray &id, QByteArray &type, QString &name)
-{
-    if (id.isEmpty()) {
-        Error() << "looking for empty cid";
-        return 0;
-    }
-    Q_ASSERT(!data->contents().isEmpty());
-    Q_FOREACH(KMime::Content *c, data->contents()) {
-//         kDebug() << "searching: " << c->contentID()->identifier();
-        if ( c->contentID()->identifier() == id ) {
-            type = c->contentType()->mimeType();
-            name = c->contentType()->name();
-            return c;
-        }
-    }
-    return 0;
-}
-
-QList<QByteArray> getContentMimeTypeList(const KMime::Message::Ptr& data)
-{
-    QList<QByteArray> typeList;
-    Q_ASSERT(!data->contents().isEmpty());
-    Q_FOREACH(KMime::Content *c, data->contents()) {
-        typeList.append(c->contentType()->mimeType());
-    }
-    return typeList;
-}
-
-QString fromCid(const QString &cid)
-{
-    if (cid.left(4) != QString::fromLatin1("cid:")) { //Don't set if not a cid, happens when serializing format v2
-        return QString();
-    }
-    return cid.right(cid.size()-4);
-}
-
-KMime::Message::Ptr createMessage(const KCalCore::Incidence::Ptr &incidencePtr, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &productId)
-{
-    KMime::Message::Ptr message = createMessage( xKolabType, v3, productId );
-    if (!incidencePtr) {
-        Error() << "invalid incidence passed  in";
-        message->assemble();
-        return message;
-    }
-    if ( incidencePtr->organizer() && !incidencePtr->organizer()->email().isEmpty()) {
-        message->from()->addAddress( incidencePtr->organizer()->email().toUtf8(), incidencePtr->organizer()->name() );
-    }
-    message->subject()->fromUnicodeString( incidencePtr->uid(), "utf-8" );
-    
-    KMime::Content *content = createMainPart( mimetype, xml );
-    message->addContent( content );
-    
-    Q_FOREACH (KCalCore::Attachment::Ptr attachment, incidencePtr->attachments()) {
-        //Serialize the attachment as attachment with uri, referencing the created mime-part
-        if (v3 && !attachment->uri().contains("cid:")) {
-            //onyl by url, skip
-            continue;
-        }
-        message->addContent( createAttachmentPart(fromCid(attachment->uri()).toLatin1(), attachment->mimeType(), attachment->label(), attachment->decodedData() ) );
-    }
-    
-    message->assemble();
-    return message;
-}
-
-KMime::Message::Ptr createMessage(const KABC::Addressee &contact, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &prodid)
-{
-    KMime::Message::Ptr message = Mime::createMessage( xKolabType, v3, prodid );
-    message->subject()->fromUnicodeString( contact.uid(), "utf-8" );
-    message->from()->fromUnicodeString( contact.fullEmail(), "utf-8" );
-    
-    KMime::Content* content = Mime::createMainPart( mimetype, xml );
-    message->addContent( content );
-
-// TODO add pictures as separate mimeparts
-//     if ( !contact.picture().isNull() ) {
-//         QByteArray pic;
-//         QBuffer buffer(&pic);
-//         buffer.open(QIODevice::WriteOnly);
-//         contact.picture().save(&buffer, "PNG");
-//         buffer.close();
-//         
-//         content = Mime::createAttachmentPart(QByteArray(), "image/png", "kolab-picture.png", pic );
-//         message->addContent(content);
-//     }
-//     
-//     if ( !contact.logo().isNull() ) {
-//         QByteArray pic;
-//         QBuffer buffer(&pic);
-//         buffer.open(QIODevice::WriteOnly);
-//         contact.logo().save(&buffer, "PNG");
-//         buffer.close();
-//         
-//         content = Mime::createAttachmentPart(QByteArray(), "image/png", "kolab-logo.png", pic );
-//         message->addContent(content);
-//     }
-//     
-//     if ( !contact.sound().isEmpty() ) {
-//         content = Mime::createAttachmentPart(QByteArray(), "audio/unknown", "sound", contact.sound() );
-//         message->addContent(content);
-//     }
-    
-    message->assemble();
-    return message;
-}
-
-KMime::Message::Ptr createMessage(const QString &subject, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &prodid)
-{
-    KMime::Message::Ptr message = createMessage( xKolabType, v3, prodid );
-    if (!subject.isEmpty()) {
-        message->subject()->fromUnicodeString( subject, "utf-8" );
-    }
-    
-    KMime::Content *content = createMainPart( mimetype, xml );
-    message->addContent( content );
-    
-    message->assemble();
-    return message;
-}
-
-KMime::Content* createExplanationPart(bool v3)
-{
-    KMime::Content *content = new KMime::Content();
-    content->contentType()->setMimeType( "text/plain" );
-    content->contentType()->setCharset( "us-ascii" );
-    content->contentTransferEncoding()->setEncoding( KMime::Headers::CE7Bit );
-    if (v3) {
-        content->setBody( "This is a Kolab Groupware object.\n"
-        "To view this object you will need an email client that can understand the Kolab Groupware format.\n"
-        "For a list of such email clients please visit\n"
-        "http://www.kolab.org/get-kolab\n" );
-    } else {
-        content->setBody( "This is a Kolab Groupware object.\n"
-        "To view this object you will need an email client that can understand the Kolab Groupware format.\n"
-        "For a list of such email clients please visit\n"
-        "http://www.kolab.org/get-kolab\n" );
-    }
-    return content;
-}
-
-
-KMime::Message::Ptr createMessage(const QString& xKolabType, bool v3, const QString &prodid)
-{
-    KMime::Message::Ptr message( new KMime::Message );
-    message->date()->setDateTime( KDateTime::currentUtcDateTime() );
-    KMime::Headers::Generic *h = new KMime::Headers::Generic( X_KOLAB_TYPE_HEADER, message.get(), xKolabType, "utf-8" );
-    message->appendHeader( h );
-    if (v3) {
-        KMime::Headers::Generic *vh = new KMime::Headers::Generic( X_KOLAB_MIME_VERSION_HEADER, message.get(), KOLAB_VERSION_V3, "utf-8" );
-        message->appendHeader( vh );
-    }
-    message->userAgent()->from7BitString( prodid.toLatin1() );
-    message->contentType()->setMimeType( "multipart/mixed" );
-    message->contentType()->setBoundary( KMime::multiPartBoundary() );
-    
-    message->addContent( createExplanationPart(v3) );
-    return message;
-}
-
-
-KMime::Content* createMainPart(const QString& mimeType, const QByteArray& decodedContent)
-{
-    KMime::Content* content = new KMime::Content();
-    content->contentType()->setMimeType( mimeType.toLatin1() );
-    content->contentType()->setName( KOLAB_OBJECT_FILENAME, "us-ascii" );
-    content->contentTransferEncoding()->setEncoding( KMime::Headers::CEquPr );
-    content->contentDisposition()->setDisposition( KMime::Headers::CDattachment );
-    content->contentDisposition()->setFilename( KOLAB_OBJECT_FILENAME );
-    content->setBody( decodedContent );
-    return content;
-}
-
-KMime::Content* createAttachmentPart(const QByteArray& cid, const QString& mimeType, const QString& fileName, const QByteArray& decodedContent)
-{
-    KMime::Content* content = new KMime::Content();
-    if (!cid.isEmpty()) {
-        content->contentID()->setIdentifier( cid );
-    }
-    content->contentType()->setMimeType( mimeType.toLatin1() );
-    content->contentType()->setName( fileName, "utf-8" );
-    content->contentTransferEncoding()->setEncoding( KMime::Headers::CEbase64 );
-    content->contentDisposition()->setDisposition( KMime::Headers::CDattachment );
-    content->contentDisposition()->setFilename( fileName );
-    content->setBody( decodedContent );
-    return content;
-}
-
-void getAttachments(KCalCore::Incidence::Ptr incidence, const QStringList &attachments, const KMime::Message::Ptr &mimeData)
-{
-    if (!incidence) {
-        Error() << "Invalid incidence";
-        return;
-    }
-//     kDebug() << "getting " << attachments.size() << "attachments";
-//     kDebug() << mimeData->encodedContent();
-    foreach (const QString &name, attachments) {
-        QByteArray type;
-        KMime::Content *content = findContentByName(mimeData, name, type);
-        if (!content) { // guard against malformed events with non-existent attachments
-            Warning() << "could not find attachment: "<< name.toUtf8() << type;
-            continue;
-        }
-        const QByteArray c = content->decodedContent().toBase64();
-//         Debug() << c;
-        KCalCore::Attachment::Ptr attachment( new KCalCore::Attachment( c, QString::fromLatin1( type ) ) );
-        attachment->setLabel( name );
-        incidence->addAttachment(attachment);
-        Debug() << "ATTACHMENT NAME" << name << type;
-    }
-}
-
-void getAttachmentsById(KCalCore::Incidence::Ptr incidence, const KMime::Message::Ptr &mimeData)
-{
-    if (!incidence) {
-        Error() << "Invalid incidence";
-        return;
-    }
-//     kDebug() << "getting " << attachments.size() << "attachments";
-//     kDebug() << mimeData->encodedContent();
-
-    foreach(KCalCore::Attachment::Ptr attachment, incidence->attachments()) {
-        Debug() << attachment->uri();
-        if (!attachment->uri().contains("cid:")) {
-            continue;
-        }
-        //It's a referenced attachmant, extract it
-        QByteArray type;
-        QString name;
-        KMime::Content *content = findContentById(mimeData, fromCid(attachment->uri()).toLatin1(), type, name);
-        if (!content) { // guard against malformed events with non-existent attachments
-            Error() << "could not find attachment: "<< name << type;
-            continue;
-        }
-        attachment->setUri(QString());
-        attachment->setData(content->decodedContent().toBase64());
-        attachment->setMimeType(type);
-        attachment->setLabel(name);
-    }
-}
-
-
-
-}; //Namespace
-}; //Namespace
diff --git a/mime/mimeutils.h b/mime/mimeutils.h
deleted file mode 100644
index c3053a9..0000000
--- a/mime/mimeutils.h
+++ /dev/null
@@ -1,59 +0,0 @@
-/*
- * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#ifndef KOLABMIMEUTILS_H
-#define KOLABMIMEUTILS_H
-
-#include "kolab_export.h"
-
-#include <kcalcore/incidence.h>
-#include <kcalcore/event.h>
-#include <kmime/kmime_message.h>
-#include <kabc/addressee.h>
-class QDomDocument;
-
-namespace Kolab {
-    namespace Mime {
-
-KMime::Content* findContentByName(const KMime::Message::Ptr &data, const QString &name, QByteArray &type);
-KMime::Content* findContentByType(const KMime::Message::Ptr &data, const QByteArray &type);
-QList<QByteArray> getContentMimeTypeList(const KMime::Message::Ptr &data);
-
-/**
-* Get Attachments from a Mime message
-* 
-* Set the attachments listed in @param attachments on @param incidence from @param mimeData
-*/
-//v2
-void getAttachments(KCalCore::Incidence::Ptr incidence, const QStringList &attachments, const KMime::Message::Ptr &mimeData);
-//v3
-void getAttachmentsById(KCalCore::Incidence::Ptr incidence, const KMime::Message::Ptr &mimeData);
-
-///Generic serializing functions
-KMime::Message::Ptr createMessage(const KCalCore::Incidence::Ptr &incidencePtr, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &prodid);
-KMime::Message::Ptr createMessage(const KABC::Addressee &contact, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &prodid);
-KMime::Message::Ptr createMessage(const QString &subject, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &prodid);
-
-KMime::Content* createExplanationPart();
-KMime::Message::Ptr createMessage(const QString& mimeType, bool v3, const QString &prodid);
-KMime::Content* createMainPart(const QString& mimeType, const QByteArray& decodedContent);
-KMime::Content* createAttachmentPart(const QByteArray &cid, const QString& mimeType, const QString& fileName, const QByteArray& decodedContent);
-
-    };
-}; //Namespace
-
-#endif
diff --git a/shared.i b/shared.i
deleted file mode 100644
index 1941daa..0000000
--- a/shared.i
+++ /dev/null
@@ -1,13 +0,0 @@
-
-%{
-    /* This macro ensures that return vectors remain a vector also in python and are not converted to tuples */
-    #define SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
-    #include <kolabevent.h>
-%}
-%include "std_vector.i"
-%import(module="kolabformat") <kolabevent.h>
-namespace std {
-/* vectorevent moved to libkolabxml, vectorevent2 breaks the pythonbindings without vectorevent in here (compile error) */
-/*    %template(vectorevent) vector<Kolab::Event>; */
-/*    %template(vectorevent2) vector< vector<Kolab::Event> >; */
-};
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
new file mode 100644
index 0000000..17ea432
--- /dev/null
+++ b/src/CMakeLists.txt
@@ -0,0 +1,106 @@
+
+set( CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -Wnon-virtual-dtor -Wno-long-long -ansi -Wundef -Wcast-align -Wchar-subscripts -Wall -W -Wpointer-arith -Wformat-security -fno-exceptions -DQT_NO_EXCEPTIONS -fno-common -Woverloaded-virtual -fno-threadsafe-statics -fvisibility=hidden -Werror=return-type -fvisibility-inlines-hidden -fexceptions -UQT_NO_EXCEPTIONS -fPIC -g" )
+# message("${CMAKE_CXX_FLAGS}")
+set(CMAKE_CXX_FLAGS_RELEASE "${CMAKE_CXX_FLAGS_RELEASE} -DQT_NO_DEBUG")
+
+include_directories(
+  ${CMAKE_SOURCE_DIR}/src/kolabformatV2/
+  ${CMAKE_SOURCE_DIR}/src/kolabformat/
+  ${Libkolabxml_INCLUDES}
+)
+
+add_subdirectory(kolabformatV2)
+add_subdirectory(conversion)
+add_subdirectory(calendaring)
+add_subdirectory(icalendar)
+add_subdirectory(freebusy)
+add_subdirectory(utils)
+
+QT5_WRAP_CPP(CALENDARING_MOC calendaring/event.h)
+# QT5_WRAP_CPP(CONVERSION_MOC conversion/qtevent.h conversion/qtduration.h)
+
+set(KOLAB_SRCS
+    kolabformat/kolabobject.cpp
+    kolabformat/xmlobject.cpp
+    kolabformat/formathelpers.cpp
+    kolabformat/errorhandler.cpp
+    kolabformat/v2helpers.cpp
+    kolabformat/mimeobject.cpp
+    mime/mimeutils.cpp
+    ${CONVERSION_SRCS}
+    ${kolabformatv2_SRCS}
+    ${CALENDARING_SRCS}
+    ${ICALENDAR_SRCS}
+    ${CALENDARING_MOC}
+    ${CONVERSION_MOC}
+    ${FREEBUSY_SRCS}
+)
+
+set(KOLAB_LINK_LIBRARIES
+    ${Libkolabxml_LIBRARIES}
+    ${KDE_LIBRARIES}
+    Qt5::Core
+    Qt5::Xml
+    Qt5::Gui
+    Qt5::Widgets
+)
+
+
+
+add_library(KF5Kolab ${KOLAB_SRCS})
+generate_export_header(KF5Kolab BASE_NAME kolab)
+
+add_library(KF5::Kolab ALIAS KF5Kolab)
+
+
+target_include_directories(KF5Kolab INTERFACE "$<INSTALL_INTERFACE:${KF5_INCLUDE_INSTALL_DIR}/Kolab;${KF5_INCLUDE_INSTALL_DIR}/Kolab/kolab>")
+target_include_directories(KF5Kolab PUBLIC "$<BUILD_INTERFACE:${Libkolab_SOURCE_DIR}/src;${Libkolab_BINARY_DIR}/src;${Libkolab_SOURCE_DIR}/src/kolabformatV2>")
+
+target_link_libraries(KF5Kolab
+                      ${KOLAB_LINK_LIBRARIES}
+)
+
+set_target_properties(KF5Kolab PROPERTIES
+    VERSION ${KOLAB_VERSION_STRING}
+    SOVERSION ${KOLAB_SOVERSION}
+    EXPORT_NAME Kolab
+)
+
+
+install(FILES
+    ${CMAKE_CURRENT_BINARY_DIR}/kolab_export.h
+    kolabformat/kolabdefinitions.h
+    kolabformat/formathelpers.h
+    kolabformat/kolabobject.h
+    kolabformat/errorhandler.h
+    kolabformat/xmlobject.h
+    kolabformat/mimeobject.h
+    conversion/kcalconversion.h
+    conversion/kabcconversion.h
+    conversion/commonconversion.h
+    freebusy/freebusy.h
+
+
+    ${Kolab_HEADERS}
+    DESTINATION ${KF5_INCLUDE_INSTALL_DIR}/Kolab/kolab
+    COMPONENT Devel
+)
+
+ecm_generate_pri_file(BASE_NAME Kolab LIB_NAME KF5Kolab DEPS "Qt5::Gui" FILENAME_VAR PRI_FILENAME INCLUDE_INSTALL_DIR ${KF5_INCLUDE_INSTALL_DIR}/Kolab)
+install(FILES ${PRI_FILENAME} DESTINATION ${ECM_MKSPECS_INSTALL_DIR})
+
+
+install(TARGETS KF5Kolab EXPORT KF5KolabTargets ${KF5_INSTALL_TARGETS_DEFAULT_ARGS})
+
+
+include(SWIGUtils)
+if(PYTHON_BINDINGS)
+    generatePythonBindings(shared shared.i)
+    add_subdirectory(kolabformat/python)
+endif(PYTHON_BINDINGS)
+
+if(PHP_BINDINGS)
+    generatePHPBindings(kolabshared shared.i)
+    add_subdirectory(kolabformat/php)
+endif(PHP_BINDINGS)
+
diff --git a/src/KF5KolabConfig.cmake.in b/src/KF5KolabConfig.cmake.in
new file mode 100644
index 0000000..2da14c9
--- /dev/null
+++ b/src/KF5KolabConfig.cmake.in
@@ -0,0 +1,5 @@
+@PACKAGE_INIT@
+
+set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_LIST_DIR} ${CMAKE_MODULE_PATH})
+
+include("${CMAKE_CURRENT_LIST_DIR}/KF5KolabTargets.cmake")
diff --git a/src/calendaring/CMakeLists.txt b/src/calendaring/CMakeLists.txt
new file mode 100644
index 0000000..0cdbf08
--- /dev/null
+++ b/src/calendaring/CMakeLists.txt
@@ -0,0 +1,15 @@
+set (CALENDARING_SRCS
+    ${CMAKE_CURRENT_SOURCE_DIR}/calendaring.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/event.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/datetimeutils.cpp
+    PARENT_SCOPE)
+
+if(PYTHON_BINDINGS)
+    message("building python bindings")
+    add_subdirectory(python)
+endif(PYTHON_BINDINGS)
+
+if(PHP_BINDINGS)
+    message("building php bindings")
+    add_subdirectory(php)
+endif(PHP_BINDINGS)
diff --git a/src/calendaring/calendaring.cpp b/src/calendaring/calendaring.cpp
new file mode 100644
index 0000000..8128ca0
--- /dev/null
+++ b/src/calendaring/calendaring.cpp
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "calendaring.h"
+
+#include <kcalcore/event.h>
+#include <kcalcore/todo.h>
+#include <qdebug.h>
+#include <kolabevent.h>
+#include <QDate>
+
+#include "conversion/kcalconversion.h"
+#include "conversion/commonconversion.h"
+
+namespace Kolab {
+
+    namespace Calendaring {
+
+bool conflicts(const Kolab::Event &e1, const Kolab::Event &e2)
+{
+    KCalCore::Event::Ptr k1 = Kolab::Conversion::toKCalCore(e1);
+    KCalCore::Event::Ptr k2 = Kolab::Conversion::toKCalCore(e2);
+    if (k2->dtEnd().compare(k1->dtStart()) == KDateTime::Before) {
+        return false;
+    } else if (k1->dtEnd().compare(k2->dtStart()) == KDateTime::Before) {
+        return false;
+    }
+    return true;
+}
+
+std::vector< std::vector< Event > > getConflictingSets(const std::vector< Event > &events, const std::vector< Event > &events2)
+{
+    std::vector< std::vector< Kolab::Event > > ret;
+    for(std::size_t i = 0; i < events.size(); i++) {
+        std::vector<Kolab::Event> set;
+        const Kolab::Event &event = events.at(i);
+        set.push_back(event);
+        for(std::size_t q = i+1; q < events.size(); q++) {
+            const Kolab::Event &e2 = events.at(q);
+            if (conflicts(event, e2)) {
+                set.push_back(e2);
+            }
+        }
+        for(std::size_t m = 0; m < events2.size(); m++) {
+            const Kolab::Event &e2 = events2.at(m);
+            if (conflicts(event, e2)) {
+                set.push_back(e2);
+            }
+        }
+        if (set.size() > 1) {
+            ret.push_back(set);
+        }
+    }
+    return ret;
+}
+
+
+std::vector<Kolab::cDateTime> timeInInterval(const Kolab::Event &e, const Kolab::cDateTime &start, const Kolab::cDateTime &end)
+{
+    KCalCore::Event::Ptr k = Kolab::Conversion::toKCalCore(e);
+    KCalCore::DateTimeList list = k->recurrence()->timesInInterval(Kolab::Conversion::toDate(start), Kolab::Conversion::toDate(end));
+    std::vector<Kolab::cDateTime> dtList;
+    foreach(const KDateTime &dt, list) {
+        dtList.push_back(Kolab::Conversion::fromDate(dt));
+    }
+    return dtList;
+}
+
+Calendar::Calendar()
+:   mCalendar(new KCalCore::MemoryCalendar(Kolab::Conversion::getTimeSpec(true, std::string()))) //Always utc as it doesn't change anything anyways
+{
+}
+
+void Calendar::addEvent(const Kolab::Event &event)
+{
+    KCalCore::Event::Ptr k = Kolab::Conversion::toKCalCore(event);
+    if (!mCalendar->addEvent(k)) {
+        qWarning() << "failed to add event";
+    }
+}
+
+
+std::vector<Kolab::Event> Calendar::getEvents(const Kolab::cDateTime& start, const Kolab::cDateTime& end, bool sort)
+{
+    const KDateTime s = Kolab::Conversion::toDate(start);
+    const KDateTime e = Kolab::Conversion::toDate(end);
+    const KDateTime::Spec timeSpec = s.timeSpec();
+    KCalCore::Event::List list = mCalendar->events(s.date(), e.date(), timeSpec, true);
+    if (sort) {
+        list = mCalendar->sortEvents(list, KCalCore::EventSortStartDate, KCalCore::SortDirectionAscending);
+    }
+    std::vector<Kolab::Event> eventlist;
+    foreach (const KCalCore::Event::Ptr &event, list) {
+        //We have to filter the list by time
+        if (event->dtEnd().compare(s) != KDateTime::Before && e.compare(event->dtStart()) != KDateTime::Before) {
+            eventlist.push_back(Kolab::Conversion::fromKCalCore(*event));
+        }
+    }
+    return eventlist;
+}
+
+
+    } //Namespace
+} //Namespace
diff --git a/src/calendaring/calendaring.h b/src/calendaring/calendaring.h
new file mode 100644
index 0000000..b48c1d6
--- /dev/null
+++ b/src/calendaring/calendaring.h
@@ -0,0 +1,86 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef KOLABCALENDARING_H
+#define KOLABCALENDARING_H
+
+#ifndef SWIG
+#include "kolab_export.h"
+#else
+/* No export/import SWIG interface files */
+#define KOLAB_EXPORT
+#endif
+
+#include <kcalcore/event.h>
+#include <kcalcore/memorycalendar.h>
+#include <boost/scoped_ptr.hpp>
+#include <kolabevent.h>
+
+namespace Kolab {
+    namespace Calendaring {
+/**
+ * Returns true if the events conflict (overlap)
+ * Start and end date/time is inclusive.
+ *
+ * Does not take recurrences into account.
+ */
+KOLAB_EXPORT bool conflicts(const Kolab::Event &, const Kolab::Event &);
+
+/**
+ * Returns sets of the events which are directly conflicting with each other.
+ * The same event may appear in multiple sets.
+ * Non-conflicting events are not returned.
+ * conflicts() is used for conflict detection.
+ *
+ * If the second list is given, each event from the first list is additionally checked against each event of the second set.
+ * Conflicts within the second list are not detected.
+ *
+ * The checked event from the first list comes always first in the returned set.
+ */
+KOLAB_EXPORT std::vector< std::vector<Kolab::Event> > getConflictingSets(const std::vector<Kolab::Event> &, const std::vector<Kolab::Event> & = std::vector<Kolab::Event>());
+
+/**
+ * Returns the dates in which the event recurs within the specified timespan.
+ */
+KOLAB_EXPORT std::vector<Kolab::cDateTime> timeInInterval(const Kolab::Event &, const Kolab::cDateTime &start, const Kolab::cDateTime &end);
+
+/**
+ * In-Memory Calendar Cache
+ */
+class KOLAB_EXPORT Calendar {
+public:
+    explicit Calendar();
+    /**
+     * Add an event to the in-memory calendar.
+     */
+    void addEvent(const Kolab::Event &);
+    /**
+     * Returns all events within the specified interval (start and end inclusive).
+     *
+     * @param sort controls if the resulting event set is sorted in ascending order according to the start date
+     */
+    std::vector<Kolab::Event> getEvents(const Kolab::cDateTime &start, const Kolab::cDateTime &end, bool sort);
+private:
+    Calendar(const Calendar &);
+    void operator=(const Calendar &);
+    boost::scoped_ptr<KCalCore::MemoryCalendar> mCalendar;
+};
+
+    }; //Namespace
+}; //Namespace
+
+#endif
diff --git a/src/calendaring/calendaring.i b/src/calendaring/calendaring.i
new file mode 100644
index 0000000..fc935e4
--- /dev/null
+++ b/src/calendaring/calendaring.i
@@ -0,0 +1,19 @@
+%{
+    /* This macro ensures that return vectors remain a vector also in python and are not converted to tuples */
+    #define SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
+    
+    #include "../calendaring/calendaring.h"
+    #include "../calendaring/event.h"
+%}
+
+%include "std_string.i"
+%include "std_vector.i"
+
+%import(module="kolabformat") <kolabevent.h>
+%import "../shared.i"
+
+%rename(EventCal) Kolab::Calendaring::Event;
+%rename(KolabCalendar) Kolab::Calendaring::Calendar;
+
+%include "../calendaring/calendaring.h"
+%include "../calendaring/event.h"
diff --git a/src/calendaring/datetimeutils.cpp b/src/calendaring/datetimeutils.cpp
new file mode 100644
index 0000000..d6ea077
--- /dev/null
+++ b/src/calendaring/datetimeutils.cpp
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "datetimeutils.h"
+
+#include <qdebug.h>
+#include <ksystemtimezone.h>
+#include "conversion/commonconversion.h"
+
+namespace Kolab {
+    namespace DateTimeUtils {
+    KOLAB_EXPORT std::string getLocalTimezone()
+    {
+        const QString tz = KSystemTimeZones::local().name();
+        return tz.toStdString();
+    }
+
+    } //Namespace
+} //Namespace
diff --git a/src/calendaring/datetimeutils.h b/src/calendaring/datetimeutils.h
new file mode 100644
index 0000000..969f8bc
--- /dev/null
+++ b/src/calendaring/datetimeutils.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef KOLABDATETIMEUTILS_H
+#define KOLABDATETIMEUTILS_H
+
+#ifndef SWIG
+#include "kolab_export.h"
+#else
+/* No export/import SWIG interface files */
+#define KOLAB_EXPORT
+#endif
+
+#include <string>
+
+namespace Kolab {
+    namespace DateTimeUtils {
+
+    KOLAB_EXPORT std::string getLocalTimezone();
+
+    }; //Namespace
+}; //Namespace
+
+#endif
diff --git a/src/calendaring/event.cpp b/src/calendaring/event.cpp
new file mode 100644
index 0000000..259a463
--- /dev/null
+++ b/src/calendaring/event.cpp
@@ -0,0 +1,239 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "event.h"
+#include <icalendar/icalendar.h>
+#include <kolabformat/kolabobject.h>
+#include <conversion/kcalconversion.h>
+#include <conversion/commonconversion.h>
+
+#include <iostream>
+#include <kolabformat.h>
+#include <kolabevent_p.h>
+
+namespace Kolab {
+    namespace Calendaring {
+
+Event::Event()
+: Kolab::Event()
+{
+    setUid(Kolab::generateUID());
+}
+
+Event::Event(const Kolab::Event &e)
+: Kolab::Event(e)
+{
+}
+
+Event::~Event()
+{
+
+}
+
+
+bool Event::read(const std::string &string)
+{
+    const Kolab::Event &e = Kolab::readEvent(string, false);
+    if (Kolab::error()) {
+        return false;
+    }
+    Kolab::Event::operator=(e);
+    return true;
+}
+
+std::string Event::write() const
+{
+    return Kolab::writeEvent(*this);
+}
+
+bool Event::fromMime(const std::string &input)
+{
+    KMime::Message::Ptr msg = KMime::Message::Ptr(new KMime::Message);
+    msg->setContent( KMime::CRLFtoLF(Kolab::Conversion::fromStdString(input).toUtf8()) );
+    msg->parse();
+    msg->content(KMime::ContentIndex());
+    KolabObjectReader reader(msg);
+    if (reader.getType() != EventObject) {
+        std::cout << "not an event ";
+        return false;
+    }
+    const Kolab::Event &e = Kolab::Conversion::fromKCalCore(*reader.getEvent());
+    Kolab::Event::operator=(e);
+    return true;
+}
+
+std::string Event::toMime() const
+{
+    return std::string(QString(KolabObjectWriter::writeEvent(Kolab::Conversion::toKCalCore(*this))->encodedContent()).toUtf8().constData());
+}
+
+
+bool Event::fromICal(const std::string &input)
+{
+    std::vector<Kolab::Event> list = fromICalEvents(input);
+    if (list.size() != 1) {
+        std::cout << "invalid number of events: " << list.size();
+        return false;
+    }
+    Kolab::Event::operator=(list.at(0));
+    return true;
+}
+
+std::string Event::toICal() const
+{
+    std::vector<Kolab::Event> list;
+    list.push_back(*this);
+    return Kolab::toICal(list);
+}
+
+bool Event::fromIMip(const std::string &input)
+{
+    std::vector<Kolab::Event> list = mITipHandler.fromIMip(input);
+    if (list.size() != 1) {
+        std::cout << "invalid number of events: " << list.size();
+        return false;
+    }
+    Kolab::Event::operator=(list.at(0));
+    return true;
+}
+
+std::string Event::toIMip(ITipMethod method) const
+{
+    std::vector<Kolab::Event> list;
+    list.push_back(*this);
+    return mITipHandler.toIMip(*this, static_cast<ITipHandler::ITipMethod>(method), organizer().email());
+}
+
+Calendaring::Event::ITipMethod Event::getSchedulingMethod() const
+{
+    Q_ASSERT((int)iTIPPublish == (int)ITipHandler::iTIPPublish);
+    Q_ASSERT((int)iTIPNoMethod == (int)ITipHandler::iTIPNoMethod);
+    return static_cast<ITipMethod>(mITipHandler.method());
+}
+
+
+
+bool contains(const Kolab::ContactReference &delegatorRef, const std::vector <Kolab::ContactReference > &list)
+{
+    foreach (const Kolab::ContactReference &ref, list) {
+        if (delegatorRef.uid() == ref.uid() || delegatorRef.email() == ref.email() || delegatorRef.name() == ref.name()) {
+            return true;
+        }
+    }
+    return false;
+}
+
+void Event::delegate(const std::vector< Attendee >& delegators, const std::vector< Attendee >& delegatees)
+{
+
+    //First build a list of attendee references, and insert any missing attendees
+    std::vector<Kolab::Attendee*> delegateesRef;
+    foreach(const Attendee &a, delegatees) {
+        if (Attendee *attendee = getAttendee(a.contact())) {
+            delegateesRef.push_back(attendee);
+        } else {
+            d->attendees.push_back(a);
+            delegateesRef.push_back(&d->attendees.back());
+        }
+    }
+
+    std::vector<Kolab::Attendee*> delegatorsRef;
+    foreach(const Attendee& a, delegators) {
+        if (Attendee *attendee = getAttendee(a.contact())) {
+            delegatorsRef.push_back(attendee);
+        } else {
+            std::cout << "missing delegator";
+        }
+    }
+    
+    foreach (Attendee *delegatee, delegateesRef) {
+        std::vector <Kolab::ContactReference > delegatedFrom = delegatee->delegatedFrom();
+        foreach (Attendee *delegator, delegatorsRef) {
+
+            //Set the delegator on each delegatee
+            const ContactReference &delegatorRef = delegator->contact();
+            if (!contains(delegatorRef, delegatedFrom)) {
+                delegatedFrom.push_back(Kolab::ContactReference(Kolab::ContactReference::EmailReference, delegatorRef.email(), delegatorRef.name()));
+            }
+
+            //Set the delegatee on each delegator
+            std::vector <Kolab::ContactReference > delegatedTo = delegator->delegatedTo();
+            const ContactReference &delegaeeRef = delegatee->contact();
+            if (!contains(delegaeeRef, delegatedTo)) {
+                delegatedTo.push_back(Kolab::ContactReference(Kolab::ContactReference::EmailReference, delegaeeRef.email(), delegaeeRef.name()));
+            }
+            delegator->setDelegatedTo(delegatedTo);
+        }
+        delegatee->setDelegatedFrom(delegatedFrom);
+    }
+    
+}
+
+Attendee *Event::getAttendee(const ContactReference &ref)
+{
+    for(std::vector <Kolab::Attendee >::iterator it = d->attendees.begin();
+        it != d->attendees.end(); it++) {
+        if (it->contact().uid() == ref.uid() || it->contact().email() == ref.email() || it->contact().name() == ref.name()) {
+            return &*it;
+        }
+    }
+    return 0;
+}
+
+
+Attendee Event::getAttendee(const std::string &s)
+{
+    foreach(const Attendee &a, attendees()) {
+        if (a.contact().uid() == s || a.contact().email() == s || a.contact().name() == s) {
+            return a;
+        }
+    }
+    return Attendee();
+}
+
+cDateTime Calendaring::Event::getNextOccurence(const cDateTime &date)
+{
+    KCalCore::Event::Ptr event = Kolab::Conversion::toKCalCore(*this);
+    if (!event->recurs()) {
+        return cDateTime();
+    }
+    const KDateTime nextDate = event->recurrence()->getNextDateTime(Kolab::Conversion::toDate(date));
+    return Kolab::Conversion::fromDate(nextDate);
+}
+
+
+cDateTime Calendaring::Event::getOccurenceEndDate(const cDateTime &startDate)
+{
+    KCalCore::Event::Ptr event = Kolab::Conversion::toKCalCore(*this);
+    const KDateTime start = Kolab::Conversion::toDate(startDate);
+    return Kolab::Conversion::fromDate(event->endDateForStart(start));
+}
+
+cDateTime Calendaring::Event::getLastOccurrence() const
+{
+    KCalCore::Event::Ptr event = Kolab::Conversion::toKCalCore(*this);
+    if (!event->recurs()) {
+        return cDateTime();
+    }
+    const KDateTime endDate = event->recurrence()->endDateTime();
+    return Kolab::Conversion::fromDate(endDate);
+}
+
+
+    };
+};
diff --git a/src/calendaring/event.h b/src/calendaring/event.h
new file mode 100644
index 0000000..e9b5ce4
--- /dev/null
+++ b/src/calendaring/event.h
@@ -0,0 +1,122 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef EVENT_H
+#define EVENT_H
+#include <kolabevent.h>
+
+#ifndef SWIG
+#include "kolab_export.h"
+#include <icalendar/icalendar.h>
+#else
+/* No export/import SWIG interface files */
+#define KOLAB_EXPORT
+#endif
+
+namespace Kolab {
+    namespace Calendaring {
+
+class KOLAB_EXPORT Event: public Kolab::Event
+{
+public:
+    Event();
+    Event(const Kolab::Event &);
+    ~Event();
+
+    bool read(const std::string &);
+    /**
+     * Convert to kolab xml format.
+     */
+    std::string write() const;
+
+
+    bool fromMime(const std::string &);
+
+    /**
+     * Convert to kolab mime format.
+     */
+    std::string toMime() const;
+
+    enum ITipMethod {
+            iTIPPublish,       /**< Event, to-do, journal or freebusy posting */
+            iTIPRequest,       /**< Event, to-do or freebusy scheduling request */
+            iTIPReply,         /**< Event, to-do or freebusy reply to request */
+            iTIPAdd,           /**< Event, to-do or journal additional property request */
+            iTIPCancel,        /**< Event, to-do or journal cancellation notice */
+            iTIPRefresh,       /**< Event or to-do description update request */
+            iTIPCounter,       /**< Event or to-do submit counter proposal */
+            iTIPDeclineCounter,/**< Event or to-do decline a counter proposal */
+            iTIPNoMethod       /**< No method */
+        };
+    
+    bool fromICal(const std::string &);
+    std::string toICal() const;
+
+    bool fromIMip(const std::string &);
+    std::string toIMip(ITipMethod method) const;
+
+    /**
+     * Returns the scheduling method from the last fromIMip call
+     */
+    ITipMethod getSchedulingMethod() const;
+
+
+    /**
+     * Updates the delegators and delegatees of the event.
+     *
+     * Creates a new attendee for each missing delegatee (delegators are expected to be existing), and then updates each delegatee with the delegator (delegatedFrom).
+     * Delegators delegatedTo is updated accordingly.
+     * Existing attendees are tried to be found by uid/email/name (in this order).
+     *
+     */
+    void delegate(const std::vector<Kolab::Attendee> &delegators, const std::vector<Kolab::Attendee> &delegatees);
+
+    /**
+     * Get attendee by uid/email/name (in this order)
+     */
+    Kolab::Attendee getAttendee(const std::string &);
+
+    /**
+     * Returns the next occurence for a recurring event.
+     *
+     * If the start date of the event is passed in, the second occurence is returned (so it can be used in a for loop to loop through all occurences).
+     *
+     * If there is no next occurence or the event is not recurring at all an invalid cDateTime is returned.
+     */
+    Kolab::cDateTime getNextOccurence(const Kolab::cDateTime &);
+
+    /**
+     * Returns the corresponding end date-time for a specific occurence.
+     * @param start is the start date of the occurence.
+     */
+    Kolab::cDateTime getOccurenceEndDate(const Kolab::cDateTime &start);
+
+    /**
+     * Returns the last occurrence, or and invalid cDateTime if the event is not recurring or recurring idenfinitely.
+     */
+    Kolab::cDateTime getLastOccurrence() const;
+
+private:
+    Kolab::Attendee *getAttendee(const ContactReference &);
+    Kolab::ITipHandler mITipHandler;
+};
+
+    };
+};
+
+#endif // EVENT_H
diff --git a/src/calendaring/php/CMakeLists.txt b/src/calendaring/php/CMakeLists.txt
new file mode 100644
index 0000000..5fc92ec
--- /dev/null
+++ b/src/calendaring/php/CMakeLists.txt
@@ -0,0 +1,4 @@
+#Generate PHP wrapper
+include_directories(../)
+include(SWIGUtils)
+generatePHPBindings(kolabcalendaring ../calendaring.i)
diff --git a/src/calendaring/php/test.php b/src/calendaring/php/test.php
new file mode 100644
index 0000000..c31bc6f
--- /dev/null
+++ b/src/calendaring/php/test.php
@@ -0,0 +1,236 @@
+<?php
+//run using "php -d enable_dl=On extension=./kolabcalendaring.so test.php [--verbose]"
+
+include("kolabformat.php");
+include("kolabcalendaring.php");
+
+/////// Basic unit test facilities
+
+$errors = 0;
+$verbose = preg_match('/\s(--verbose|-v)\b/', join(' ', $_SERVER['argv']));
+
+function assertequal($got, $expect, $name) {
+	global $verbose, $errors;
+
+	if ($got == $expect) {
+		if ($verbose)
+			print "OK - $name\n";
+		return true;
+	}
+	else {
+		$errors++;
+		print "FAIL - $name\n";
+		print "-- Expected " . var_export($expect, true) . ", got " . var_export($got, true) . " --\n";
+		return false;
+	}
+}
+
+function asserttrue($arg, $name) {
+	return assertequal($arg, true, $name);
+}
+
+function assertfalse($arg, $name) {
+	return assertequal($arg, false, $name);
+}
+
+
+/////// Test EventCal recurrence
+
+$xml = <<<EOF
+<icalendar xmlns="urn:ietf:params:xml:ns:icalendar-2.0">
+  <vcalendar>
+    <properties>
+      <prodid>
+        <text>Libkolab-0.4 Libkolabxml-0.9</text>
+      </prodid>
+      <version>
+        <text>2.0</text>
+      </version>
+      <x-kolab-version>
+        <text>3.0dev1</text>
+      </x-kolab-version>
+    </properties>
+    <components>
+      <vevent>
+        <properties>
+          <uid>
+            <text>DDDEBE616DB7480A003725D1D7C4C2FE-8C02E7EEB49870A2</text>
+          </uid>
+          <created><date-time>2012-10-23T11:04:53Z</date-time></created>
+          <dtstamp><date-time>2012-10-23T13:04:53Z</date-time></dtstamp>
+          <sequence>
+            <integer>0</integer>
+          </sequence>
+          <class>
+            <text>PUBLIC</text>
+          </class>
+          <dtstart>
+            <parameters>
+              <tzid>
+                <text>/kolab.org/Europe/Paris</text>
+              </tzid>
+            </parameters>
+            <date-time>2012-10-23T14:00:00</date-time>
+          </dtstart>
+          <dtend>
+            <parameters>
+              <tzid>
+                <text>/kolab.org/Europe/Paris</text>
+              </tzid>
+            </parameters>
+            <date-time>2012-10-23T15:30:00</date-time>
+          </dtend>
+          <rrule>
+            <recur>
+              <freq>DAILY</freq>
+              <count>4</count>
+              <interval>2</interval>
+            </recur>
+          </rrule>
+          <summary>
+            <text>Recurring with libkolab</text>
+          </summary>
+        </properties>
+      </vevent>
+    </components>
+  </vcalendar>
+</icalendar>
+EOF;
+
+$rdates = <<<EOF
+<icalendar xmlns="urn:ietf:params:xml:ns:icalendar-2.0">
+  <vcalendar>
+    <properties>
+      <prodid>
+        <text>Roundcube-libkolab-0.9 Libkolabxml-1.1</text>
+      </prodid>
+      <version>
+        <text>2.0</text>
+      </version>
+      <x-kolab-version>
+        <text>3.1.0</text>
+      </x-kolab-version>
+    </properties>
+    <components>
+      <vevent>
+        <properties>
+          <uid>
+            <text>49961C572093EC3FC125799C004A200F-Lotus_Notes_Generated</text>
+          </uid>
+          <created>
+            <date-time>2014-02-28T12:57:42Z</date-time>
+          </created>
+          <dtstamp>
+            <date-time>2014-02-28T12:57:42Z</date-time>
+          </dtstamp>
+          <sequence>
+            <integer>0</integer>
+          </sequence>
+          <class>
+            <text>PUBLIC</text>
+          </class>
+          <dtstart>
+            <parameters>
+              <tzid>
+                <text>/kolab.org/Europe/Amsterdam</text>
+              </tzid>
+            </parameters>
+            <date-time>2012-03-30T04:00:00</date-time>
+          </dtstart>
+          <dtend>
+            <parameters>
+              <tzid>
+                <text>/kolab.org/Europe/Amsterdam</text>
+              </tzid>
+            </parameters>
+            <date-time>2012-03-30T20:00:00</date-time>
+          </dtend>
+          <transp>
+            <text>TRANSPARENT</text>
+          </transp>
+          <rdate>
+            <date>2012-03-30</date>
+            <date>2013-03-30</date>
+            <date>2014-03-30</date>
+            <date>2015-03-30</date>
+            <date>2016-03-30</date>
+            <date>2017-03-30</date>
+            <date>2018-03-30</date>
+            <date>2019-03-30</date>
+            <date>2020-03-30</date>
+            <date>2021-03-30</date>
+          </rdate>
+          <summary>
+            <text>Geburtstag Jane Doe (30.03.1969)</text>
+          </summary>
+        </properties>
+      </vevent>
+    </components>
+  </vcalendar>
+</icalendar>
+EOF;
+
+$e = kolabformat::readEvent($xml, false);
+$ec = new EventCal($e);
+
+$rstart = new cDateTime(2012,8,1, 0,0,0);
+# asserttrue($ec->getNextOccurence($rstart) instanceof cDateTime, "EventCal::getNextOccurence() returning cDateTime instance");
+
+$next = new cDateTime($ec->getNextOccurence($rstart));
+assertequal(
+	sprintf("%d-%d-%d %02d:%02d:%02d", $next->year(), $next->month(), $next->day(), $next->hour(), $next->minute(), $next->second()),
+	"2012-10-23 14:00:00",
+	"EventCal first recurrence"
+);
+
+$next = new cDateTime($ec->getNextOccurence($next));
+assertequal(
+	sprintf("%d-%d-%d %02d:%02d:%02d", $next->year(), $next->month(), $next->day(), $next->hour(), $next->minute(), $next->second()),
+	"2012-10-25 14:00:00",
+	"EventCal second recurrence"
+);
+
+$end = new cDateTime($ec->getOccurenceEndDate($next));
+assertequal(
+	sprintf("%d-%d-%d %02d:%02d:%02d", $end->year(), $end->month(), $end->day(), $end->hour(), $end->minute(), $end->second()),
+	"2012-10-25 15:30:00",
+	"EventCal::getOccurenceEndDate"
+);
+
+$last = new cDateTime($ec->getLastOccurrence());
+assertequal(
+	sprintf("%d-%d-%d %02d:%02d:%02d", $last->year(), $last->month(), $last->day(), $last->hour(), $last->minute(), $last->second()),
+	"2012-10-29 14:00:00",
+	"EventCal::getLastOccurence"
+);
+
+// test event with RDATE list
+
+$e = kolabformat::readEvent($rdates, false);
+$ec = new EventCal($e);
+
+$rstart = new cDateTime(2012,3,1, 0,0,0);
+$next = new cDateTime($ec->getNextOccurence($rstart));
+assertequal(
+	sprintf("%d-%02d-%02d %02d:%02d:%02d", $next->year(), $next->month(), $next->day(), $next->hour(), $next->minute(), $next->second()),
+	"2012-03-30 04:00:00",
+	"RDATE first recurrence"
+);
+
+$next = new cDateTime($ec->getNextOccurence($next));
+assertequal(
+	sprintf("%d-%02d-%02d %02d:%02d:%02d", $next->year(), $next->month(), $next->day(), $next->hour(), $next->minute(), $next->second()),
+	"2013-03-30 04:00:00",
+	"RDATE next recurrence"
+);
+
+$last = new cDateTime($ec->getLastOccurrence());
+assertequal(
+	sprintf("%d-%02d-%d %02d:%02d:%02d", $last->year(), $last->month(), $last->day(), $last->hour(), $last->minute(), $last->second()),
+	"2021-03-30 04:00:00",
+	"RDATE last occurence"
+);
+
+
+// terminate with error status
+exit($errors);
diff --git a/src/calendaring/python/CMakeLists.txt b/src/calendaring/python/CMakeLists.txt
new file mode 100644
index 0000000..2a49bea
--- /dev/null
+++ b/src/calendaring/python/CMakeLists.txt
@@ -0,0 +1,3 @@
+include_directories(../)
+include(SWIGUtils)
+generatePythonBindings(calendaring ../calendaring.i)
\ No newline at end of file
diff --git a/src/conversion/CMakeLists.txt b/src/conversion/CMakeLists.txt
new file mode 100644
index 0000000..683de63
--- /dev/null
+++ b/src/conversion/CMakeLists.txt
@@ -0,0 +1,8 @@
+
+set (CONVERSION_SRCS
+    ${CMAKE_CURRENT_SOURCE_DIR}/kcalconversion.cpp 
+    ${CMAKE_CURRENT_SOURCE_DIR}/kabcconversion.cpp 
+    ${CMAKE_CURRENT_SOURCE_DIR}/commonconversion.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/kolabconversion.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/timezoneconverter.cpp PARENT_SCOPE)
+
diff --git a/src/conversion/commonconversion.cpp b/src/conversion/commonconversion.cpp
new file mode 100644
index 0000000..7accd22
--- /dev/null
+++ b/src/conversion/commonconversion.cpp
@@ -0,0 +1,174 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "commonconversion.h"
+#include "timezoneconverter.h"
+#include <kolabformat/errorhandler.h>
+
+#include <iostream>
+#include <ksystemtimezone.h>
+#include <kdebug.h>
+#include <QUrl>
+
+namespace Kolab {
+    namespace Conversion {
+
+KDateTime::Spec getTimeSpec(bool isUtc, const std::string& timezone)
+{
+    if (isUtc) { //UTC
+        return KDateTime::Spec(KDateTime::UTC);
+    }
+    if (timezone.empty()) { //Floating
+        return  KDateTime::Spec(KDateTime::ClockTime);
+    }
+    //Timezone
+
+    //Convert non-olson timezones if necessary
+    const QString normalizedTz = TimezoneConverter::normalizeTimezone(QString::fromStdString(timezone));
+    KTimeZone tz = KSystemTimeZones::zone(normalizedTz); //Needs ktimezoned (timezone daemon running) http://api.kde.org/4.x-api/kdelibs-apidocs/kdecore/html/classKSystemTimeZones.html
+    if (!tz.isValid()) {
+        Warning() << "invalid timezone: " << QString::fromStdString(timezone) << ", assuming floating time";
+        if (!KSystemTimeZones::isTimeZoneDaemonAvailable()) {
+            Error() << "ktimezoned is not available and required for timezone interpretation";
+        }
+        return  KDateTime::Spec(KDateTime::ClockTime);
+    }
+    return KDateTime::Spec(tz);
+}
+
+KDateTime toDate(const Kolab::cDateTime &dt)
+{
+    KDateTime date;
+    if (!dt.isValid()) { //We rely on this codepath, so it's not an error
+        //         qDebug() << "invalid datetime converted";
+        return KDateTime();
+    }
+    if (dt.isDateOnly()) { //Date only
+        date.setDateOnly(true);
+        date.setDate(QDate(dt.year(), dt.month(), dt.day()));
+        date.setTimeSpec(KDateTime::Spec(KDateTime::ClockTime));
+    } else {
+        date.setDate(QDate(dt.year(), dt.month(), dt.day()));
+        date.setTime(QTime(dt.hour(), dt.minute(), dt.second()));
+        date.setTimeSpec(getTimeSpec(dt.isUTC(), dt.timezone()));
+    }
+    Q_ASSERT(date.timeSpec().isValid());
+    Q_ASSERT(date.isValid());
+    return date;
+}
+
+cDateTime fromDate(const KDateTime &dt)
+{
+    if (!dt.isValid()) {
+        //         qDebug() << "invalid datetime converted";
+        return cDateTime();
+    }
+    cDateTime date;
+    if (dt.isDateOnly()) { //Date only
+        const QDate &d = dt.date();
+        date.setDate(d.year(), d.month(), d.day());
+    } else {
+        const QDate &d = dt.date();
+        date.setDate(d.year(), d.month(), d.day());
+        const QTime &t = dt.time();
+        date.setTime(t.hour(), t.minute(), t.second());
+        if (dt.timeType() == KDateTime::UTC) { //UTC
+            date.setUTC(true);
+        } else if (dt.timeType() == KDateTime::OffsetFromUTC) {
+            const KDateTime utcDate = dt.toUtc();
+            const QDate &d = utcDate.date();
+            date.setDate(d.year(), d.month(), d.day());
+            const QTime &t = utcDate.time();
+            date.setTime(t.hour(), t.minute(), t.second());
+            date.setUTC(true);
+        } else if (dt.timeType() == KDateTime::TimeZone) { //Timezone
+            //TODO handle local timezone?
+            //Convert non-olson timezones if necessary
+            const QString timezone = TimezoneConverter::normalizeTimezone(dt.timeZone().name());
+            if (!timezone.isEmpty()) {
+                date.setTimezone(toStdString(timezone));
+            } else {
+                Warning() << "invalid timezone: " << dt.timeZone().name() << ", assuming floating time";
+                return date;
+            }
+        } else if (dt.timeType() != KDateTime::ClockTime) {
+            Error() << "invalid timespec, assuming floating time. Type: " << dt.timeType() << "dt: " << dt.toString();
+            return date;
+        }
+    }
+    Q_ASSERT(date.isValid());
+    return date;
+}
+
+QStringList toStringList(const std::vector<std::string> &l)
+{
+    QStringList list;
+    foreach(const std::string &s, l) {
+        list.append(Conversion::fromStdString(s));
+    }
+    return list;
+}
+
+std::vector<std::string> fromStringList(const QStringList &l)
+{
+    std::vector<std::string> list;
+    foreach(const QString &s, l) {
+        list.push_back(toStdString(s));
+    }
+    return list;
+}
+
+QUrl toMailto(const std::string &email, const std::string &name)
+{
+    std::string mailto;
+    if (!name.empty()) {
+        mailto.append(name);
+    }
+    mailto.append("<");
+    mailto.append(email);
+    mailto.append(">");
+    return QUrl(QString::fromStdString(std::string("mailto:")+mailto));
+}
+
+std::string fromMailto(const QUrl &mailtoUri, std::string &name)
+{
+    const std::string &decoded = toStdString(mailtoUri.toString());
+    if (decoded.substr(0, 7).compare("mailto:")) {
+        WARNING("no mailto address");
+        std::cout << decoded << std::endl;
+        return decoded;
+    }
+    std::size_t begin = decoded.find('<',7);
+    if (begin == std::string::npos) {
+        WARNING("no mailto address");
+        std::cout << decoded << std::endl;
+        return decoded;
+    }
+    std::size_t end = decoded.find('>', begin);
+    if (end == std::string::npos) {
+        WARNING("no mailto address");
+        std::cout << decoded << std::endl;
+        return decoded;
+    }
+    name = decoded.substr(7, begin-7);
+    const std::string &email = decoded.substr(begin+1, end-begin-1);
+    return email;
+}
+
+    }
+}
+
diff --git a/src/conversion/commonconversion.h b/src/conversion/commonconversion.h
new file mode 100644
index 0000000..fd4c191
--- /dev/null
+++ b/src/conversion/commonconversion.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef KOLABCOMMONCONVERSION_H
+#define KOLABCOMMONCONVERSION_H
+
+#include "kolab_export.h"
+
+#include <kdatetime.h>
+#include <QStringList>
+#include <kolabcontainers.h>
+
+
+namespace Kolab {
+    namespace Conversion {
+        KOLAB_EXPORT KDateTime toDate(const Kolab::cDateTime &dt);
+        KOLAB_EXPORT cDateTime fromDate(const KDateTime &dt);
+        QStringList toStringList(const std::vector<std::string> &l);
+        std::vector<std::string> fromStringList(const QStringList &l);
+        /**
+         * Returns a UTC, Floating Time or Timezone
+         */
+        KDateTime::Spec getTimeSpec(bool isUtc, const std::string &timezone);
+
+        QUrl toMailto(const std::string &email, const std::string &name = std::string());
+        std::string fromMailto(const QUrl &mailtoUri, std::string &name);
+        
+        inline std::string toStdString(const QString &s)
+        {
+            return std::string(s.toUtf8().constData());
+        }
+
+        inline QString fromStdString(const std::string &s)
+        {
+            return QString::fromUtf8(s.c_str());
+        }
+
+    };
+};
+
+#endif
\ No newline at end of file
diff --git a/src/conversion/kabcconversion.cpp b/src/conversion/kabcconversion.cpp
new file mode 100644
index 0000000..21be037
--- /dev/null
+++ b/src/conversion/kabcconversion.cpp
@@ -0,0 +1,894 @@
+/*
+ * Copyright (C) 2011  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "kabcconversion.h"
+
+#include "commonconversion.h"
+#include <kdebug.h>
+#include <qbuffer.h>
+#include <qimagereader.h>
+#include "kolabformat/errorhandler.h"
+
+
+
+namespace Kolab {
+    namespace Conversion {
+        
+        //The following was copied from kdepim/libkleo/kleo/enum.h,.cpp
+        enum CryptoMessageFormat {
+            InlineOpenPGPFormat = 1,
+            OpenPGPMIMEFormat = 2,
+            SMIMEFormat = 4,
+            SMIMEOpaqueFormat = 8,
+            AnyOpenPGP = InlineOpenPGPFormat|OpenPGPMIMEFormat,
+            AnySMIME = SMIMEOpaqueFormat|SMIMEFormat,
+            AutoFormat = AnyOpenPGP|AnySMIME
+        };
+
+        enum EncryptionPreference {
+            UnknownPreference = 0,
+            NeverEncrypt = 1,
+            AlwaysEncrypt = 2,
+            AlwaysEncryptIfPossible = 3,
+            AlwaysAskForEncryption = 4,
+            AskWheneverPossible = 5,
+            MaxEncryptionPreference = AskWheneverPossible
+        };
+        
+        enum SigningPreference {
+            UnknownSigningPreference = 0,
+            NeverSign = 1,
+            AlwaysSign = 2,
+            AlwaysSignIfPossible = 3,
+            AlwaysAskForSigning = 4,
+            AskSigningWheneverPossible = 5,
+            MaxSigningPreference = AskSigningWheneverPossible
+        };
+        
+        static const struct {
+            CryptoMessageFormat format;
+            const char * displayName;
+            const char * configName;
+        } cryptoMessageFormats[] = {
+            { InlineOpenPGPFormat,
+            ("Inline OpenPGP (deprecated)"),
+            "inline openpgp" },
+            { OpenPGPMIMEFormat,
+            ("OpenPGP/MIME"),
+            "openpgp/mime" },
+            { SMIMEFormat,
+            ("S/MIME"),
+            "s/mime" },
+            { SMIMEOpaqueFormat,
+            ("S/MIME Opaque"),
+            "s/mime opaque" },
+        };
+        static const unsigned int numCryptoMessageFormats
+        = sizeof cryptoMessageFormats / sizeof *cryptoMessageFormats ;
+        
+        const char * cryptoMessageFormatToString( CryptoMessageFormat f ) {
+            if ( f == AutoFormat )
+                return "auto";
+            for ( unsigned int i = 0 ; i < numCryptoMessageFormats ; ++i )
+                if ( f == cryptoMessageFormats[i].format )
+                    return cryptoMessageFormats[i].configName;
+                return 0;
+        }
+        
+        QStringList cryptoMessageFormatsToStringList( unsigned int f ) {
+            QStringList result;
+            for ( unsigned int i = 0 ; i < numCryptoMessageFormats ; ++i )
+                if ( f & cryptoMessageFormats[i].format )
+                    result.push_back( cryptoMessageFormats[i].configName );
+                return result;
+        }
+        
+        
+        CryptoMessageFormat stringToCryptoMessageFormat( const QString & s ) {
+            const QString t = s.toLower();
+            for ( unsigned int i = 0 ; i < numCryptoMessageFormats ; ++i )
+                if ( t == cryptoMessageFormats[i].configName )
+                    return cryptoMessageFormats[i].format;
+                return AutoFormat;
+        }
+        
+        unsigned int stringListToCryptoMessageFormats( const QStringList & sl ) {
+            unsigned int result = 0;
+            for ( QStringList::const_iterator it = sl.begin() ; it != sl.end() ; ++it )
+                result |= stringToCryptoMessageFormat( *it );
+            return result;
+        }
+        
+        // For the config values used below, see also kaddressbook/editors/cryptowidget.cpp
+        
+        const char* encryptionPreferenceToString( EncryptionPreference pref )
+        {
+            switch( pref ) {
+                case UnknownPreference:
+                    return 0;
+                case NeverEncrypt:
+                    return "never";
+                case AlwaysEncrypt:
+                    return "always";
+                case AlwaysEncryptIfPossible:
+                    return "alwaysIfPossible";
+                case AlwaysAskForEncryption:
+                    return "askAlways";
+                case AskWheneverPossible:
+                    return "askWhenPossible";
+            }
+            return 0; // keep the compiler happy
+        }
+        
+        EncryptionPreference stringToEncryptionPreference( const QString& str )
+        {
+            if ( str == "never" )
+                return NeverEncrypt;
+            if ( str == "always" )
+                return AlwaysEncrypt;
+            if ( str == "alwaysIfPossible" )
+                return AlwaysEncryptIfPossible;
+            if ( str == "askAlways" )
+                return AlwaysAskForEncryption;
+            if ( str == "askWhenPossible" )
+                return AskWheneverPossible;
+            return UnknownPreference;
+        }
+        
+        const char* signingPreferenceToString( SigningPreference pref )
+        {
+            switch( pref ) {
+                case UnknownSigningPreference:
+                    return 0;
+                case NeverSign:
+                    return "never";
+                case AlwaysSign:
+                    return "always";
+                case AlwaysSignIfPossible:
+                    return "alwaysIfPossible";
+                case AlwaysAskForSigning:
+                    return "askAlways";
+                case AskSigningWheneverPossible:
+                    return "askWhenPossible";
+            }
+            return 0; // keep the compiler happy
+        }
+        
+        SigningPreference stringToSigningPreference( const QString& str )
+        {
+            if ( str == "never" )
+                return NeverSign;
+            if ( str == "always" )
+                return AlwaysSign;
+            if ( str == "alwaysIfPossible" )
+                return AlwaysSignIfPossible;
+            if ( str == "askAlways" )
+                return AlwaysAskForSigning;
+            if ( str == "askWhenPossible" )
+                return AskSigningWheneverPossible;
+            return UnknownSigningPreference;
+        }
+
+        
+        
+int fromAddressType(int kabcType, bool &pref)
+{
+    int type = 0;
+    if (kabcType & KABC::Address::Dom) {
+        Warning() << "domestic address is not supported";
+    } 
+    if (kabcType & KABC::Address::Intl) {
+        Warning() << "international address is not supported";
+    } 
+    if (kabcType & KABC::Address::Pref) {
+        pref = true;
+    } 
+    if (kabcType & KABC::Address::Postal) {
+        Warning() << "postal address is not supported";
+    } 
+    if (kabcType & KABC::Address::Parcel) {
+        Warning() << "parcel is not supported";
+    } 
+    if (kabcType & KABC::Address::Home) {
+        type |= Kolab::Address::Home;
+    } 
+    if (kabcType & KABC::Address::Work) {
+        type |= Kolab::Address::Work;
+    } 
+    return type;
+}
+
+KABC::Address::Type toAddressType(int types, bool pref)
+{
+    KABC::Address::Type type = 0;
+    if (pref) {
+        type |= KABC::Address::Pref;
+    } 
+    if (types & Kolab::Address::Home) {
+        type |= KABC::Address::Home;
+    } 
+    if (types & Kolab::Address::Work) {
+        type |= KABC::Address::Work;
+    } 
+    return type;
+}
+        
+int fromPhoneType(int kabcType, bool &pref)
+{
+    int type = 0;
+    if (kabcType & KABC::PhoneNumber::Home) {
+        type |= Kolab::Telephone::Home;
+    } 
+    if (kabcType & KABC::PhoneNumber::Work) {
+        type |= Kolab::Telephone::Work;
+    } 
+    if (kabcType & KABC::PhoneNumber::Msg) {
+        type |= Kolab::Telephone::Text;
+    } 
+    if (kabcType & KABC::PhoneNumber::Pref) {
+        pref = true;
+    } 
+    if (kabcType & KABC::PhoneNumber::Voice) {
+        type |= Kolab::Telephone::Voice;
+    } 
+    if (kabcType & KABC::PhoneNumber::Fax) {
+        type |= Kolab::Telephone::Fax;
+    } 
+    if (kabcType & KABC::PhoneNumber::Cell) {
+        type |= Kolab::Telephone::Cell;
+    } 
+    if (kabcType & KABC::PhoneNumber::Video) {
+        type |= Kolab::Telephone::Video;
+    } 
+    if (kabcType & KABC::PhoneNumber::Bbs) {
+        Warning() << "mailbox number is not supported";
+    } 
+    if (kabcType & KABC::PhoneNumber::Modem) {
+        Warning() << "modem is not supported";
+    } 
+    if (kabcType & KABC::PhoneNumber::Car) {
+        type |= Kolab::Telephone::Car;
+    } 
+    if (kabcType & KABC::PhoneNumber::Isdn) {
+        Warning() << "isdn number is not supported";
+    } 
+    if (kabcType & KABC::PhoneNumber::Pcs) {
+        type |= Kolab::Telephone::Text;
+    } 
+    if (kabcType & KABC::PhoneNumber::Pager) {
+        type |= Kolab::Telephone::Pager;
+    }
+    return type;
+}
+
+KABC::PhoneNumber::Type toPhoneType(int types, bool pref)
+{
+    KABC::PhoneNumber::Type type = 0;
+    if (types & Kolab::Telephone::Home) {
+        type |= KABC::PhoneNumber::Home;
+    } 
+    if (types & Kolab::Telephone::Work) {
+        type |= KABC::PhoneNumber::Work;
+    } 
+    if (types & Kolab::Telephone::Text) {
+        type |= KABC::PhoneNumber::Msg;
+    } 
+    if (pref) {
+        type |= KABC::PhoneNumber::Pref;
+    } 
+    if (types & Kolab::Telephone::Voice) {
+        type |= KABC::PhoneNumber::Voice;
+    } 
+    if (types & Kolab::Telephone::Fax) {
+        type |= KABC::PhoneNumber::Fax;
+    } 
+    if (types & Kolab::Telephone::Cell) {
+        type |= KABC::PhoneNumber::Cell;
+    } 
+    if (types & Kolab::Telephone::Video) {
+        type |= KABC::PhoneNumber::Video;
+    } 
+    if (types & Kolab::Telephone::Car) {
+        type |= KABC::PhoneNumber::Car;
+    } 
+    if (types & Kolab::Telephone::Text) {
+        type |= KABC::PhoneNumber::Pcs;
+    } 
+    if (types & Kolab::Telephone::Pager) {
+        type |= KABC::PhoneNumber::Pager;
+    }
+    return type;
+}
+
+std::string fromPicture(const KABC::Picture &pic, std::string &mimetype)
+{    
+    QByteArray input;
+    QBuffer buffer( &input );
+    buffer.open( QIODevice::WriteOnly );
+    QImage img;
+        
+    
+    if ( pic.isIntern() ) {
+        if ( !pic.data().isNull() ) {
+            img = pic.data();
+        }
+    } else if ( !pic.url().isEmpty() ) {
+        QString tmpFile;
+        kWarning() << "external pictures are currently not supported";
+        //FIXME add kio support to libcalendaring or use libcurl
+//         if ( KIO::NetAccess::download( pic.url(), tmpFile, 0 /*no widget known*/ ) ) {
+//             img.load( tmpFile );
+//             KIO::NetAccess::removeTempFile( tmpFile );
+//         }
+    }
+    if (img.isNull()) {
+        Error() << "invalid picture";
+        return std::string();
+    }
+    if ( !img.hasAlphaChannel() ) {
+        if (!img.save( &buffer, "JPEG" )) {
+            Error() << "error on jpeg save";
+            return std::string();
+        }
+        mimetype = "image/jpeg";
+    } else {
+        if (!img.save( &buffer, "PNG" )) {
+            Error() << "error on png save";
+            return std::string();
+        }
+        mimetype = "image/png";
+    }
+    return std::string(input.data(), input.size());
+}
+
+KABC::Picture toPicture(const std::string &data, const std::string &mimetype) {
+    QImage img;
+    bool ret = false;
+    QByteArray type(mimetype.data(), mimetype.size());
+    type = type.split('/').last(); // extract "jpeg" from "image/jpeg"
+    if (QImageReader::supportedImageFormats().contains(type)) {
+        ret = img.loadFromData(QByteArray::fromRawData(data.data(), data.size()), type.constData());
+    } else {
+        ret = img.loadFromData(QByteArray::fromRawData(data.data(), data.size()));
+    }
+    if (!ret) {
+        Warning() << "failed to load picture";
+        return KABC::Picture();
+    }
+    
+    KABC::Picture logo(img);
+    if (logo.isEmpty()) {
+        Warning() << "failed to read picture";
+        return KABC::Picture();
+    }
+    return logo;
+}
+
+template <typename T>
+void setCustom(const std::string &value, const std::string &id, T &object)
+{
+    std::vector <Kolab::CustomProperty > properties = object.customProperties();
+    properties.push_back(CustomProperty(id, value));
+    object.setCustomProperties(properties);
+}
+
+template <typename T>
+std::string getCustom(const std::string &id, T &object)
+{
+    const std::vector <Kolab::CustomProperty > &properties = object.customProperties();
+    foreach(const Kolab::CustomProperty &prop, properties) {
+        if (prop.identifier == id) {
+            return prop.value;
+        }
+    }
+    return std::string();
+}
+
+static QString emailTypesToStringList(int emailTypes) {
+    QStringList types;
+    if (emailTypes & Kolab::Email::Home) {
+        types << "home";
+    }
+    if (emailTypes & Kolab::Email::Work) {
+        types << "work";
+    }
+    return types.join(",");
+}
+
+static int emailTypesFromStringlist(const QString &types) {
+    int emailTypes = Kolab::Email::NoType;
+    if (types.contains("home")) {
+        emailTypes |= Kolab::Email::Home;
+    }
+    if (types.contains("work")) {
+        emailTypes |= Kolab::Email::Work;
+    }
+    return emailTypes;
+}
+
+KABC::Addressee toKABC(const Kolab::Contact &contact)
+{
+  KABC::Addressee addressee;
+  addressee.setUid(fromStdString(contact.uid()));
+  addressee.setCategories(toStringList(contact.categories()));
+  //addressee.setName(fromStdString(contact.name()));//This one is only for compatiblity (and results in a non-existing name property)
+  addressee.setFormattedName(fromStdString(contact.name())); //This on corresponds to fn
+  
+  const Kolab::NameComponents &nc = contact.nameComponents();
+  if (!nc.surnames().empty()) {
+      addressee.setFamilyName(fromStdString(nc.surnames().front()));
+  }
+  if (!nc.given().empty()) {
+      addressee.setGivenName(fromStdString(nc.given().front()));
+  }
+  if (!nc.additional().empty()) {
+      addressee.setAdditionalName(fromStdString(nc.additional().front()));
+  }
+  if (!nc.prefixes().empty()) {
+      addressee.setPrefix(fromStdString(nc.prefixes().front()));
+  }
+  if (!nc.suffixes().empty()) {
+      addressee.setSuffix(fromStdString(nc.suffixes().front()));
+  }
+  
+  addressee.setNote(fromStdString(contact.note()));
+  
+  addressee.setSecrecy(KABC::Secrecy::Public); //We don't have any privacy setting in xCard
+  
+  
+  QString preferredEmail;
+  
+  if (!contact.emailAddresses().empty()) {
+      QStringList emails;
+      foreach( const Kolab::Email &email, contact.emailAddresses()) {
+          emails << fromStdString(email.address());
+          const QString types = emailTypesToStringList(email.types());
+          if (!types.isEmpty()) {
+              addressee.insertCustom(QLatin1String("KOLAB"), QString::fromLatin1("EmailTypes%1").arg(fromStdString(email.address())), types);
+          }
+      }
+      addressee.setEmails(emails);
+      if ((contact.emailAddressPreferredIndex() >= 0) && (contact.emailAddressPreferredIndex() < static_cast<int>(contact.emailAddresses().size()))) {
+          preferredEmail = fromStdString(contact.emailAddresses().at(contact.emailAddressPreferredIndex()).address());
+      } else {
+          preferredEmail = fromStdString(contact.emailAddresses().at(0).address());
+      }
+      addressee.insertEmail(preferredEmail, true);
+  }
+  
+  if (!contact.freeBusyUrl().empty()) {
+      if (preferredEmail.isEmpty()) {
+          Error() << "f/b url is set but no email address available, skipping";
+      } else  {
+        addressee.insertCustom("KOLAB", "FreebusyUrl", fromStdString(contact.freeBusyUrl()));
+      }
+  }
+  
+  if (!contact.nickNames().empty()) {
+      addressee.setNickName(fromStdString(contact.nickNames().at(0))); //TODO support multiple
+  }
+  
+  if (contact.bDay().isValid()) {
+      addressee.setBirthday(toDate(contact.bDay()).dateTime());
+  }
+  if (!contact.titles().empty()) {
+      addressee.setTitle(fromStdString(contact.titles().at(0))); //TODO support multiple
+  }
+  if (!contact.urls().empty()) {
+      addressee.setUrl(QUrl(fromStdString(contact.urls().at(0).url()))); //TODO support multiple
+      foreach(const Kolab::Url &u, contact.urls()) {
+          if (u.type() == Kolab::Url::Blog) {
+              addressee.insertCustom("KADDRESSBOOK", "BlogFeed", fromStdString(u.url()));
+          }
+      }
+  }
+  
+
+  if (!contact.affiliations().empty()) {
+      //Storing only a const reference leads to segfaults. No idea why.
+      const Kolab::Affiliation aff = contact.affiliations().at(0); //TODO support multiple
+      if (!aff.organisation().empty()) {
+          addressee.setOrganization(fromStdString(aff.organisation()));
+      }
+      if (!aff.organisationalUnits().empty()) {
+          addressee.setDepartment(fromStdString(aff.organisationalUnits().at(0))); //TODO support multiple
+      }
+      if (!aff.roles().empty()) {
+          addressee.setRole(fromStdString(aff.roles().at(0))); //TODO support multiple
+      }
+      if (!aff.logo().empty()) {
+          addressee.setLogo(toPicture(aff.logo(), aff.logoMimetype()));
+      }
+      foreach(const Kolab::Related &related, aff.relateds()) {
+          if (related.type() != Kolab::Related::Text) {
+              Error() << "invalid relation type";
+              continue;
+          }
+          if (related.relationTypes() & Kolab::Related::Assistant) {
+              addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-AssistantsName"), fromStdString(related.text()));
+          }
+          if (related.relationTypes() & Kolab::Related::Manager) {
+              addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-ManagersName"), fromStdString(related.text()));
+          }
+      }
+      foreach(const Kolab::Address &address, aff.addresses()) {
+          addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Office"), fromStdString(address.label())); //TODO support proper addresses
+      }
+  }
+  const std::string &prof = getCustom("X-Profession", contact);
+  if (!prof.empty()) {
+    addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Profession"), fromStdString(prof));
+  }
+  
+  const std::string &adrBook = getCustom("X-AddressBook", contact);
+  if (!adrBook.empty()) {
+      addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-AddressBook"), fromStdString(prof));
+  }
+  
+  if (!contact.photo().empty()) {
+      addressee.setPhoto(toPicture(contact.photo(), contact.photoMimetype()));
+  }
+  
+  if (!contact.telephones().empty()) {
+      int index = 0;
+      foreach(const Kolab::Telephone &tel, contact.telephones()) {
+          bool pref = false;
+          if (index == contact.telephonesPreferredIndex()) {
+              pref = true;
+          }
+          KABC::PhoneNumber number(fromStdString(tel.number()), toPhoneType(tel.types(), pref));
+          index++;
+          addressee.insertPhoneNumber(number);
+      }
+  }
+  
+  if (!contact.addresses().empty()) {
+      int index = 0;
+      foreach(const Kolab::Address &a, contact.addresses()) {
+          bool pref = false;
+          if (index == contact.addressPreferredIndex()) {
+              pref = true;
+          }
+          KABC::Address adr(toAddressType(a.types(), pref));          
+          adr.setLabel(fromStdString(a.label()));
+          adr.setStreet(fromStdString(a.street()));
+          adr.setLocality(fromStdString(a.locality()));
+          adr.setRegion(fromStdString(a.region()));
+          adr.setPostalCode(fromStdString(a.code()));
+          adr.setCountry(fromStdString(a.country()));
+          
+          index++;
+          addressee.insertAddress(adr);
+      }
+  }
+  
+  if (contact.anniversary().isValid()) {
+      addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Anniversary"), toDate(contact.anniversary()).toString(KDateTime::ISODate));
+  }
+  
+  if (!contact.imAddresses().empty()) {
+      addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-IMAddress"),fromStdString(contact.imAddresses()[0])); //TODO support multiple
+  }
+  
+  if (!contact.relateds().empty()) {
+      foreach(const Kolab::Related &rel, contact.relateds()) {
+          if (rel.type() != Kolab::Related::Text) {
+              Error() << "relation type not supported";
+              continue;
+          }
+          if (rel.relationTypes() & Kolab::Related::Spouse) {
+              addressee.insertCustom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-SpousesName"),fromStdString(rel.text())); //TODO support multiple
+          } else {
+              Warning() << "relation not supported";
+              continue;
+          }
+      }
+  }
+  
+  return addressee;
+}
+
+Kolab::Contact fromKABC(const KABC::Addressee &addressee)
+{
+    int prefNum = -1;
+    int prefCounter = -1;
+    Kolab::Contact c;
+    c.setUid(toStdString(addressee.uid()));
+    c.setCategories(fromStringList(addressee.categories()));
+    c.setName(toStdString(addressee.formattedName()));
+    Kolab::NameComponents nc;
+    nc.setSurnames(std::vector<std::string>() << toStdString(addressee.familyName()));
+    nc.setGiven(std::vector<std::string>() << toStdString(addressee.givenName()));
+    nc.setAdditional(std::vector<std::string>() << toStdString(addressee.additionalName()));
+    nc.setPrefixes(std::vector<std::string>() << toStdString(addressee.prefix()));
+    nc.setSuffixes(std::vector<std::string>() << toStdString(addressee.suffix()));
+    c.setNameComponents(nc);
+    
+    c.setNote(toStdString(addressee.note()));
+    c.setFreeBusyUrl(toStdString(addressee.custom("KOLAB", QString("FreebusyUrl"))));
+
+    if (!addressee.title().isEmpty()) {
+        c.setTitles(std::vector<std::string>() << toStdString(addressee.title()));
+    }
+    
+    Kolab::Affiliation businessAff;
+    businessAff.setOrganisation(toStdString(addressee.organization()));
+    if (!addressee.department().isEmpty()) {
+        Debug() << addressee.department() << addressee.department().toLatin1() << addressee.department().toUtf8();
+        businessAff.setOrganisationalUnits(std::vector<std::string>() << toStdString(addressee.department()));
+    }
+
+    if (!addressee.logo().isEmpty()) {
+        std::string logoMimetype;
+        const std::string &logo = fromPicture(addressee.logo(), logoMimetype);
+        businessAff.setLogo(logo, logoMimetype);
+    }
+    if (!addressee.role().isEmpty()) {
+        businessAff.setRoles(std::vector<std::string>() << toStdString(addressee.role()));
+    }
+    const QString &office = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Office"));
+    if (!office.isEmpty()) {
+        Kolab::Address a;
+        a.setTypes(Kolab::Address::Work);
+        a.setLabel(toStdString(addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Office"))));
+        businessAff.setAddresses(std::vector<Kolab::Address>() << a);
+    }
+    
+    std::vector<Kolab::Related> relateds;
+    const QString &manager = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-ManagersName"));
+    if (!manager.isEmpty()) {
+        relateds.push_back(Kolab::Related(Kolab::Related::Text, toStdString(manager), Kolab::Related::Manager));
+    }
+    const QString &assistant = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-AssistantsName"));
+    if (!assistant.isEmpty()) {
+        relateds.push_back(Kolab::Related(Kolab::Related::Text, toStdString(assistant), Kolab::Related::Assistant));
+    }
+    if (!relateds.empty()) {
+        businessAff.setRelateds(relateds);
+    }
+    if (!(businessAff == Kolab::Affiliation())) {
+        c.setAffiliations(std::vector<Kolab::Affiliation>() << businessAff);
+    }
+    
+    std::vector<Kolab::Url> urls;
+    if (!addressee.url().isEmpty()) {
+        urls.push_back(Kolab::Url(toStdString(addressee.url().url())));
+    }   
+    const QString &blogUrl = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("BlogFeed"));
+    if (!blogUrl.isEmpty()) {
+        urls.push_back(Kolab::Url(toStdString(blogUrl), Kolab::Url::Blog));
+    }
+    c.setUrls(urls);
+    
+    std::vector<Kolab::Address> addresses;
+    prefNum = -1;
+    prefCounter = -1;
+    foreach(const KABC::Address &a, addressee.addresses()) {
+        Kolab::Address adr;
+        bool pref = false;
+        adr.setTypes(fromAddressType(a.type(), pref));
+        prefCounter++;
+        if (pref) {
+            prefNum = prefCounter;
+        }
+        adr.setLabel(toStdString(a.label()));
+        adr.setStreet(toStdString(a.street()));
+        adr.setLocality(toStdString(a.locality()));
+        adr.setRegion(toStdString(a.region()));
+        adr.setCode(toStdString(a.postalCode()));
+        adr.setCountry(toStdString(a.country()));
+        addresses.push_back(adr);
+    }
+    c.setAddresses(addresses, prefNum);
+    
+    if (!addressee.nickName().isEmpty()) {
+        c.setNickNames(std::vector<std::string>() << toStdString(addressee.nickName()));
+    }
+    
+    const QString &spouse = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-SpousesName"));
+    if (!spouse.isEmpty()) {
+        c.setRelateds(std::vector<Kolab::Related>() << Kolab::Related(Kolab::Related::Text, toStdString(spouse), Kolab::Related::Spouse));
+    }
+    c.setBDay(fromDate(KDateTime(addressee.birthday(), KDateTime::ClockTime)));
+    c.setAnniversary(fromDate(KDateTime(QDate::fromString( addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-Anniversary")), Qt::ISODate ), KDateTime::ClockTime)));
+    if (!addressee.photo().isEmpty()) {
+        std::string mimetype;
+        const std::string &photo = fromPicture(addressee.photo(), mimetype);
+        c.setPhoto(photo, mimetype);
+    }
+    //TODO
+//     c.setGender();
+//     c.setLanguages();
+
+    std::vector <Kolab::Telephone> phones;
+    prefNum = -1;
+    prefCounter = -1;
+    foreach (const KABC::PhoneNumber &n, addressee.phoneNumbers()) {
+        Kolab::Telephone p;
+        p.setNumber(toStdString(n.number()));
+        bool pref = false;
+        p.setTypes(fromPhoneType(n.type(), pref));
+        prefCounter++;
+        if (pref) {
+            prefNum = prefCounter;
+        }
+        phones.push_back(p);
+    }
+    c.setTelephones(phones, prefNum);
+    
+    const QString &imAddress = addressee.custom(QLatin1String("KADDRESSBOOK"), QLatin1String("X-IMAddress"));
+    if (!imAddress.isEmpty()) {
+        c.setIMaddresses(std::vector<std::string>() << toStdString(imAddress), 0);
+    }
+    
+    int prefEmail = -1;
+    int count = 0;
+    std::vector<Kolab::Email> emails;
+    foreach(const QString &e, addressee.emails()) {
+        if ((prefEmail == -1) && (e == addressee.preferredEmail())) {
+            prefEmail = count;
+        }
+        count++;
+        emails.push_back(Kolab::Email(toStdString(e), emailTypesFromStringlist(addressee.custom(QLatin1String("KOLAB"), QString::fromLatin1("EmailTypes%1").arg(e)))));
+    }
+    c.setEmailAddresses(emails, prefEmail);
+    if (addressee.geo().isValid()) {
+        c.setGPSpos(std::vector<Kolab::Geo>() << Kolab::Geo(addressee.geo().latitude(), addressee.geo().longitude()));
+    }
+    
+    Kolab::Crypto crypto;
+    
+    const QStringList protocolPrefs = addressee.custom( "KADDRESSBOOK", "CRYPTOPROTOPREF" ).split( ',', QString::SkipEmptyParts );
+    const uint cryptoFormats = stringListToCryptoMessageFormats( protocolPrefs );
+    int formats = 0;
+    if (cryptoFormats & InlineOpenPGPFormat) {
+        formats |= Kolab::Crypto::PGPinline;
+    }
+    if (cryptoFormats & OpenPGPMIMEFormat) {
+        formats |= Kolab::Crypto::PGPmime;
+    }
+    if (cryptoFormats & SMIMEFormat) {
+        formats |= Kolab::Crypto::SMIME;
+    }
+    if (cryptoFormats & SMIMEOpaqueFormat) {
+        formats |= Kolab::Crypto::SMIMEopaque;
+    }
+    crypto.setAllowed(formats);
+    
+    Kolab::Crypto::CryptoPref signPref = Kolab::Crypto::Ask;
+    switch (stringToSigningPreference(addressee.custom( "KADDRESSBOOK", "CRYPTOSIGNPREF" ) )) {
+        case NeverSign:
+            signPref = Kolab::Crypto::Never;
+            break;
+        case AlwaysSign:
+            signPref = Kolab::Crypto::Always;
+            break;
+        case AlwaysSignIfPossible:
+            signPref = Kolab::Crypto::IfPossible;
+            break;
+        case AlwaysAskForSigning:
+        case AskSigningWheneverPossible:
+            signPref = Kolab::Crypto::Ask;
+            break;
+        default:
+            signPref = Kolab::Crypto::Ask;
+    }
+    crypto.setSignPref(signPref);
+    
+    Kolab::Crypto::CryptoPref encryptPref = Kolab::Crypto::Ask;
+    switch (stringToSigningPreference(addressee.custom( "KADDRESSBOOK", "CRYPTOENCRYPTPREF" ) )) {
+        case NeverEncrypt:
+            encryptPref = Kolab::Crypto::Never;
+            break;
+        case AlwaysEncrypt:
+            encryptPref = Kolab::Crypto::Always;
+            break;
+        case AlwaysEncryptIfPossible:
+            encryptPref = Kolab::Crypto::IfPossible;
+            break;
+        case AlwaysAskForEncryption:
+        case AskWheneverPossible:
+            encryptPref = Kolab::Crypto::Ask;
+            break;
+        default:
+            encryptPref = Kolab::Crypto::Ask;
+    }
+    crypto.setEncryptPref(encryptPref);
+    
+    c.setCrypto(crypto);
+    
+    
+    //FIXME the keys are most certainly worng, look at cryptopageplugin.cpp
+    std::vector<Kolab::Key> keys;
+    const std::string &pgpkey = toStdString(addressee.custom( "KADDRESSBOOK", "OPENPGPFP" ));
+    if (!pgpkey.empty()) {
+        keys.push_back(Kolab::Key(pgpkey, Kolab::Key::PGP));
+    }
+    const std::string &smimekey = toStdString(addressee.custom( "KADDRESSBOOK", "SMIMEFP" ));
+    if (!smimekey.empty()) {
+        keys.push_back(Kolab::Key(smimekey, Kolab::Key::PKCS7_MIME));
+    }
+    c.setKeys(keys);
+    
+    
+    if (!addressee.sound().isEmpty()) {
+        Warning() << "sound is not supported";
+    }
+    
+    const std::string &profession = toStdString(addressee.custom( "KADDRESSBOOK", "X-Profession" ));
+    if (!profession.empty()) {
+        setCustom(profession, "X-Profession", c);
+    }
+    
+    const std::string &adrBook = toStdString(addressee.custom( "KADDRESSBOOK", "X-AddressBook" ));
+    if (!adrBook.empty()) {
+        setCustom(adrBook, "X-AddressBook", c);
+    }
+    
+    //TODO preserve all custom properties (also such which are unknown to us)
+        
+    return c;
+}
+
+DistList fromKABC(const KABC::ContactGroup &cg)
+{
+    DistList dl;
+    dl.setName(toStdString(cg.name()));
+    dl.setUid(toStdString(cg.id()));
+    
+    std::vector <Kolab::ContactReference > members;
+    for (unsigned int i = 0; i < cg.dataCount(); i++) {
+        const KABC::ContactGroup::Data &data = cg.data(i);
+        members.push_back(Kolab::ContactReference(Kolab::ContactReference::EmailReference, toStdString(data.email()), toStdString(data.name())));
+    }
+    for (unsigned int i = 0; i < cg.contactReferenceCount(); i++) {
+        const KABC::ContactGroup::ContactReference &ref = cg.contactReference(i);
+        members.push_back(Kolab::ContactReference(Kolab::ContactReference::UidReference, toStdString(ref.uid())));
+    }
+    
+    if (cg.contactGroupReferenceCount() > 0) {
+        kWarning() << "Tried to save contact group references, which should have been resolved already";
+    }
+    
+    dl.setMembers(members);
+    
+    return dl;
+}
+
+KABC::ContactGroup toKABC(const DistList &dl)
+{
+    KABC::ContactGroup cg(fromStdString(dl.name()));
+    cg.setId(fromStdString(dl.uid()));
+    foreach(const Kolab::ContactReference &m, dl.members()) {
+        switch (m.type()) {
+            case Kolab::ContactReference::EmailReference:
+                cg.append(KABC::ContactGroup::Data(fromStdString(m.name()), fromStdString(m.email())));
+                break;
+            case Kolab::ContactReference::UidReference:
+                cg.append(KABC::ContactGroup::ContactReference(fromStdString(m.uid())));
+                break;
+            default:
+                Error() << "invalid contact reference";
+        }
+    }
+    
+    return cg;
+}
+
+
+    } //Namespace
+} //Namespace
diff --git a/src/conversion/kabcconversion.h b/src/conversion/kabcconversion.h
new file mode 100644
index 0000000..0b7863a
--- /dev/null
+++ b/src/conversion/kabcconversion.h
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef KOLABKABCCONVERSION_H
+#define KOLABKABCCONVERSION_H
+
+#include "kolab_export.h"
+
+#include <kolabcontact.h>
+#include <kabc/addressee.h>
+#include <kabc/contactgroup.h>
+
+namespace Kolab {
+    /**
+     * Conversion of Kolab-Containers to/from KABC Containers.
+     *
+     */
+    namespace Conversion {
+
+        KOLAB_EXPORT KABC::Addressee toKABC(const Kolab::Contact &);
+        KOLAB_EXPORT Kolab::Contact fromKABC(const KABC::Addressee &);
+        
+        KOLAB_EXPORT KABC::ContactGroup toKABC(const Kolab::DistList &);
+        KOLAB_EXPORT Kolab::DistList fromKABC(const KABC::ContactGroup &);
+
+    };
+};
+
+#endif
diff --git a/src/conversion/kcalconversion.cpp b/src/conversion/kcalconversion.cpp
new file mode 100644
index 0000000..bec4478
--- /dev/null
+++ b/src/conversion/kcalconversion.cpp
@@ -0,0 +1,859 @@
+/*
+ * Copyright (C) 2011  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include "kcalconversion.h"
+
+#include <kcalcore/recurrence.h>
+#include <QtCore/QBitArray>
+#include <QtCore/QVector>
+#include <QtCore/QDebug>
+#include <QUrl>
+#include <QDate>
+#include <vector>
+
+#include "kolabformat/errorhandler.h"
+#include "commonconversion.h"
+
+namespace Kolab {
+    namespace Conversion {
+
+//The uid of a contact which refers to the uuid of a contact in the addressbook
+#define CUSTOM_KOLAB_CONTACT_UUID "X_KOLAB_CONTACT_UUID"
+#define CUSTOM_KOLAB_CONTACT_CUTYPE "X_KOLAB_CONTACT_CUTYPE"
+#define CUSTOM_KOLAB_URL "X-KOLAB-URL"
+
+KCalCore::Duration toDuration(const Kolab::Duration &d)
+{
+    int value = 0;
+    if (d.hours() || d.minutes() || d.seconds()) {
+        value = ((((d.weeks() * 7 + d.days()) * 24 + d.hours()) * 60 + d.minutes()) * 60 + d.seconds());
+        if (d.isNegative()) {
+            value = -value;
+        }
+        return KCalCore::Duration(value);
+    }
+    value = d.weeks() * 7 + d.days();
+    if (d.isNegative()) {
+        value = -value;
+    }
+    return KCalCore::Duration(value, KCalCore::Duration::Days);
+}
+
+Kolab::Duration fromDuration(const KCalCore::Duration &d)
+{
+    int value = d.value();
+    bool isNegative = false;
+    if (value < 0) {
+        isNegative = true;
+        value = -value;
+    }
+    //We don't know how the seconds/days were distributed before, so no point in distributing them (probably)
+    if (d.isDaily()) {
+        int days = value;
+        return Kolab::Duration(days, 0, 0, 0, isNegative);
+    }
+    int seconds = value;
+//         int minutes = seconds / 60;
+//         seconds = seconds % 60;
+//         int hours = minutes / 60;
+//         minutes = minutes % 60;
+    return Kolab::Duration(0, 0, 0, seconds, isNegative);
+
+}
+
+KCalCore::Incidence::Secrecy toSecrecy(Kolab::Classification c)
+{
+    switch(c) {
+        case Kolab::ClassPublic:
+            return KCalCore::Incidence::SecrecyPublic;
+        case Kolab::ClassPrivate:
+            return KCalCore::Incidence::SecrecyPrivate;
+        case Kolab::ClassConfidential:
+            return KCalCore::Incidence::SecrecyConfidential;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return KCalCore::Incidence::SecrecyPublic;
+}
+
+Kolab::Classification fromSecrecy(KCalCore::Incidence::Secrecy c)
+{
+    switch(c) {
+        case KCalCore::Incidence::SecrecyPublic:
+            return Kolab::ClassPublic;
+        case KCalCore::Incidence::SecrecyPrivate:
+            return Kolab::ClassPrivate;
+        case KCalCore::Incidence::SecrecyConfidential:
+            return Kolab::ClassConfidential;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return Kolab::ClassPublic;
+}
+
+int toPriority(int priority)
+{
+    //Same mapping
+    return priority;
+}
+
+int fromPriority(int priority)
+{
+    //Same mapping
+    return priority;
+}
+
+KCalCore::Incidence::Status toStatus(Kolab::Status s)
+{
+    switch (s) {
+        case StatusUndefined:
+            return  KCalCore::Incidence::StatusNone;
+        case StatusNeedsAction:
+            return  KCalCore::Incidence::StatusNeedsAction;
+        case StatusCompleted:
+            return  KCalCore::Incidence::StatusCompleted;
+        case StatusInProcess:
+            return  KCalCore::Incidence::StatusInProcess;
+        case StatusCancelled:
+            return  KCalCore::Incidence::StatusCanceled;
+        case StatusTentative:
+            return  KCalCore::Incidence::StatusTentative;
+        case StatusConfirmed:
+            return  KCalCore::Incidence::StatusConfirmed;
+        case StatusDraft:
+            return  KCalCore::Incidence::StatusDraft;
+        case StatusFinal:
+            return  KCalCore::Incidence::StatusFinal;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return KCalCore::Incidence::StatusNone;
+}
+
+Kolab::Status fromStatus(KCalCore::Incidence::Status s)
+{
+    switch (s) {
+        case KCalCore::Incidence::StatusNone:
+            return StatusUndefined;
+        case KCalCore::Incidence::StatusNeedsAction:
+            return StatusNeedsAction;
+        case KCalCore::Incidence::StatusCompleted:
+            return StatusCompleted;
+        case KCalCore::Incidence::StatusInProcess:
+            return StatusInProcess;
+        case KCalCore::Incidence::StatusCanceled:
+            return StatusCancelled;
+        case KCalCore::Incidence::StatusTentative:
+            return StatusTentative;
+        case KCalCore::Incidence::StatusConfirmed:
+            return StatusConfirmed;
+        case KCalCore::Incidence::StatusDraft:
+            return StatusDraft;
+        case KCalCore::Incidence::StatusFinal:
+            return StatusFinal;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return StatusUndefined;
+}
+
+KCalCore::Attendee::PartStat toPartStat(Kolab::PartStatus p)
+{
+    switch (p) {
+        case PartNeedsAction:
+            return KCalCore::Attendee::NeedsAction;
+        case PartAccepted:
+            return KCalCore::Attendee::Accepted;
+        case PartDeclined:
+            return KCalCore::Attendee::Declined;
+        case PartTentative:
+            return KCalCore::Attendee::Tentative;
+        case PartDelegated:
+            return KCalCore::Attendee::Delegated;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return KCalCore::Attendee::NeedsAction;
+}
+
+Kolab::PartStatus fromPartStat(KCalCore::Attendee::PartStat p)
+{
+    switch (p) {
+        case KCalCore::Attendee::NeedsAction:
+            return PartNeedsAction;
+        case KCalCore::Attendee::Accepted:
+            return PartAccepted;
+        case KCalCore::Attendee::Declined:
+            return PartDeclined;
+        case KCalCore::Attendee::Tentative:
+            return PartTentative;
+        case KCalCore::Attendee::Delegated:
+            return PartDelegated;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return PartNeedsAction;
+}
+
+KCalCore::Attendee::Role toRole(Kolab::Role r)
+{
+    switch (r) {
+        case Required:
+            return KCalCore::Attendee::ReqParticipant;
+        case Chair:
+            return KCalCore::Attendee::Chair;
+        case Optional:
+            return KCalCore::Attendee::OptParticipant;
+        case NonParticipant:
+            return KCalCore::Attendee::NonParticipant;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return KCalCore::Attendee::ReqParticipant;
+}
+
+Kolab::Role fromRole(KCalCore::Attendee::Role r)
+{
+    switch (r) {
+        case KCalCore::Attendee::ReqParticipant:
+            return Required;
+        case KCalCore::Attendee::Chair:
+            return Chair;
+        case KCalCore::Attendee::OptParticipant:
+            return Optional;
+        case KCalCore::Attendee::NonParticipant:
+            return NonParticipant;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return Required;
+}
+
+template <typename T>
+QString getCustomProperty(const QString &id, const T &e)
+{
+    std::vector<CustomProperty> &props = e.customProperties();
+    foreach (const CustomProperty &p, props) {
+        if (fromStdString(p.identifier) == id) {
+            return fromStdString(p.value);
+        }
+    }
+}
+
+template <typename T>
+void setIncidence(KCalCore::Incidence &i, const T &e)
+{
+    if (!e.uid().empty()) {
+        i.setUid(fromStdString(e.uid()));
+    }
+    
+    i.setCreated(toDate(e.created()));
+    i.setLastModified(toDate(e.lastModified()));
+    i.setRevision(e.sequence());
+    i.setSecrecy(toSecrecy(e.classification()));
+    i.setCategories(toStringList(e.categories()));
+    
+    if (e.start().isValid()) {
+        i.setDtStart(toDate(e.start()));
+    }
+
+    i.setSummary(fromStdString(e.summary())); //TODO detect richtext
+    i.setDescription(fromStdString(e.description())); //TODO detect richtext
+    i.setStatus(toStatus(e.status()));
+    foreach (const Kolab::Attendee a, e.attendees()) {
+        /*
+         * KCalCore always sets a UID if empty, but that's just a pointer, and not the uid of a real contact.
+         * Since that means the semantics of the two are different, we have to store the kolab uid as a custom property.
+         */
+        KCalCore::Attendee::Ptr attendee = KCalCore::Attendee::Ptr(new KCalCore::Attendee(fromStdString(a.contact().name()), 
+                                                                                          fromStdString(a.contact().email()),
+                                                                                          a.rsvp(),
+                                                                                          toPartStat(a.partStat()),
+                                                                                          toRole(a.role()) ));
+        if (!a.contact().uid().empty()) { //TODO Identify contact from addressbook based on uid
+            attendee->customProperties().setNonKDECustomProperty(CUSTOM_KOLAB_CONTACT_UUID, fromStdString(a.contact().uid()));
+        }
+        if (!a.delegatedTo().empty()) {
+            if (a.delegatedTo().size() > 1) {
+                WARNING("multiple delegatees are not supported");
+            }
+            attendee->setDelegate(toMailto(a.delegatedTo().front().email(), a.delegatedTo().front().name()).toString());
+        }
+        if (!a.delegatedFrom().empty()) {
+            if (a.delegatedFrom().size() > 1) {
+                WARNING("multiple delegators are not supported");
+            }
+            attendee->setDelegator(toMailto(a.delegatedFrom().front().email(), a.delegatedFrom().front().name()).toString());
+        }
+        if (!a.cutype() != CutypeIndividual) {
+            attendee->customProperties().setNonKDECustomProperty(CUSTOM_KOLAB_CONTACT_CUTYPE, QString::number(a.cutype()));
+        }
+        i.addAttendee(attendee);
+    }
+    foreach (const Kolab::Attachment a, e.attachments()) {
+        KCalCore::Attachment::Ptr ptr;
+        if (!a.uri().empty()) {
+            ptr = KCalCore::Attachment::Ptr(new KCalCore::Attachment(fromStdString(a.uri()), fromStdString(a.mimetype())));
+        } else {
+            ptr = KCalCore::Attachment::Ptr(new KCalCore::Attachment(QByteArray::fromRawData(a.data().c_str(), a.data().size()), fromStdString(a.mimetype())));
+        }
+        if (!a.label().empty()) {
+            ptr->setLabel(fromStdString(a.label()));
+        }
+        i.addAttachment(ptr);
+    }
+
+    QMap<QByteArray, QString> props;
+    foreach (const Kolab::CustomProperty &prop, e.customProperties()) {
+        QString key;
+        if (prop.identifier.compare(0, 5, "X-KDE")) {
+            key.append(QString::fromLatin1("X-KOLAB-"));
+        }
+        key.append(fromStdString(prop.identifier));
+        props.insert(key.toLatin1(), fromStdString(prop.value));
+//         i.setCustomProperty("KOLAB", fromStdString(prop.identifier).toLatin1(), fromStdString(prop.value));
+    }
+    i.setCustomProperties(props);
+}
+
+template <typename T, typename I>
+void getIncidence(T &i, const I &e)
+{
+    i.setUid(toStdString(e.uid()));
+    i.setCreated(fromDate(e.created()));
+    i.setLastModified(fromDate(e.lastModified()));
+    i.setSequence(e.revision());
+    i.setClassification(fromSecrecy(e.secrecy()));
+    i.setCategories(fromStringList(e.categories()));
+    
+    i.setStart(fromDate(e.dtStart()));
+    i.setSummary(toStdString(e.summary()));
+    i.setDescription(toStdString(e.description()));
+    i.setStatus(fromStatus(e.status()));
+    std::vector<Kolab::Attendee> attendees;
+    foreach (const KCalCore::Attendee::Ptr ptr, e.attendees()) {
+        const QString &uid = ptr->customProperties().nonKDECustomProperty(CUSTOM_KOLAB_CONTACT_UUID);
+        Kolab::Attendee a(Kolab::ContactReference(toStdString(ptr->email()), toStdString(ptr->name()), toStdString(uid)));
+        a.setRSVP(ptr->RSVP());
+        a.setPartStat(fromPartStat(ptr->status()));
+        a.setRole(fromRole(ptr->role()));
+        if (!ptr->delegate().isEmpty()) {
+            std::string name;
+            const std::string &email = fromMailto(QUrl(ptr->delegate()), name);
+            a.setDelegatedTo(std::vector<Kolab::ContactReference>() << Kolab::ContactReference(email, name));
+        }
+        if (!ptr->delegator().isEmpty()) {
+            std::string name;
+            const std::string &email = fromMailto(QUrl(ptr->delegator()), name);
+            a.setDelegatedFrom(std::vector<Kolab::ContactReference>() << Kolab::ContactReference(email, name));
+        }
+        const QString &cutype = ptr->customProperties().nonKDECustomProperty(CUSTOM_KOLAB_CONTACT_CUTYPE);
+        if (!cutype.isEmpty()) {
+            a.setCutype(static_cast<Kolab::Cutype>(cutype.toInt()));
+        }
+        
+        attendees.push_back(a);
+    }
+    i.setAttendees(attendees);
+    std::vector<Kolab::Attachment> attachments;
+    foreach (const KCalCore::Attachment::Ptr &ptr, e.attachments()) {
+        Kolab::Attachment a;
+        if (ptr->isUri()) {
+            a.setUri(toStdString(ptr->uri()), toStdString(ptr->mimeType()));
+        } else {
+            a.setData(std::string(ptr->decodedData().data(), ptr->decodedData().size()), toStdString(ptr->mimeType()));
+        }
+        a.setLabel(toStdString(ptr->label()));
+        attachments.push_back(a);
+    }
+    i.setAttachments(attachments);
+
+    std::vector<Kolab::CustomProperty> customProperties;
+    const QMap<QByteArray, QString> &props = e.customProperties();
+    for (QMap<QByteArray, QString>::const_iterator it = props.begin(); it != props.end(); it++) {
+        QString key(it.key());
+        if (key == QLatin1String(CUSTOM_KOLAB_URL)) {
+            continue;
+        }
+        customProperties.push_back(Kolab::CustomProperty(toStdString(key.remove("X-KOLAB-")), toStdString(it.value())));
+    }
+    i.setCustomProperties(customProperties);
+}
+
+int toWeekDay(Kolab::Weekday wday)
+{
+    switch (wday) {
+        case Kolab::Monday:
+            return  1;
+        case Kolab::Tuesday:
+            return 2;
+        case Kolab::Wednesday:
+            return 3;
+        case Kolab::Thursday:
+            return 4;
+        case Kolab::Friday:
+            return 5;
+        case Kolab::Saturday:
+            return 6;
+        case Kolab::Sunday:
+            return 7;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return 1;
+}
+
+Kolab::Weekday fromWeekDay(int wday)
+{
+    switch (wday) {
+        case 1:
+            return Kolab::Monday;
+        case 2:
+            return Kolab::Tuesday;
+        case 3:
+            return Kolab::Wednesday;
+        case 4:
+            return Kolab::Thursday;
+        case 5:
+            return Kolab::Friday;
+        case 6:
+            return Kolab::Saturday;
+        case 7:
+            return Kolab::Sunday;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return Kolab::Monday;
+}
+
+KCalCore::RecurrenceRule::PeriodType toRecurrenceType(Kolab::RecurrenceRule::Frequency freq)
+{
+    switch(freq) {
+        case Kolab::RecurrenceRule::FreqNone:
+            Warning() << "no recurrence?";
+            break;
+        case Kolab::RecurrenceRule::Yearly:
+            return KCalCore::RecurrenceRule::rYearly;
+        case Kolab::RecurrenceRule::Monthly:
+            return KCalCore::RecurrenceRule::rMonthly;
+        case Kolab::RecurrenceRule::Weekly:
+            return KCalCore::RecurrenceRule::rWeekly;
+        case Kolab::RecurrenceRule::Daily:
+            return KCalCore::RecurrenceRule::rDaily;
+        case Kolab::RecurrenceRule::Hourly:
+            return KCalCore::RecurrenceRule::rHourly;
+        case Kolab::RecurrenceRule::Minutely:
+            return KCalCore::RecurrenceRule::rMinutely;
+        case Kolab::RecurrenceRule::Secondly:
+            return KCalCore::RecurrenceRule::rSecondly;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return KCalCore::RecurrenceRule::rNone;
+}
+
+Kolab::RecurrenceRule::Frequency fromRecurrenceType(KCalCore::RecurrenceRule::PeriodType freq)
+{
+    switch(freq) {
+        case KCalCore::RecurrenceRule::rNone:
+            Warning() << "no recurrence?";
+            break;
+        case KCalCore::RecurrenceRule::rYearly:
+            return Kolab::RecurrenceRule::Yearly;
+        case KCalCore::RecurrenceRule::rMonthly:
+            return Kolab::RecurrenceRule::Monthly;
+        case KCalCore::RecurrenceRule::rWeekly:
+            return Kolab::RecurrenceRule::Weekly;
+        case KCalCore::RecurrenceRule::rDaily:
+            return Kolab::RecurrenceRule::Daily;
+        case KCalCore::RecurrenceRule::rHourly:
+            return Kolab::RecurrenceRule::Hourly;
+        case KCalCore::RecurrenceRule::rMinutely:
+            return Kolab::RecurrenceRule::Minutely;
+        case KCalCore::RecurrenceRule::rSecondly:
+            return Kolab::RecurrenceRule::Secondly;
+        default:
+            Error() << "unhandled";
+            Q_ASSERT(0);
+    }
+    return Kolab::RecurrenceRule::FreqNone;
+}
+
+KCalCore::RecurrenceRule::WDayPos toWeekDayPos(const Kolab::DayPos &dp)
+{
+    return KCalCore::RecurrenceRule::WDayPos(dp.occurence(), toWeekDay(dp.weekday()));
+}
+
+Kolab::DayPos fromWeekDayPos(const KCalCore::RecurrenceRule::WDayPos &dp)
+{
+    return Kolab::DayPos(dp.pos(), fromWeekDay(dp.day()));
+}
+
+template <typename T>
+void setRecurrence(KCalCore::Incidence &e, const T &event)
+{
+    const Kolab::RecurrenceRule &rrule = event.recurrenceRule();
+    if (rrule.isValid()) {
+        KCalCore::Recurrence *rec = e.recurrence();
+        
+        KCalCore::RecurrenceRule *defaultRR = rec->defaultRRule(true);
+        Q_ASSERT(defaultRR);
+        
+        defaultRR->setWeekStart(toWeekDay(rrule.weekStart()));
+        defaultRR->setRecurrenceType(toRecurrenceType(rrule.frequency()));
+        defaultRR->setFrequency(rrule.interval());
+        
+        if (rrule.end().isValid()) {
+            rec->setEndDateTime(toDate(rrule.end())); //TODO date/datetime setEndDate(). With date-only the start date has to be taken into account.
+        } else {
+            rec->setDuration(rrule.count());
+        }
+        
+        if (!rrule.bysecond().empty()) {
+            defaultRR->setBySeconds(QVector<int>::fromStdVector(rrule.bysecond()).toList());
+        }
+        if (!rrule.byminute().empty()) {
+            defaultRR->setByMinutes(QVector<int>::fromStdVector(rrule.byminute()).toList());
+        }
+        if (!rrule.byhour().empty()) {
+            defaultRR->setByHours(QVector<int>::fromStdVector(rrule.byhour()).toList());
+        }
+        if (!rrule.byday().empty()) {
+            QList<KCalCore::RecurrenceRule::WDayPos> daypos;
+            foreach(const Kolab::DayPos &dp, rrule.byday()) {
+                daypos.append(toWeekDayPos(dp));
+            }
+            defaultRR->setByDays(daypos);
+        }
+        if (!rrule.bymonthday().empty()) {
+            defaultRR->setByMonthDays(QVector<int>::fromStdVector(rrule.bymonthday()).toList());
+        }
+        if (!rrule.byyearday().empty()) {
+            defaultRR->setByYearDays(QVector<int>::fromStdVector(rrule.byyearday()).toList());
+        }
+        if (!rrule.byweekno().empty()) {
+            defaultRR->setByWeekNumbers(QVector<int>::fromStdVector(rrule.byweekno()).toList());
+        }
+        if (!rrule.bymonth().empty()) {
+            defaultRR->setByMonths(QVector<int>::fromStdVector(rrule.bymonth()).toList());
+        }
+    }
+    foreach (const Kolab::cDateTime &dt, event.recurrenceDates()) {
+        const KDateTime &date = toDate(dt);
+        if (date.isDateOnly()) {
+            e.recurrence()->addRDate(date.date());
+        } else {
+            e.recurrence()->addRDateTime(date);
+        }
+    }
+    foreach (const Kolab::cDateTime &dt, event.exceptionDates()) {
+        const KDateTime &date = toDate(dt);
+        if (date.isDateOnly()) {
+            e.recurrence()->addExDate(date.date());
+        } else {
+            e.recurrence()->addExDateTime(date);
+        }
+    }
+
+}
+
+template <typename T, typename I>
+void getRecurrence(T &i, const I &e)
+{
+    if (!e.recurs()) {
+        return;
+    }
+    KCalCore::Recurrence *rec = e.recurrence();
+    KCalCore::RecurrenceRule *defaultRR = rec->defaultRRule(false);
+    if (!defaultRR) {
+        Warning() << "no recurrence";
+        return;
+    }
+    Q_ASSERT(defaultRR);
+
+    Kolab::RecurrenceRule rrule;
+    rrule.setWeekStart(fromWeekDay(defaultRR->weekStart()));
+    rrule.setFrequency(fromRecurrenceType(defaultRR->recurrenceType()));
+    rrule.setInterval(defaultRR->frequency());
+  
+    if (defaultRR->duration() != 0) { //Inidcates if end date is set or not
+        if (defaultRR->duration() > 0) {
+            rrule.setCount(defaultRR->duration());
+        }
+    } else {
+        rrule.setEnd(fromDate(defaultRR->endDt()));
+    }
+    
+    rrule.setBysecond(defaultRR->bySeconds().toVector().toStdVector());
+    rrule.setByminute(defaultRR->byMinutes().toVector().toStdVector());
+    rrule.setByhour(defaultRR->byHours().toVector().toStdVector());
+    
+    std::vector<Kolab::DayPos> daypos;
+    foreach (const KCalCore::RecurrenceRule::WDayPos &dp, defaultRR->byDays()) {
+        daypos.push_back(fromWeekDayPos(dp));
+    }
+    rrule.setByday(daypos);
+    
+    rrule.setBymonthday(defaultRR->byMonthDays().toVector().toStdVector());
+    rrule.setByyearday(defaultRR->byYearDays().toVector().toStdVector());
+    rrule.setByweekno(defaultRR->byWeekNumbers().toVector().toStdVector());
+    rrule.setBymonth(defaultRR->byMonths().toVector().toStdVector());
+    i.setRecurrenceRule(rrule);
+    
+    std::vector<Kolab::cDateTime> rdates;
+    foreach (const KDateTime &dt, rec->rDateTimes()) {
+        rdates.push_back(fromDate(dt));
+    }
+    foreach (const QDate &dt, rec->rDates()) {
+        rdates.push_back(fromDate(KDateTime(dt)));
+    }
+    i.setRecurrenceDates(rdates);
+    
+    std::vector<Kolab::cDateTime> exdates;
+    foreach (const KDateTime &dt, rec->exDateTimes()) {
+        exdates.push_back(fromDate(dt));
+    }
+    foreach (const QDate &dt, rec->exDates()) {
+        exdates.push_back(fromDate(KDateTime(dt)));
+    }
+    i.setExceptionDates(exdates);
+    
+    if (!rec->exRules().empty()) {
+        Warning() << "exrules are not supported";
+    }
+}
+
+template <typename T>
+void setTodoEvent(KCalCore::Incidence &i, const T &e)
+{
+    i.setPriority(toPriority(e.priority()));
+    if (!e.location().empty()) {
+        i.setLocation(fromStdString(e.location())); //TODO detect richtext
+    }
+    if (e.organizer().isValid()) {
+        i.setOrganizer(KCalCore::Person::Ptr(new KCalCore::Person(fromStdString(e.organizer().name()), fromStdString(e.organizer().email())))); //TODO handle uid too
+    }
+    if (!e.url().empty()) {
+        i.setNonKDECustomProperty(CUSTOM_KOLAB_URL, fromStdString(e.url()));
+    }
+    if (e.recurrenceID().isValid()) {
+        i.setRecurrenceId(toDate(e.recurrenceID())); //TODO THISANDFUTURE
+    }
+    setRecurrence(i, e);
+    foreach (const Kolab::Alarm a, e.alarms()) {
+        KCalCore::Alarm::Ptr alarm = KCalCore::Alarm::Ptr(new KCalCore::Alarm(&i));
+        switch (a.type()) {
+            case Kolab::Alarm::EMailAlarm: {
+                KCalCore::Person::List receipents;
+                foreach (Kolab::ContactReference c ,a.attendees()) {
+                    KCalCore::Person::Ptr person = KCalCore::Person::Ptr(new KCalCore::Person(fromStdString(c.name()), fromStdString(c.email())));
+                    receipents.append(person);
+                }
+                alarm->setEmailAlarm(fromStdString(a.summary()), fromStdString(a.description()), receipents);
+            }
+                break;
+            case Kolab::Alarm::DisplayAlarm:
+                alarm->setDisplayAlarm(fromStdString(a.text()));
+                break;
+            case Kolab::Alarm::AudioAlarm:
+                alarm->setAudioAlarm(fromStdString(a.audioFile().uri()));
+                break;
+            default:
+                Error() << "invalid alarm";
+        }
+
+        if (a.start().isValid()) {
+            alarm->setTime(toDate(a.start()));
+        } else if (a.relativeStart().isValid()) {
+            if (a.relativeTo() == Kolab::End) {
+                alarm->setEndOffset(toDuration(a.relativeStart()));
+            } else {
+                alarm->setStartOffset(toDuration(a.relativeStart()));
+            }
+        }
+        
+        alarm->setSnoozeTime(toDuration(a.duration()));
+        alarm->setRepeatCount(a.numrepeat());
+        alarm->setEnabled(true);
+        i.addAlarm(alarm);       
+    }
+}
+
+template <typename T, typename I>
+void getTodoEvent(T &i, const I &e)
+{
+    i.setPriority(fromPriority(e.priority()));
+    i.setLocation(toStdString(e.location()));
+    if (e.organizer() && !e.organizer()->email().isEmpty()) {
+        i.setOrganizer(Kolab::ContactReference(Kolab::ContactReference::EmailReference, toStdString(e.organizer()->email()), toStdString(e.organizer()->name()))); //TODO handle uid too
+    }
+    i.setUrl(toStdString(e.nonKDECustomProperty(CUSTOM_KOLAB_URL)));
+    i.setRecurrenceID(fromDate(e.recurrenceId()), false); //TODO THISANDFUTURE
+    getRecurrence(i, e);
+    std::vector <Kolab::Alarm> alarms;
+    foreach (const KCalCore::Alarm::Ptr &a, e.alarms()) {
+        Kolab::Alarm alarm;
+        //TODO KCalCore disables alarms using KCalCore::Alarm::enabled() (X-KDE-KCALCORE-ENABLED) We should either delete the alarm, or store the attribute .
+        //Ideally we would store the alarm somewhere and temporarily delete it, so we can restore it when parsing. For now we just remove disabled alarms.
+        if (!a->enabled()) {
+            Warning() << "skipping disabled alarm";
+            continue;
+        }
+        switch (a->type()) {
+            case KCalCore::Alarm::Display:
+                alarm = Kolab::Alarm(toStdString(a->text()));
+                break;
+            case KCalCore::Alarm::Email: {
+                std::vector<Kolab::ContactReference> receipents;
+                foreach(const KCalCore::Person::Ptr &p, a->mailAddresses()) {
+                    receipents.push_back(Kolab::ContactReference(toStdString(p->email()), toStdString(p->name())));
+                }
+                alarm = Kolab::Alarm(toStdString(a->mailSubject()), toStdString(a->mailText()), receipents);
+            }
+                break;
+            case KCalCore::Alarm::Audio: {
+                Kolab::Attachment audioFile;
+                audioFile.setUri(toStdString(a->audioFile()), std::string());
+                alarm = Kolab::Alarm(audioFile);
+            }
+                break;
+            default:
+                Error() << "unhandled alarm";
+        }
+
+        if (a->hasTime()) {
+            alarm.setStart(fromDate(a->time()));
+        } else if (a->hasStartOffset()) {
+            alarm.setRelativeStart(fromDuration(a->startOffset()), Start);
+        } else if (a->hasEndOffset()) {
+            alarm.setRelativeStart(fromDuration(a->endOffset()), End);
+        } else {
+            Error() << "alarm trigger is missing";
+            continue;
+        }
+        
+        alarm.setDuration(fromDuration(a->snoozeTime()), a->repeatCount());
+        
+        alarms.push_back(alarm);
+    }
+    i.setAlarms(alarms);
+}
+
+KCalCore::Event::Ptr toKCalCore(const Kolab::Event &event)
+{
+    KCalCore::Event::Ptr e(new KCalCore::Event);
+    setIncidence(*e, event);
+    setTodoEvent(*e, event);
+    if (event.end().isValid()) {
+        e->setDtEnd(toDate(event.end()));
+    }
+    if (event.duration().isValid()) {
+        e->setDuration(toDuration(event.duration()));
+    }
+    if (event.transparency()) {
+        e->setTransparency(KCalCore::Event::Transparent);
+    } else {
+        e->setTransparency(KCalCore::Event::Opaque);
+    }
+    return e;
+}
+
+Event fromKCalCore(const KCalCore::Event &event)
+{
+    Event e;
+    getIncidence(e, event);
+    getTodoEvent(e, event);
+    if (event.hasEndDate()) {
+        e.setEnd(fromDate(event.dtEnd()));
+    } else if (event.hasDuration()) {
+        e.setDuration(fromDuration(event.duration()));
+    }
+    if (event.transparency() == KCalCore::Event::Transparent) {
+        e.setTransparency(true);
+    } else {
+        e.setTransparency(false);
+    }
+    return e;
+}
+
+
+
+KCalCore::Todo::Ptr toKCalCore ( const Todo &todo )
+{
+    KCalCore::Todo::Ptr e(new KCalCore::Todo);
+    setIncidence(*e, todo);
+    setTodoEvent(*e, todo);
+    if (todo.due().isValid()) {
+        e->setDtDue(toDate(todo.due()));
+    }
+    if (!todo.relatedTo().empty()) {
+        e->setRelatedTo(Conversion::fromStdString(todo.relatedTo().front()), KCalCore::Incidence::RelTypeParent);
+        if (todo.relatedTo().size() > 1) {
+            Error() << "only one relation support but got multiple";
+        }
+    }
+    e->setPercentComplete(todo.percentComplete());
+    return e;
+}
+
+Todo fromKCalCore ( const KCalCore::Todo &todo )
+{
+    Todo t;
+    getIncidence(t, todo);
+    getTodoEvent(t, todo);
+    t.setDue(fromDate(todo.dtDue(true)));
+    t.setPercentComplete(todo.percentComplete());
+    const QString relatedTo = todo.relatedTo(KCalCore::Incidence::RelTypeParent);
+    if (!relatedTo.isEmpty()) {
+        std::vector<std::string> relateds;
+        relateds.push_back(Conversion::toStdString(relatedTo));
+        t.setRelatedTo(relateds);
+    }
+    return t;
+}
+
+KCalCore::Journal::Ptr toKCalCore ( const Journal &journal )
+{
+    KCalCore::Journal::Ptr e(new KCalCore::Journal);
+    setIncidence(*e, journal);
+    //TODO contacts
+    return e;
+}
+
+Journal fromKCalCore ( const KCalCore::Journal &journal )
+{
+    Journal j;
+    getIncidence(j, journal);
+    //TODO contacts
+    return j;
+}
+
+
+
+}
+}
diff --git a/src/conversion/kcalconversion.h b/src/conversion/kcalconversion.h
new file mode 100644
index 0000000..cd4f4e9
--- /dev/null
+++ b/src/conversion/kcalconversion.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2011  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#ifndef KOLABKCALCONVERSION_H
+#define KOLABKCALCONVERSION_H
+
+#include "kolab_export.h"
+
+#include <kolabevent.h>
+#include <kolabtodo.h>
+#include <kolabjournal.h>
+#include <kcalcore/event.h>
+#include <kcalcore/todo.h>
+#include <kcalcore/journal.h>
+
+namespace Kolab {
+    /**
+     * Conversion of Kolab-Containers to/from KCalCore Containers.
+     *
+     */
+    namespace Conversion {
+
+        KOLAB_EXPORT KCalCore::Event::Ptr toKCalCore(const Kolab::Event &);
+        KOLAB_EXPORT Kolab::Event fromKCalCore(const KCalCore::Event &);
+
+        KOLAB_EXPORT KCalCore::Todo::Ptr toKCalCore(const Kolab::Todo &);
+        KOLAB_EXPORT Kolab::Todo fromKCalCore(const KCalCore::Todo &);
+
+        KOLAB_EXPORT KCalCore::Journal::Ptr toKCalCore(const Kolab::Journal &);
+        KOLAB_EXPORT Kolab::Journal fromKCalCore(const KCalCore::Journal &);
+
+        KOLAB_EXPORT KDateTime toDate(const Kolab::cDateTime &dt);
+        KOLAB_EXPORT cDateTime fromDate(const KDateTime &dt);
+
+    };
+};
+
+#endif
diff --git a/src/conversion/kolabconversion.cpp b/src/conversion/kolabconversion.cpp
new file mode 100644
index 0000000..f99ff99
--- /dev/null
+++ b/src/conversion/kolabconversion.cpp
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "kolabconversion.h"
+#include "commonconversion.h"
+#include <akonadi/notes/noteutils.h>
+
+namespace Kolab {
+    namespace Conversion {
+        
+Note fromNote(const KMime::Message::Ptr &m)
+{
+    Akonadi::NoteUtils::NoteMessageWrapper note(m);
+    Note n;
+    n.setSummary(toStdString(note.title()));
+    n.setDescription(toStdString(note.text()));
+    KDateTime created = KDateTime(note.creationDate());
+    created.setTimeSpec(KDateTime::UTC);
+    n.setCreated(fromDate(created));
+
+    n.setUid(toStdString(note.uid()));
+    KDateTime lastModified = KDateTime(note.lastModifiedDate());
+    lastModified.setTimeSpec(KDateTime::UTC);
+    n.setLastModified(fromDate(lastModified));
+    
+    switch (note.classification()) {
+        case Akonadi::NoteUtils::NoteMessageWrapper::Confidential:
+            n.setClassification(Kolab::ClassConfidential);
+            break;
+        case Akonadi::NoteUtils::NoteMessageWrapper::Private:
+            n.setClassification(Kolab::ClassPrivate);
+            break;
+        default:
+            n.setClassification(Kolab::ClassPublic);
+    }
+    
+    std::vector<Kolab::CustomProperty> customs;
+    QMap<QString, QString> &customsMap = note.custom();
+    for (QMap <QString, QString >::const_iterator it = customsMap.constBegin(); it != customsMap.constEnd(); it ++) {
+        customs.push_back(Kolab::CustomProperty(toStdString(it.key()), toStdString(it.value())));
+    }
+    n.setCustomProperties(customs);
+    
+    std::vector<Kolab::Attachment> attachments;
+    foreach(const Akonadi::NoteUtils::Attachment &a, note.attachments()) {
+        Kolab::Attachment attachment;
+        if (a.url().isValid()) {
+            attachment.setUri(toStdString(a.url().toString()), toStdString(a.mimetype()));
+        } else {
+            attachment.setData(toStdString(QString(a.data())), toStdString(a.mimetype()));
+        }
+        attachment.setLabel(toStdString(a.label()));
+        attachments.push_back(attachment);
+    }
+    n.setAttachments(attachments);
+
+    return n;
+}
+
+KMime::Message::Ptr toNote(const Note &n)
+{
+    Akonadi::NoteUtils::NoteMessageWrapper note;
+    note.setTitle(fromStdString(n.summary()));
+    note.setText(fromStdString(n.description()));
+    note.setFrom("kolab@kde4");
+    note.setCreationDate(toDate(n.created()).dateTime());
+    note.setUid(fromStdString(n.uid()));
+    note.setLastModifiedDate(toDate(n.lastModified()).dateTime());
+    switch (n.classification()) {
+        case Kolab::ClassPrivate:
+            note.setClassification(Akonadi::NoteUtils::NoteMessageWrapper::Private);
+            break;
+        case Kolab::ClassConfidential:
+            note.setClassification(Akonadi::NoteUtils::NoteMessageWrapper::Confidential);
+            break;
+        default:
+            note.setClassification(Akonadi::NoteUtils::NoteMessageWrapper::Public);
+    }
+
+    foreach (const Kolab::Attachment &a, n.attachments()) {
+        if (!a.uri().empty()) {
+            Akonadi::NoteUtils::Attachment attachment(QUrl(fromStdString(a.uri())), fromStdString(a.mimetype()));
+            attachment.setLabel(fromStdString(a.label()));
+            note.attachments().append(attachment);
+        } else {
+            Akonadi::NoteUtils::Attachment attachment(fromStdString(a.data()).toLatin1(), fromStdString(a.mimetype()));
+            attachment.setLabel(fromStdString(a.label()));
+            note.attachments().append(attachment);
+        }
+    }
+    foreach (const Kolab::CustomProperty &a, n.customProperties()) {
+        note.custom().insert(fromStdString(a.identifier), fromStdString(a.value));
+    }
+    return note.message();
+}
+
+        
+    }
+}
+
diff --git a/src/conversion/kolabconversion.h b/src/conversion/kolabconversion.h
new file mode 100644
index 0000000..88de02e
--- /dev/null
+++ b/src/conversion/kolabconversion.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef KOLABCONVERSION_H
+#define KOLABCONVERSION_H
+
+#include "kolab_export.h"
+
+#include <kolabnote.h>
+#include <kmime/kmime_message.h>
+
+namespace Kolab {
+    /**
+     * Conversion of Kolab-Containers to/from KDE Containers.
+     *
+     */
+    namespace Conversion {
+        
+        KOLAB_EXPORT KMime::Message::Ptr toNote(const Kolab::Note &);
+        KOLAB_EXPORT Kolab::Note fromNote(const KMime::Message::Ptr &);
+        
+    };
+};
+
+#endif
diff --git a/src/conversion/timezoneconverter.cpp b/src/conversion/timezoneconverter.cpp
new file mode 100644
index 0000000..7a75a04
--- /dev/null
+++ b/src/conversion/timezoneconverter.cpp
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "timezoneconverter.h"
+#include <ktimezone.h>
+#include <ksystemtimezone.h>
+#include <kdebug.h>
+#include <QRegExp>
+#include <QStringList>
+#include "kolabformat/errorhandler.h"
+
+QString TimezoneConverter::normalizeTimezone(const QString& tz)
+{
+    KTimeZone timezone = KSystemTimeZones::zone(tz); //Needs ktimezoned (timezone daemon running) http://api.kde.org/4.x-api/kdelibs-apidocs/kdecore/html/classKSystemTimeZones.html
+    if (timezone.isValid()) {
+        return tz;
+    } else if (!KSystemTimeZones::isTimeZoneDaemonAvailable()) {
+        Error() << "ktimezoned is not available and required for timezone interpretation";
+    }
+    //We're dealing with an invalid or unknown timezone, try to parse it
+    QString guessedTimezone = fromCityName(tz);
+    if (guessedTimezone.isEmpty()) {
+        guessedTimezone = fromHardcodedList(tz);
+    }
+    if (guessedTimezone.isEmpty()) {
+        guessedTimezone = fromGMTOffsetTimezone(tz);
+    }
+//     if (guessedTimezone.isEmpty()) {
+//         //slower but also finds outdated zones
+//         timezone = KSystemTimeZones::readZone(tz);
+//         if (timezone.isValid()) {
+//             //This thinks all kinds of shit is valid, including /etc/localtime. Let's verify again.
+//             qDebug() << "found " << tz;
+//             return tz;
+//         }
+//     }
+    Debug() << "Guessed timezone and found: " << guessedTimezone;
+    return guessedTimezone;
+}
+
+QString TimezoneConverter::fromGMTOffsetTimezone(const QString& tz)
+{
+    Q_UNUSED(tz);
+    return QString();
+}
+
+QString TimezoneConverter::fromCityName(const QString& tz)
+{
+    const KTimeZones::ZoneMap zones = KSystemTimeZones::zones();
+    KTimeZones::ZoneMap::const_iterator it = zones.constBegin();
+    QHash<QString, QString> countryMap;
+    for(;it != zones.constEnd(); it++) {
+        const QString cityName = it.key().split('/').last();
+//         kDebug() << it.key() << it.value().name() << cityName;
+        Q_ASSERT(!countryMap.contains(cityName));
+        countryMap.insert(cityName, it.key());
+    }
+
+    QRegExp locationFinder("\\b([a-zA-Z])+\\b", Qt::CaseSensitive, QRegExp::RegExp2);
+    int pos = 0;
+    while (pos >= 0) {
+        pos = locationFinder.indexIn(tz, pos);
+        if (pos >= 0) {
+            ++pos;
+        }
+        const QString location = locationFinder.capturedTexts().first();
+//         kDebug() << "location " << location;
+        if (countryMap.contains(location)) {
+//             kDebug() << "found match " << countryMap.value(location);
+            return countryMap.value(location);
+        }
+    }
+    return QString();
+}
+
+
+//Based on
+// * http://msdn.microsoft.com/en-us/library/ms912391(v=winembedded.11).aspx
+// * http://technet.microsoft.com/en-us/library/cc749073(v=ws.10).aspx
+// * http://unicode.org/repos/cldr/trunk/common/supplemental/windowsZones.xml
+// * http://stackoverflow.com/questions/4967903/linux-windows-timezone-mapping
+static const struct WindowsTimezone {
+//   const int gmtOffset;
+  const char *timezoneSpecifier; //This one should be stable and always in english
+  const char *name; //The display name (which is in some cases still useful to try guessing)
+  const char *olson[28]; //Corresponding olson timezones we can map to
+} windowsTimezones[] = {
+    {"Afghanistan Standard Time", "Kabul", {"Asia/Kabul", "Asia/Kabul"}},
+    {"Alaskan Standard Time", "Alaska", {"America/Anchorage", "America/Anchorage America/Juneau America/Nome America/Sitka America/Yakutat"}},
+    {"Arab Standard Time", "Kuwait, Riyadh", {"Asia/Riyadh", "Asia/Bahrain", "Asia/Kuwait", "Asia/Qatar", "Asia/Riyadh", "Asia/Aden"}},
+    {"Arabian Standard Time", "Abu Dhabi, Muscat", {"Asia/Dubai", "Asia/Dubai", "Asia/Muscat", "Etc/GMT-4"}},
+    {"Arabic Standard Time", "Baghdad", {"Asia/Baghdad", "Asia/Baghdad"}},
+    {"Atlantic Standard Time", "Atlantic Time (Canada)", {"America/Halifax", "Atlantic/Bermuda", "America/Halifax America/Glace_Bay America/Goose_Bay America/Moncton", "America/Thule"}},
+    {"AUS Central Standard Time", "Darwin", {"Australia/Darwin", "Australia/Darwin"}},
+    {"AUS Eastern Standard Time", "Canberra, Melbourne, Sydney", {"Australia/Sydney", "Australia/Sydney Australia/Melbourne"}},
+    {"Azerbaijan Standard Time", "Baku", {"Asia/Baku", "Asia/Baku"}},
+    {"Azores Standard Time", "Azores", {"Atlantic/Azores", "America/Scoresbysund", "Atlantic/Azores"}},
+    {"Canada Central Standard Time", "Saskatchewan", {"America/Regina", "America/Regina America/Swift_Current"}},
+    {"Cape Verde Standard Time", "Cape Verde Islands", {"Atlantic/Cape_Verde", "Atlantic/Cape_Verde", "Etc/GMT+1"}},
+    {"Caucasus Standard Time", "Yerevan", {"Asia/Yerevan", "Asia/Yerevan"}},
+    {"Cen. Australia Standard Time", "Adelaide", {"Australia/Adelaide", "Australia/Adelaide Australia/Broken_Hill"}},
+    {"Central America Standard Time", "Central America", {"America/Guatemala", "America/Belize", "America/Costa_Rica", "Pacific/Galapagos", "America/Guatemala", "America/Tegucigalpa", "America/Managua", "America/El_Salvador", "Etc/GMT+6"}},
+    {"Central Asia Standard Time", "Astana, Dhaka", {"Asia/Almaty", "Antarctica/Vostok", "Indian/Chagos", "Asia/Bishkek", "Asia/Almaty Asia/Qyzylorda", "Etc/GMT-6"}},
+    {"Central Brazilian Standard Time", "Manaus", {"America/Cuiaba", "America/Cuiaba America/Campo_Grande"}},
+    {"Central Europe Standard Time", "Belgrade, Bratislava, Budapest, Ljubljana, Prague", {"Europe/Budapest", "Europe/Tirane", "Europe/Prague", "Europe/Budapest", "Europe/Podgorica", "Europe/Belgrade", "Europe/Ljubljana", "Europe/Bratislava"}},
+    {"Central European Standard Time", "Sarajevo, Skopje, Warsaw, Zagreb", {"Europe/Warsaw", "Europe/Sarajevo", "Europe/Zagreb", "Europe/Skopje", "Europe/Warsaw"}},
+    {"Central Pacific Standard Time", "Magadan, Solomon Islands, New Caledonia", {"Pacific/Guadalcanal", "Antarctica/Macquarie", "Pacific/Ponape Pacific/Kosrae", "Pacific/Noumea", "Pacific/Guadalcanal", "Pacific/Efate", "Etc/GMT-11"}},
+    {"Central Standard Time", "Central Time (US and Canada)", {"America/Chicago", "America/Winnipeg America/Rainy_River America/Rankin_Inlet America/Resolute", "America/Matamoros", "America/Chicago America/Indiana/Knox America/Indiana/Tell_City America/Menominee America/North_Dakota/Beulah America/North_Dakota/Center America/North_Dakota/New_Salem", "CST6CDT"}},
+    {"Central Standard Time (Mexico)", "Guadalajara, Mexico City, Monterrey", {"America/Mexico_City", "America/Mexico_City America/Bahia_Banderas America/Cancun America/Merida America/Monterrey"}},
+    {"China Standard Time", "Beijing, Chongqing, Hong Kong SAR, Urumqi", {"Asia/Shanghai", "Asia/Shanghai Asia/Chongqing Asia/Harbin Asia/Kashgar Asia/Urumqi", "Asia/Hong_Kong", "Asia/Macau"}},
+    {"Dateline Standard Time", "International Date Line West", {"Etc/GMT+12", "Etc/GMT+12"}},
+    {"E. Africa Standard Time", "Nairobi", {"Africa/Nairobi", "Antarctica/Syowa", "Africa/Djibouti", "Africa/Asmera", "Africa/Addis_Ababa", "Africa/Nairobi", "Indian/Comoro", "Indian/Antananarivo", "Africa/Khartoum", "Africa/Mogadishu", "Africa/Juba", "Africa/Dar_es_Salaam", "Africa/Kampala", "Indian/Mayotte", "Etc/GMT-3"}},
+    {"E. Australia Standard Time", "Brisbane", {"Australia/Brisbane", "Australia/Brisbane Australia/Lindeman"}},
+    {"E. Europe Standard Time", "Minsk", {"Asia/Nicosia", "Asia/Nicosia"}},
+    {"E. South America Standard Time", "Brasilia", {"America/Sao_Paulo", "America/Sao_Paulo"}},
+    {"Eastern Standard Time", "Eastern Time (US and Canada)", {"America/New_York", "America/Nassau", "America/Toronto America/Iqaluit America/Montreal America/Nipigon America/Pangnirtung America/Thunder_Bay", "America/Grand_Turk", "America/New_York America/Detroit America/Indiana/Petersburg America/Indiana/Vincennes America/Indiana/Winamac America/Kentucky/Monticello America/Louisville", "EST5EDT"}},
+    {"Egypt Standard Time", "Cairo", {"Africa/Cairo", "Africa/Cairo", "Asia/Gaza Asia/Hebron"}},
+    {"Ekaterinburg Standard Time", "Ekaterinburg", {"Asia/Yekaterinburg", "Asia/Yekaterinburg"}},
+    {"Fiji Standard Time", "Fiji Islands, Kamchatka, Marshall Islands", {"Pacific/Fiji", "Pacific/Fiji"}},
+    {"FLE Standard Time", "Helsinki, Kiev, Riga, Sofia, Tallinn, Vilnius", {"Europe/Kiev", "Europe/Mariehamn", "Europe/Sofia", "Europe/Tallinn", "Europe/Helsinki", "Europe/Vilnius", "Europe/Riga", "Europe/Kiev Europe/Simferopol Europe/Uzhgorod Europe/Zaporozhye"}},
+    {"Georgian Standard Time", "Tblisi", {"Asia/Tbilisi", "Asia/Tbilisi"}},
+    {"GMT Standard Time", "Greenwich Mean Time : Dublin, Edinburgh, Lisbon, London", {"Europe/London", "Atlantic/Canary", "Atlantic/Faeroe", "Europe/London", "Europe/Guernsey", "Europe/Dublin", "Europe/Isle_of_Man", "Europe/Jersey", "Europe/Lisbon Atlantic/Madeira"}},
+    {"Greenland Standard Time", "Greenland", {"America/Godthab", "America/Godthab"}},
+    {"Greenwich Standard Time", "Casablanca, Monrovia", {"Atlantic/Reykjavik", "Africa/Ouagadougou", "Africa/Abidjan", "Africa/El_Aaiun", "Africa/Accra", "Africa/Banjul", "Africa/Conakry", "Africa/Bissau", "Atlantic/Reykjavik", "Africa/Monrovia", "Africa/Bamako", "Africa/Nouakchott", "Atlantic/St_Helena", "Africa/Freetown", "Africa/Dakar", "Africa/Sao_Tome", "Africa/Lome"}},
+    {"GTB Standard Time", "Athens, Bucharest, Istanbul", {"Europe/Bucharest", "Europe/Athens", "Europe/Chisinau", "Europe/Bucharest"}},
+    {"Hawaiian Standard Time", "Hawaii", {"Pacific/Honolulu", "Pacific/Rarotonga", "Pacific/Tahiti", "Pacific/Johnston", "Pacific/Honolulu", "Etc/GMT+10"}},
+    {"India Standard Time", "Chennai, Kolkata, Mumbai, New Delhi", {"Asia/Calcutta", "Asia/Calcutta"}},
+    {"Iran Standard Time", "Tehran", {"Asia/Tehran", "Asia/Tehran"}},
+    {"Israel Standard Time", "Jerusalem", {"Asia/Jerusalem", "Asia/Jerusalem"}},
+    {"Korea Standard Time", "Seoul", {"Asia/Seoul", "Asia/Pyongyang", "Asia/Seoul"}},
+//    {"Mid-Atlantic Standard Time", "Mid-Atlantic", {"}},
+    {"Mountain Standard Time", "Mountain Time (US and Canada)", {"America/Denver", "America/Edmonton America/Cambridge_Bay America/Inuvik America/Yellowknife", "America/Ojinaga", "America/Denver America/Boise America/Shiprock", "MST7MDT"}},
+    {"Mountain Standard Time (Mexico)", "Chihuahua, La Paz, Mazatlan", {"America/Chihuahua", "America/Chihuahua America/Mazatlan"}},
+    {"Myanmar Standard Time", "Yangon (Rangoon)", {"Asia/Rangoon", "Indian/Cocos", "Asia/Rangoon"}},
+    {"N. Central Asia Standard Time", "Almaty, Novosibirsk", {"Asia/Novosibirsk", "Asia/Novosibirsk Asia/Novokuznetsk Asia/Omsk"}},
+    {"Namibia Standard Time", "Windhoek", {"Africa/Windhoek", "Africa/Windhoek"}},
+    {"Nepal Standard Time", "Kathmandu", {"Asia/Katmandu", "Asia/Katmandu"}},
+    {"New Zealand Standard Time", "Auckland, Wellington", {"Pacific/Auckland", "Antarctica/South_Pole Antarctica/McMurdo", "Pacific/Auckland"}},
+    {"Newfoundland Standard Time", "Newfoundland and Labrador", {"America/St_Johns", "America/St_Johns"}},
+    {"North Asia East Standard Time", "Irkutsk, Ulaanbaatar", {"Asia/Irkutsk", "Asia/Irkutsk"}},
+    {"North Asia Standard Time", "Krasnoyarsk", {"Asia/Krasnoyarsk", "Asia/Krasnoyarsk"}},
+    {"Pacific SA Standard Time", "Santiago", {"America/Santiago", "Antarctica/Palmer", "America/Santiago"}},
+    {"Pacific Standard Time", "Pacific Time (US and Canada); Tijuana", {"America/Los_Angeles", "America/Vancouver America/Dawson America/Whitehorse", "America/Tijuana", "America/Los_Angeles", "PST8PDT"}},
+    {"Romance Standard Time", "Brussels, Copenhagen, Madrid, Paris", {"Europe/Paris", "Europe/Brussels", "Europe/Copenhagen", "Europe/Madrid Africa/Ceuta", "Europe/Paris"}},
+    {"Russian Standard Time", "Moscow, St. Petersburg, Volgograd", {"Europe/Moscow", "Europe/Moscow Europe/Samara Europe/Volgograd"}},
+    {"SA Eastern Standard Time", "Buenos Aires, Georgetown", {"America/Cayenne", "Antarctica/Rothera", "America/Fortaleza America/Araguaina America/Belem America/Maceio America/Recife America/Santarem", "Atlantic/Stanley", "America/Cayenne", "America/Paramaribo", "Etc/GMT+3"}},
+    {"SA Pacific Standard Time", "Bogota, Lima, Quito", {"America/Bogota", "America/Coral_Harbour", "America/Bogota", "America/Guayaquil", "America/Port-au-Prince", "America/Jamaica", "America/Cayman", "America/Panama", "America/Lima", "Etc/GMT+5"}},
+    {"SA Western Standard Time", "Caracas, La Paz", {"America/La_Paz", "America/Antigua", "America/Anguilla", "America/Aruba", "America/Barbados", "America/St_Barthelemy", "America/La_Paz", "America/Kralendijk", "America/Manaus America/Boa_Vista America/Eirunepe America/Porto_Velho America/Rio_Branco", "America/Blanc-Sablon", "America/Curacao", "America/Dominica", "America/Santo_Domingo", "America/Grenada", "America/Guadeloupe", "America/Guyana", "America/St_Kitts", "America/St_Lucia", "America/Marigot", "America/Martinique", "America/Montserrat", "America/Puerto_Rico", "America/Lower_Princes", "America/Port_of_Spain", "America/St_Vincent", "America/Tortola", "America/St_Thomas", "Etc/GMT+4"}},
+    {"Samoa Standard Time", "Midway Island, Samoa", {"Pacific/Apia", "Pacific/Apia"}},
+    {"SE Asia Standard Time", "Bangkok, Hanoi, Jakarta", {"Asia/Bangkok", "Antarctica/Davis", "Indian/Christmas", "Asia/Jakarta Asia/Pontianak", "Asia/Phnom_Penh", "Asia/Vientiane", "Asia/Hovd", "Asia/Bangkok", "Asia/Saigon", "Etc/GMT-7"}},
+    {"Singapore Standard Time", "Kuala Lumpur, Singapore", {"Asia/Singapore", "Asia/Brunei", "Asia/Makassar", "Asia/Kuala_Lumpur Asia/Kuching", "Asia/Manila", "Asia/Singapore", "Etc/GMT-8"}},
+    {"South Africa Standard Time", "Harare, Pretoria", {"Africa/Johannesburg", "Africa/Bujumbura", "Africa/Gaborone", "Africa/Lubumbashi", "Africa/Maseru", "Africa/Blantyre", "Africa/Maputo", "Africa/Kigali", "Africa/Mbabane", "Africa/Johannesburg", "Africa/Lusaka", "Africa/Harare", "Etc/GMT-2"}},
+    {"Sri Lanka Standard Time", "Sri Jayawardenepura", {"Asia/Colombo", "Asia/Colombo"}},
+    {"Taipei Standard Time", "Taipei", {"Asia/Taipei", "Asia/Taipei"}},
+    {"Tasmania Standard Time", "Hobart", {"Australia/Hobart", "Australia/Hobart Australia/Currie"}},
+    {"Tokyo Standard Time", "Osaka, Sapporo, Tokyo", {"Asia/Tokyo", "Asia/Jayapura", "Asia/Tokyo", "Pacific/Palau", "Asia/Dili", "Etc/GMT-9"}},
+    {"Tonga Standard Time", "Nuku'alofa", {"Pacific/Tongatapu", "Pacific/Enderbury", "Pacific/Fakaofo", "Pacific/Tongatapu", "Etc/GMT-13"}},
+    {"US Eastern Standard Time", "Indiana (East)", {"America/Indianapolis", "America/Indianapolis America/Indiana/Marengo America/Indiana/Vevay"}},
+    {"US Mountain Standard Time", "Arizona", {"America/Phoenix", "America/Dawson_Creek America/Creston", "America/Hermosillo", "America/Phoenix", "Etc/GMT+7"}},
+    {"Vladivostok Standard Time", "Vladivostok", {"Asia/Vladivostok", "Asia/Vladivostok Asia/Sakhalin"}},
+    {"W. Australia Standard Time", "Perth", {"Australia/Perth", "Antarctica/Casey", "Australia/Perth"}},
+    {"W. Central Africa Standard Time", "West Central Africa", {"Africa/Lagos", "Africa/Luanda", "Africa/Porto-Novo", "Africa/Kinshasa", "Africa/Bangui", "Africa/Brazzaville", "Africa/Douala", "Africa/Algiers", "Africa/Libreville", "Africa/Malabo", "Africa/Niamey", "Africa/Lagos", "Africa/Ndjamena", "Africa/Tunis", "Etc/GMT-1"}},
+    {"W. Europe Standard Time", "Amsterdam, Berlin, Bern, Rome, Stockholm, Vienna", {"Europe/Berlin", "Europe/Andorra", "Europe/Vienna", "Europe/Zurich", "Europe/Berlin", "Europe/Gibraltar", "Europe/Rome", "Europe/Vaduz", "Europe/Luxembourg", "Africa/Tripoli", "Europe/Monaco", "Europe/Malta", "Europe/Amsterdam", "Europe/Oslo", "Europe/Stockholm", "Arctic/Longyearbyen", "Europe/San_Marino", "Europe/Vatican"}},
+    {"West Asia Standard Time", "Islamabad, Karachi, Tashkent", {"Asia/Tashkent", "Antarctica/Mawson", "Asia/Oral Asia/Aqtau Asia/Aqtobe", "Indian/Maldives", "Indian/Kerguelen", "Asia/Dushanbe", "Asia/Ashgabat", "Asia/Tashkent Asia/Samarkand", "Etc/GMT-5"}},
+    {"West Pacific Standard Time", "Guam, Port Moresby", {"Pacific/Port_Moresby", "Antarctica/DumontDUrville", "Pacific/Truk", "Pacific/Guam", "Pacific/Saipan", "Pacific/Port_Moresby", "Etc/GMT-10"}},
+    {"Yakutsk Standard Time", "Yakuts", {"Asia/Yakutsk", "Asia/Yakutsk"}}
+};
+static const int numWindowsTimezones = sizeof windowsTimezones / sizeof *windowsTimezones;
+
+QString TimezoneConverter::fromHardcodedList(const QString& tz)
+{
+    for (int i = 0; i <numWindowsTimezones; i++) {
+        const WindowsTimezone &windowsTimezone = windowsTimezones[i];
+        const QByteArray specifier(windowsTimezone.timezoneSpecifier);
+        const QByteArray windowsName(windowsTimezone.name);
+        if ((!specifier.isEmpty() && tz.contains(specifier)) ||
+            (!windowsName.isEmpty() && tz.contains(windowsName))) {
+            //TODO find the olson timezone matching the local timezone if we have multiple to map to
+            return QString::fromLatin1(windowsTimezone.olson[0]);
+        }
+    }
+    return QString();
+}
diff --git a/src/conversion/timezoneconverter.h b/src/conversion/timezoneconverter.h
new file mode 100644
index 0000000..84cad70
--- /dev/null
+++ b/src/conversion/timezoneconverter.h
@@ -0,0 +1,33 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef TIMEZONECONVERTER_H
+#define TIMEZONECONVERTER_H
+
+#include <QString>
+
+class TimezoneConverter
+{
+public:
+    static QString normalizeTimezone(const QString &tz);
+private:
+    static QString fromCityName(const QString &tz);
+    static QString fromHardcodedList(const QString &tz);
+    static QString fromGMTOffsetTimezone(const QString &tz);
+};
+
+#endif // TIMEZONECONVERTER_H
diff --git a/src/freebusy/CMakeLists.txt b/src/freebusy/CMakeLists.txt
new file mode 100644
index 0000000..f1f584e
--- /dev/null
+++ b/src/freebusy/CMakeLists.txt
@@ -0,0 +1,3 @@
+set (FREEBUSY_SRCS
+    ${CMAKE_CURRENT_SOURCE_DIR}/freebusy.cpp
+    PARENT_SCOPE)
diff --git a/src/freebusy/freebusy.cpp b/src/freebusy/freebusy.cpp
new file mode 100644
index 0000000..ac7dc44
--- /dev/null
+++ b/src/freebusy/freebusy.cpp
@@ -0,0 +1,321 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "freebusy.h"
+#include "conversion/kcalconversion.h"
+#include "conversion/commonconversion.h"
+#include "kolab_version.h"
+#include <kcalcore/freebusy.h>
+#include <kcalcore/icalformat.h>
+#include <kdebug.h>
+#include <quuid.h>
+#include <QTime>
+
+// namespace KCalCore {
+//     struct KCalFreebusy
+// {
+//
+// void init( const Event::List &eventList, const KDateTime &start, const KDateTime &end )
+// {
+//     mDtStart = start.toUtc();
+//     mDtEnd = end.toUtc();
+//
+//   // Loops through every event in the calendar
+//   Event::List::ConstIterator it;
+//   for ( it = eventList.constBegin(); it != eventList.constEnd(); ++it ) {
+//     Event::Ptr event = *it;
+//
+//     // If this event is transparent it shouldn't be in the freebusy list.
+//     if ( event->transparency() == Event::Transparent ) {
+//       continue;
+//     }
+//
+//     if ( event->hasRecurrenceId() ) {
+//       continue; //TODO apply special period exception (duration could be different)
+//     }
+//
+//     const KDateTime eventStart = event->dtStart().toUtc();
+//     const KDateTime eventEnd = event->dtEnd().toUtc();
+//
+//     if ( event->recurs() ) {
+//         const KCalCore::Duration duration( eventStart, eventEnd );
+//         const KCalCore::DateTimeList list = event->recurrence()->timesInInterval(start, end);
+//         foreach (const KDateTime &dt, list) {
+//             const KDateTime utc = dt.toUtc();
+//             addLocalPeriod(utc, duration.end(utc) );
+//         }
+//     } else {
+//         addLocalPeriod( eventStart, eventEnd );
+//     }
+//   }
+//
+// //   q->sortList();
+// }
+//
+// bool addLocalPeriod(
+//                                         const KDateTime &eventStart,
+//                                         const KDateTime &eventEnd )
+// {
+//   KDateTime tmpStart;
+//   KDateTime tmpEnd;
+//
+//   //Check to see if the start *or* end of the event is
+//   //between the start and end of the freebusy dates.
+//   if ( !( ( ( mDtStart.secsTo( eventStart ) >= 0 ) &&
+//             ( eventStart.secsTo( mDtEnd ) >= 0 ) ) ||
+//           ( ( mDtStart.secsTo( eventEnd ) >= 0 ) &&
+//             ( eventEnd.secsTo( mDtEnd ) >= 0 ) ) ) ) {
+//       qDebug() << "out of scope";
+//     return false;
+//   }
+//
+// //   qDebug() << eventStart.date().toString() << eventStart.time().toString() << mDtStart.toString();
+//   if ( eventStart < mDtStart ) { //eventStart is before start
+// //       qDebug() << "use start";
+//     tmpStart = mDtStart;
+//   } else {
+//     tmpStart = eventStart;
+//   }
+//
+//   qDebug() << eventEnd.date().toString() << eventEnd.time().toString() << mDtEnd.toString();
+//   if ( eventEnd > mDtEnd ) { //event end is after dtEnd
+// //     qDebug() << "use end";
+//     tmpEnd = mDtEnd;
+//   } else {
+//     tmpEnd = eventEnd;
+//   }
+//
+// //   qDebug() << "########## " << tmpStart.isValid();
+//   Q_ASSERT(tmpStart.isValid());
+//   Q_ASSERT(tmpEnd.isValid());
+// //   qDebug() << tmpStart.date().toString() << tmpStart.time().toString() << tmpStart.toString();
+//
+//   FreeBusyPeriod p( tmpStart, tmpEnd );
+//   mBusyPeriods.append( p );
+//
+//   return true;
+// }
+//
+//     KDateTime mDtStart;
+//     KDateTime mDtEnd;                  // end datetime
+//     FreeBusyPeriod::List mBusyPeriods; // list of periods
+//
+// };
+//
+// } // Namespace
+
+
+
+
+
+
+
+namespace Kolab {
+    namespace FreebusyUtils {
+
+static QString createUuid()
+{
+    const QString uuid = QUuid::createUuid().toString();
+    return uuid.mid(1, uuid.size()-2);
+}
+
+Kolab::Period addLocalPeriod(  const KDateTime &eventStart, const KDateTime &eventEnd, const KDateTime &mDtStart, const KDateTime &mDtEnd)
+{
+  KDateTime tmpStart;
+  KDateTime tmpEnd;
+
+  //Check to see if the start *or* end of the event is
+  //between the start and end of the freebusy dates.
+  if ( !( ( ( mDtStart <= eventStart) &&
+            ( eventStart <= mDtEnd ) ) ||
+          ( ( mDtStart <= eventEnd ) &&
+            ( eventEnd <= mDtEnd ) ) ) ) {
+    qDebug() << "event is not within the fb range, skipping";
+    return Kolab::Period();
+  }
+
+  if ( eventStart < mDtStart ) { //eventStart is before start
+    tmpStart = mDtStart;
+  } else {
+    tmpStart = eventStart;
+  }
+
+//   qDebug() << eventEnd.date().toString() << eventEnd.time().toString() << mDtEnd.toString();
+  if ( eventEnd > mDtEnd ) { //event end is after dtEnd
+    tmpEnd = mDtEnd;
+  } else {
+    tmpEnd = eventEnd;
+  }
+  Q_ASSERT(tmpStart.isValid());
+  Q_ASSERT(tmpEnd.isValid());
+  if (tmpStart.isDateOnly()) {
+    tmpStart.setTime(QTime(0,0,0,0));
+  }
+  if (tmpEnd.isDateOnly()) {
+    tmpEnd.setTime(QTime(23,59,59,999)); //The window is inclusive
+  }
+  return Kolab::Period(Kolab::Conversion::fromDate(tmpStart), Kolab::Conversion::fromDate(tmpEnd));
+}
+
+Freebusy generateFreeBusy(const std::vector< Event >& events, const cDateTime& startDate, const cDateTime& endDate)
+{
+    QList<KCalCore::Event::Ptr> list;
+    foreach (const Kolab::Event &e, events) {
+        list.append(Kolab::Conversion::toKCalCore(e));
+    }
+    KCalCore::Person::Ptr person(new KCalCore::Person("dummyname", "dummyemail"));
+    return generateFreeBusy(list, Kolab::Conversion::toDate(startDate), Kolab::Conversion::toDate(endDate), person);
+}
+
+Freebusy generateFreeBusy(const QList<KCalCore::Event::Ptr>& events, const KDateTime& startDate, const KDateTime& endDate, const KCalCore::Person::Ptr &organizer)
+{
+    /*
+     * TODO the conversion of date-only values to date-time is only necessary because xCal doesn't allow date only. iCalendar doesn't seem to make this restriction so it looks like a bug.
+     */
+    KDateTime start = startDate.toUtc();
+    if (start.isDateOnly()) {
+        start.setTime(QTime(0,0,0,0));
+    }
+    KDateTime end = endDate.toUtc();
+    if (end.isDateOnly()) {
+        end.addDays(1);
+        end.setTime(QTime(0,0,0,0)); //The window is inclusive
+    }
+
+    //TODO try to merge that with KCalCore::Freebusy
+    std::vector<Kolab::FreebusyPeriod> freebusyPeriods;
+    Q_FOREACH (KCalCore::Event::Ptr event, events) {    
+        // If this event is transparent it shouldn't be in the freebusy list.
+        if ( event->transparency() == KCalCore::Event::Transparent ) {
+            continue;
+        }
+
+        if ( event->hasRecurrenceId() ) {
+            continue; //TODO apply special period exception (duration could be different)
+        }
+
+        const KDateTime eventStart = event->dtStart().toUtc();
+        const KDateTime eventEnd = event->dtEnd().toUtc();
+
+        std::vector <Kolab::Period> periods;
+        if ( event->recurs() ) {
+            const KCalCore::Duration duration( eventStart, eventEnd );
+            const KCalCore::DateTimeList list = event->recurrence()->timesInInterval(start, end);
+            Q_FOREACH (const KDateTime &dt, list) {
+                const KDateTime utc = dt.toUtc();
+                const Kolab::Period &period = addLocalPeriod(utc, duration.end(utc), start, end);
+                if (period.isValid()) {
+                    periods.push_back(period);
+                }
+            }
+        } else {
+            const Kolab::Period &period = addLocalPeriod(eventStart, eventEnd, start, end);
+            if (period.isValid()) {
+                periods.push_back(period);
+            }
+        }
+        if (!periods.empty()) {
+            Kolab::FreebusyPeriod period;
+            period.setPeriods(periods);
+            //TODO get busy type from event (out-of-office, tentative)
+            period.setType(Kolab::FreebusyPeriod::Busy);
+            period.setEvent(Kolab::Conversion::toStdString(event->uid()), Kolab::Conversion::toStdString(event->summary()), Kolab::Conversion::toStdString(event->location()));
+            freebusyPeriods.push_back(period);
+        }
+    }
+
+    Kolab::Freebusy freebusy;
+    
+    freebusy.setStart(Kolab::Conversion::fromDate(start));
+    freebusy.setEnd(Kolab::Conversion::fromDate(end));
+    freebusy.setPeriods(freebusyPeriods);
+    freebusy.setUid(createUuid().toStdString());
+    freebusy.setTimestamp(Kolab::Conversion::fromDate(KDateTime::currentUtcDateTime()));
+    if (organizer) {
+        freebusy.setOrganizer(ContactReference(Kolab::ContactReference::EmailReference, Kolab::Conversion::toStdString(organizer->email()), Kolab::Conversion::toStdString(organizer->name())));
+    }
+    
+    return freebusy;
+}
+
+Freebusy aggregateFreeBusy(const std::vector< Freebusy >& fbList, const std::string &organizerEmail, const std::string &organizerName, bool simple)
+{
+    std::vector <Kolab::FreebusyPeriod > periods;
+
+    KDateTime start;
+    KDateTime end;
+    Q_FOREACH (const Freebusy &fb, fbList) {
+
+        const KDateTime &tmpStart = Kolab::Conversion::toDate(fb.start());
+        if (!start.isValid() || tmpStart < start) {
+            start = tmpStart;
+        }
+        const KDateTime &tmpEnd = Kolab::Conversion::toDate(fb.end());
+        if (!end.isValid() || tmpEnd > end) {
+            end = tmpEnd;
+        }
+
+        Q_FOREACH (const Kolab::FreebusyPeriod &period, fb.periods()) {
+            Kolab::FreebusyPeriod simplifiedPeriod;
+            simplifiedPeriod.setPeriods(period.periods());
+            simplifiedPeriod.setType(period.type());
+            if (!simple) { //Don't copy and reset to avoid unintentional information leaking into simple lists
+                simplifiedPeriod.setEvent(period.eventSummary(), period.eventUid(), period.eventLocation());
+            }
+            periods.push_back(simplifiedPeriod);
+        }
+    }
+    
+    Freebusy aggregateFB;
+
+    aggregateFB.setStart(Kolab::Conversion::fromDate(start));
+    aggregateFB.setEnd(Kolab::Conversion::fromDate(end));
+    aggregateFB.setPeriods(periods);
+    aggregateFB.setUid(createUuid().toStdString());
+    aggregateFB.setTimestamp(Kolab::Conversion::fromDate(KDateTime::currentUtcDateTime()));
+    aggregateFB.setOrganizer(ContactReference(Kolab::ContactReference::EmailReference, organizerEmail, organizerName));
+    return aggregateFB;
+}
+
+std::string toIFB(const Kolab::Freebusy &freebusy)
+{
+    KCalCore::FreeBusy::Ptr fb(new KCalCore::FreeBusy(Kolab::Conversion::toDate(freebusy.start()), Kolab::Conversion::toDate(freebusy.end())));
+    KCalCore::FreeBusyPeriod::List list;
+    Q_FOREACH (const Kolab::FreebusyPeriod &fbPeriod, freebusy.periods()) {
+        Q_FOREACH (const Kolab::Period &p, fbPeriod.periods()) {
+            KCalCore::FreeBusyPeriod period(Kolab::Conversion::toDate(p.start), Kolab::Conversion::toDate(p.end));
+//             period.setSummary("summary"); Doesn't even work. X-SUMMARY is read though (just not written out)
+            //TODO
+            list.append(period);
+            
+        }
+    }
+    fb->addPeriods(list);
+
+    fb->setUid(QString::fromStdString(freebusy.uid()));
+    fb->setOrganizer(KCalCore::Person::Ptr(new KCalCore::Person(Conversion::fromStdString(freebusy.organizer().name()), Conversion::fromStdString(freebusy.organizer().email()))));
+    fb->setLastModified(Kolab::Conversion::toDate(freebusy.timestamp()));
+
+    KCalCore::ICalFormat format;
+    format.setApplication("libkolab", KOLAB_VERSION_STRING);
+    QString data = format.createScheduleMessage( fb, KCalCore::iTIPPublish );
+    return Conversion::toStdString(data);
+}
+
+    }
+}
diff --git a/src/freebusy/freebusy.h b/src/freebusy/freebusy.h
new file mode 100644
index 0000000..3781db9
--- /dev/null
+++ b/src/freebusy/freebusy.h
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef FREEBUSY_H
+#define FREEBUSY_H
+
+#include "kolab_export.h"
+#include <kolabevent.h>
+#include <kolabfreebusy.h>
+#include <kcalcore/event.h>
+
+namespace Kolab {
+    namespace FreebusyUtils {
+
+KOLAB_EXPORT Freebusy generateFreeBusy(const QList<KCalCore::Event::Ptr>& events, const KDateTime& startDate, const KDateTime& endDate, const KCalCore::Person::Ptr &organizer);
+KOLAB_EXPORT std::string toIFB(const Kolab::Freebusy &);
+
+Kolab::Freebusy generateFreeBusy(const std::vector<Kolab::Event> &events, const Kolab::cDateTime &startDate, const Kolab::cDateTime &endDate);
+KOLAB_EXPORT Kolab::Freebusy aggregateFreeBusy(const std::vector<Kolab::Freebusy> &fbs, const std::string &organizerEmail, const std::string &organizerName, bool simple = true);
+
+    }
+}
+
+#endif // FREEBUSY_H
diff --git a/src/icalendar/CMakeLists.txt b/src/icalendar/CMakeLists.txt
new file mode 100644
index 0000000..ee276d6
--- /dev/null
+++ b/src/icalendar/CMakeLists.txt
@@ -0,0 +1,15 @@
+
+set (ICALENDAR_SRCS
+    ${CMAKE_CURRENT_SOURCE_DIR}/icalendar.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/imip.cpp
+    PARENT_SCOPE)
+
+if(PYTHON_BINDINGS)
+    message("building python bindings")
+    add_subdirectory(python)
+endif(PYTHON_BINDINGS)
+
+if(PHP_BINDINGS)
+    message("building php bindings")
+    add_subdirectory(php)
+endif(PHP_BINDINGS)
diff --git a/src/icalendar/icalendar.cpp b/src/icalendar/icalendar.cpp
new file mode 100644
index 0000000..b94f5e9
--- /dev/null
+++ b/src/icalendar/icalendar.cpp
@@ -0,0 +1,169 @@
+/*
+    <one line to give the library's name and an idea of what it does.>
+    Copyright (C) 2012  Christian Mollekopf <chrigi_1@fastmail.fm>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+
+#include "icalendar.h"
+#include "imip.h"
+#include "kolab_version.h"
+#include <conversion/kcalconversion.h>
+#include <conversion/commonconversion.h>
+#include <mime/mimeutils.h>
+#include <kcalcore/event.h>
+#include <kcalcore/memorycalendar.h>
+#include <kcalcore/icalformat.h>
+#include <kmime/kmime_message.h>
+// #include <klocalizedstring.h>
+#include <kdebug.h>
+#include <iostream>
+
+namespace Kolab {
+
+std::string toICal(const std::vector<Event> &events)
+{
+    KCalCore::Calendar::Ptr calendar(new KCalCore::MemoryCalendar(Kolab::Conversion::getTimeSpec(true, std::string())));
+    foreach (const Event &event, events) {
+        KCalCore::Event::Ptr kcalEvent = Conversion::toKCalCore(event);
+        kcalEvent->setCreated(KDateTime::currentUtcDateTime()); //sets dtstamp
+        calendar->addEvent(kcalEvent);
+    }
+    KCalCore::ICalFormat format;
+    format.setApplication("libkolab", KOLAB_VERSION_STRING);
+//     qDebug() << format.createScheduleMessage(calendar->events().first(), KCalCore::iTIPRequest);
+
+    return Conversion::toStdString(format.toString(calendar));
+    
+}
+
+std::vector< Event > fromICalEvents(const std::string &input)
+{
+    KCalCore::Calendar::Ptr calendar(new KCalCore::MemoryCalendar(Kolab::Conversion::getTimeSpec(true, std::string())));
+    KCalCore::ICalFormat format;
+    format.setApplication("libkolab", KOLAB_VERSION_STRING);
+    format.fromString(calendar, Conversion::fromStdString(input));
+    std::vector<Event> events;
+    foreach (const KCalCore::Event::Ptr &event, calendar->events()) {
+        events.push_back(Conversion::fromKCalCore(*event));
+    }
+    return events;
+}
+
+ITipHandler::ITipHandler()
+:   mMethod(iTIPNoMethod)
+{
+}
+
+
+ITipHandler::ITipMethod mapFromKCalCore(KCalCore::iTIPMethod method)
+{
+    Q_ASSERT((int)KCalCore::iTIPPublish == (int)ITipHandler::iTIPPublish);
+    Q_ASSERT((int)KCalCore::iTIPNoMethod == (int)ITipHandler::iTIPNoMethod);
+    return static_cast<ITipHandler::ITipMethod>(method);
+}
+
+KCalCore::iTIPMethod mapToKCalCore(ITipHandler::ITipMethod method)
+{
+    Q_ASSERT((int)KCalCore::iTIPPublish == (int)ITipHandler::iTIPPublish);
+    Q_ASSERT((int)KCalCore::iTIPNoMethod == (int)ITipHandler::iTIPNoMethod);
+    return static_cast<KCalCore::iTIPMethod>(method);
+}
+
+
+std::string ITipHandler::toITip(const Event &event, ITipHandler::ITipMethod method) const
+{
+    KCalCore::ICalFormat format;
+    format.setApplication("libkolab", KOLAB_VERSION_STRING);
+    KCalCore::iTIPMethod m = mapToKCalCore(method);
+    if (m == KCalCore::iTIPNoMethod) {
+        return std::string();
+    }
+//     kDebug() << event.start().
+/* TODO
+ * DTSTAMP is created
+ * CREATED is current timestamp
+ * LASTMODIFIED is lastModified
+ * 
+ * Double check if that is correct.
+ *
+ * I think DTSTAMP should be the current timestamp, and CREATED should be the creation date.
+ */
+    KCalCore::Event::Ptr e = Conversion::toKCalCore(event);
+    return Conversion::toStdString(format.createScheduleMessage(e, m));
+}
+
+
+std::vector< Event > ITipHandler::fromITip(const std::string &string)
+{
+    KCalCore::Calendar::Ptr calendar(new KCalCore::MemoryCalendar(KDateTime::Spec(KDateTime::UTC)));
+    KCalCore::ICalFormat format;
+    KCalCore::ScheduleMessage::Ptr msg= format.parseScheduleMessage(calendar, Conversion::fromStdString(string));
+    KCalCore::Event::Ptr event = msg->event().dynamicCast<KCalCore::Event>();
+    std::vector< Event > events;
+    events.push_back(Conversion::fromKCalCore(*event));
+    mMethod = mapFromKCalCore(msg->method());
+    return events;
+}
+
+ITipHandler::ITipMethod ITipHandler::method() const
+{
+    return mMethod;
+}
+
+std::string ITipHandler::toIMip(const Event &event , ITipHandler::ITipMethod m, std::string from, bool bccMe) const
+{
+    KCalCore::Event::Ptr e = Conversion::toKCalCore(event);
+//     e->recurrence()->addRDateTime(e->dtStart()); //FIXME The createScheduleMessage converts everything to utc without a recurrence.
+    KCalCore::ICalFormat format;
+    format.setApplication("libkolab", KOLAB_VERSION_STRING);
+    KCalCore::iTIPMethod method = mapToKCalCore(m);
+    const QString &messageText = format.createScheduleMessage( e, method );
+    //This code is mostly from MailScheduler::performTransaction
+    if ( method == KCalCore::iTIPRequest ||
+        method == KCalCore::iTIPCancel ||
+        method == KCalCore::iTIPAdd ||
+        method == KCalCore::iTIPDeclineCounter ) {
+        return Conversion::toStdString(QString(mailAttendees(e, bccMe, messageText)));
+    } else {
+        QString subject;
+        if ( e && method == KCalCore::iTIPCounter ) {
+            subject = QString( "Counter proposal: %1" ).arg(e->summary());
+        }
+        return Conversion::toStdString(QString(mailOrganizer( e, Conversion::fromStdString(from), bccMe, messageText, subject)));
+    }
+    return std::string();
+}
+
+std::vector< Event > ITipHandler::fromIMip(const std::string &input)
+{
+    KMime::Message::Ptr msg = KMime::Message::Ptr(new KMime::Message);
+    msg->setContent( Conversion::fromStdString(input).toUtf8() );
+    msg->parse();
+    msg->content(KMime::ContentIndex());
+
+    KMime::Content *c = Kolab::Mime::findContentByType(msg, "text/calendar");
+    if (!c) {
+        qWarning() << "could not find text/calendar part";
+        return std::vector< Event >();
+    }
+    return fromITip(Conversion::toStdString(QString(c->decodedContent())));
+}
+
+
+
+
+}
diff --git a/src/icalendar/icalendar.h b/src/icalendar/icalendar.h
new file mode 100644
index 0000000..10f1267
--- /dev/null
+++ b/src/icalendar/icalendar.h
@@ -0,0 +1,80 @@
+/*
+    <one line to give the library's name and an idea of what it does.>
+    Copyright (C) 2012  Christian Mollekopf <chrigi_1@fastmail.fm>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+
+#ifndef ICALENDAR_H
+#define ICALENDAR_H
+
+#ifndef SWIG
+#include "kolab_export.h"
+#else
+/* No export/import SWIG interface files */
+#define KOLAB_EXPORT
+#endif
+
+#include <kolabevent.h>
+
+namespace Kolab {
+
+    /**
+     * Takes a list of events and writes them to an iCal object.
+     *
+     */
+    KOLAB_EXPORT std::string toICal(const std::vector<Kolab::Event> &);
+    /**
+     * Takes an iCal object and returns the contained events.
+     */
+    KOLAB_EXPORT std::vector<Kolab::Event> fromICalEvents(const std::string &);
+
+    class KOLAB_EXPORT ITipHandler {
+    public:
+        ITipHandler();
+        enum ITipMethod {
+            iTIPPublish,       /**< Event, to-do, journal or freebusy posting */
+            iTIPRequest,       /**< Event, to-do or freebusy scheduling request */
+            iTIPReply,         /**< Event, to-do or freebusy reply to request */
+            iTIPAdd,           /**< Event, to-do or journal additional property request */
+            iTIPCancel,        /**< Event, to-do or journal cancellation notice */
+            iTIPRefresh,       /**< Event or to-do description update request */
+            iTIPCounter,       /**< Event or to-do submit counter proposal */
+            iTIPDeclineCounter,/**< Event or to-do decline a counter proposal */
+            iTIPNoMethod       /**< No method */
+        };
+        
+        std::string toIMip(const Kolab::Event &, ITipMethod, std::string from, bool bbcMe = false) const;
+        std::vector<Kolab::Event> fromIMip(const std::string &);
+
+        /**
+         * Create iTip message from single event
+         */
+        std::string toITip(const Kolab::Event &, ITipMethod) const;
+
+        /**
+         * Parse iTip message with a single event
+         */
+        std::vector<Kolab::Event> fromITip(const std::string &);
+        ITipMethod method() const;
+    private:
+        ITipMethod mMethod;
+    };
+
+
+}
+
+#endif // ICALENDAR_H
diff --git a/src/icalendar/icalendar.i b/src/icalendar/icalendar.i
new file mode 100644
index 0000000..62156e7
--- /dev/null
+++ b/src/icalendar/icalendar.i
@@ -0,0 +1,13 @@
+%{
+    /* This macro ensures that return vectors remain a vector also in python and are not converted to tuples */
+    #define SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
+
+    #include "icalendar.h"
+%}
+
+%include "std_string.i"
+
+%import(module="kolabformat") <kolabevent.h>
+%import "../shared.i"
+
+%include "icalendar.h"
\ No newline at end of file
diff --git a/src/icalendar/imip.cpp b/src/icalendar/imip.cpp
new file mode 100644
index 0000000..d7cea55
--- /dev/null
+++ b/src/icalendar/imip.cpp
@@ -0,0 +1,239 @@
+/*
+    <one line to give the library's name and an idea of what it does.>
+    Copyright (C) 2012  Christian Mollekopf <chrigi_1@fastmail.fm>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+
+#include "imip.h"
+
+#include <kcalutils/incidenceformatter.h>
+#include <kpimutils/email.h>
+#include <kmime/kmime_message.h>
+#include <QDebug>
+// #include <klocalizedstring.h>
+#include <ksystemtimezone.h>
+#include <kdebug.h>
+#include <QTime>
+/*
+ * The code in here is copy paste work from kdepim/calendarsupport.
+ *
+ * We need to refactor the code there and move the relevant parts to kdepimlibs to make it reusable.
+ *
+ *
+ */
+
+//From MailClient::send
+KMime::Message::Ptr createMessage( const QString &from, const QString &_to,
+                       const QString &cc, const QString &subject,
+                       const QString &body, bool hidden, bool bccMe,
+                       const QString &attachment/*, const QString &mailTransport */)
+{
+  Q_UNUSED( hidden );
+
+  const bool outlookConformInvitation = false;
+  QString userAgent = "libkolab";
+
+  // We must have a recipients list for most MUAs. Thus, if the 'to' list
+  // is empty simply use the 'from' address as the recipient.
+  QString to = _to;
+  if ( to.isEmpty() ) {
+    to = from;
+  }
+  kDebug() << "\nFrom:" << from
+           << "\nTo:" << to
+           << "\nCC:" << cc
+           << "\nSubject:" << subject << "\nBody: \n" << body
+           << "\nAttachment:\n" << attachment
+           /*<< "\nmailTransport: " << mailTransport*/;
+
+  // Now build the message we like to send. The message KMime::Message::Ptr instance
+  // will be the root message that has 2 additional message. The body itself and
+  // the attached cal.ics calendar file.
+  KMime::Message::Ptr message = KMime::Message::Ptr( new KMime::Message );
+  message->contentTransferEncoding()->clear();  // 7Bit, decoded.
+
+  // Set the headers
+  message->userAgent()->fromUnicodeString(userAgent, "utf-8" );
+  message->from()->fromUnicodeString( from, "utf-8" );
+  message->to()->fromUnicodeString( to, "utf-8" );
+  message->cc()->fromUnicodeString( cc, "utf-8" );
+  if( bccMe ) {
+    message->bcc()->fromUnicodeString( from, "utf-8" ); //from==me, right?
+  }
+  message->date()->setDateTime( KDateTime::currentLocalDateTime().dateTime() );
+  message->subject()->fromUnicodeString( subject, "utf-8" );
+
+  if ( outlookConformInvitation ) {
+    message->contentType()->setMimeType( "text/calendar" );
+    message->contentType()->setCharset( "utf-8" );
+    message->contentType()->setName( QLatin1String( "cal.ics" ), "utf-8" );
+    message->contentType()->setParameter( QLatin1String( "method" ), QLatin1String( "request" ) );
+
+    if ( !attachment.isEmpty() ) {
+      KMime::Headers::ContentDisposition *disposition =
+        new KMime::Headers::ContentDisposition( message.get() );
+      disposition->setDisposition( KMime::Headers::CDinline );
+      message->setHeader( disposition );
+      message->contentTransferEncoding()->setEncoding( KMime::Headers::CEquPr );
+      message->setBody( KMime::CRLFtoLF( attachment.toUtf8() ) );
+    }
+  } else {
+    // We need to set following 4 lines by hand else KMime::Content::addContent
+    // will create a new Content instance for us to attach the main message
+    // what we don't need cause we already have the main message instance where
+    // 2 additional messages are attached.
+    KMime::Headers::ContentType *ct = message->contentType();
+    ct->setMimeType( "multipart/mixed" );
+    ct->setBoundary( KMime::multiPartBoundary() );
+    ct->setCategory( KMime::Headers::CCcontainer );
+
+    // Set the first multipart, the body message.
+    KMime::Content *bodyMessage = new KMime::Content;
+    KMime::Headers::ContentDisposition *bodyDisposition =
+      new KMime::Headers::ContentDisposition( bodyMessage );
+    bodyDisposition->setDisposition( KMime::Headers::CDinline );
+    bodyMessage->contentType()->setMimeType( "text/plain" );
+    bodyMessage->contentType()->setCharset( "utf-8" );
+    bodyMessage->contentTransferEncoding()->setEncoding( KMime::Headers::CEquPr );
+    bodyMessage->setBody( KMime::CRLFtoLF( body.toUtf8() ) );
+    message->addContent( bodyMessage );
+
+    // Set the sedcond multipart, the attachment.
+    if ( !attachment.isEmpty() ) {
+      KMime::Content *attachMessage = new KMime::Content;
+      KMime::Headers::ContentDisposition *attachDisposition =
+        new KMime::Headers::ContentDisposition( attachMessage );
+      attachDisposition->setDisposition( KMime::Headers::CDattachment );
+      attachMessage->contentType()->setMimeType( "text/calendar" );
+      attachMessage->contentType()->setCharset( "utf-8" );
+      attachMessage->contentType()->setName( QLatin1String( "cal.ics" ), "utf-8" );
+      attachMessage->contentType()->setParameter( QLatin1String( "method" ),
+                                                  QLatin1String( "request" ) );
+      attachMessage->setHeader( attachDisposition );
+      attachMessage->contentTransferEncoding()->setEncoding( KMime::Headers::CEquPr );
+      attachMessage->setBody( KMime::CRLFtoLF( attachment.toUtf8() ) );
+      message->addContent( attachMessage );
+    }
+  }
+
+  // Job done, attach the both multiparts and assemble the message.
+  message->assemble();
+  return message;
+}
+
+//From MailClient::mailAttendees
+QByteArray mailAttendees( const KCalCore::IncidenceBase::Ptr &incidence,
+//                                 const KPIMIdentities::Identity &identity,
+                                bool bccMe, const QString &attachment
+                                /*const QString &mailTransport */)
+{
+  KCalCore::Attendee::List attendees = incidence->attendees();
+  if ( attendees.isEmpty() ) {
+    kWarning() << "There are no attendees to e-mail";
+    return QByteArray();
+  }
+
+  const QString from = incidence->organizer()->fullName();
+  const QString organizerEmail = incidence->organizer()->email();
+
+  QStringList toList;
+  QStringList ccList;
+  const int numberOfAttendees( attendees.count() );
+  for ( int i=0; i<numberOfAttendees; ++i ) {
+    KCalCore::Attendee::Ptr a = attendees.at(i);
+
+    const QString email = a->email();
+    if ( email.isEmpty() ) {
+      continue;
+    }
+
+    // In case we (as one of our identities) are the organizer we are sending
+    // this mail. We could also have added ourselves as an attendee, in which
+    // case we don't want to send ourselves a notification mail.
+    if ( organizerEmail == email ) {
+      continue;
+    }
+
+    // Build a nice address for this attendee including the CN.
+    QString tname, temail;
+    const QString username = KPIMUtils::quoteNameIfNecessary( a->name() );
+    // ignore the return value from extractEmailAddressAndName() because
+    // it will always be false since tusername does not contain "@domain".
+    KPIMUtils::extractEmailAddressAndName( username, temail/*byref*/, tname/*byref*/ );
+    tname += QLatin1String( " <" ) + email + QLatin1Char( '>' );
+
+    // Optional Participants and Non-Participants are copied on the email
+    if ( a->role() == KCalCore::Attendee::OptParticipant ||
+         a->role() == KCalCore::Attendee::NonParticipant ) {
+      ccList << tname;
+    } else {
+      toList << tname;
+    }
+  }
+  if( toList.isEmpty() && ccList.isEmpty() ) {
+    // Not really to be called a groupware meeting, eh
+    kWarning() << "There are really no attendees to e-mail";
+    return QByteArray();
+  }
+  QString to;
+  if ( !toList.isEmpty() ) {
+    to = toList.join( QLatin1String( ", " ) );
+  }
+  QString cc;
+  if ( !ccList.isEmpty() ) {
+    cc = ccList.join( QLatin1String( ", " ) );
+  }
+
+  QString subject;
+  if ( incidence->type() != KCalCore::Incidence::TypeFreeBusy ) {
+    KCalCore::Incidence::Ptr inc = incidence.staticCast<KCalCore::Incidence>();
+    subject = inc->summary();
+  } else {
+    subject = QString( "Free Busy Object" );
+  }
+
+  const QString body =
+    KCalUtils::IncidenceFormatter::mailBodyStr( incidence, KSystemTimeZones::local() );
+
+  return createMessage(/* identity, */from, to, cc, subject, body, false,
+               bccMe, attachment/*, mailTransport */)->encodedContent();
+}
+
+QByteArray mailOrganizer( const KCalCore::IncidenceBase::Ptr &incidence,
+//                                 const KPIMIdentities::Identity &identity,
+                                const QString &from, bool bccMe,
+                                const QString &attachment,
+                                const QString &sub/*, const QString &mailTransport*/ )
+{
+  const QString to = incidence->organizer()->fullName();
+  QString subject = sub;
+
+  if ( incidence->type() != KCalCore::Incidence::TypeFreeBusy ) {
+    KCalCore::Incidence::Ptr inc = incidence.staticCast<KCalCore::Incidence>();
+    if ( subject.isEmpty() ) {
+      subject = inc->summary();
+    }
+  } else {
+    subject = QString( "Free Busy Message" );
+  }
+
+  QString body = KCalUtils::IncidenceFormatter::mailBodyStr( incidence, KSystemTimeZones::local() );
+
+  return createMessage( /*identity, */from, to, QString(), subject, body, false,
+               bccMe, attachment/*, mailTransport */)->encodedContent();
+}
+
diff --git a/src/icalendar/imip.h b/src/icalendar/imip.h
new file mode 100644
index 0000000..2ee747e
--- /dev/null
+++ b/src/icalendar/imip.h
@@ -0,0 +1,34 @@
+/*
+    <one line to give the library's name and an idea of what it does.>
+    Copyright (C) 2012  Christian Mollekopf <chrigi_1@fastmail.fm>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Lesser General Public
+    License as published by the Free Software Foundation; either
+    version 2.1 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Lesser General Public License for more details.
+
+    You should have received a copy of the GNU Lesser General Public
+    License along with this library; if not, write to the Free Software
+    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+
+#ifndef IMIP_H
+#define IMIP_H
+#include <QByteArray>
+#include <kcalcore/incidencebase.h>
+
+QByteArray mailAttendees( const KCalCore::IncidenceBase::Ptr &incidence,
+                                bool bccMe, const QString &attachment );
+
+QByteArray mailOrganizer( const KCalCore::IncidenceBase::Ptr &incidence,
+                                const QString &from, bool bccMe,
+                                const QString &attachment,
+                                const QString &sub );
+
+#endif // IMIP_H
diff --git a/src/icalendar/php/CMakeLists.txt b/src/icalendar/php/CMakeLists.txt
new file mode 100644
index 0000000..3aea015
--- /dev/null
+++ b/src/icalendar/php/CMakeLists.txt
@@ -0,0 +1,4 @@
+#Generate PHP wrapper
+include_directories(../)
+include(SWIGUtils)
+generatePHPBindings(kolabicalendar ../icalendar.i)
diff --git a/src/icalendar/python/CMakeLists.txt b/src/icalendar/python/CMakeLists.txt
new file mode 100644
index 0000000..0b842a4
--- /dev/null
+++ b/src/icalendar/python/CMakeLists.txt
@@ -0,0 +1,3 @@
+include_directories(../)
+include(SWIGUtils)
+generatePythonBindings(icalendar ../icalendar.i)
diff --git a/src/kolabformat/errorhandler.cpp b/src/kolabformat/errorhandler.cpp
new file mode 100644
index 0000000..91021f4
--- /dev/null
+++ b/src/kolabformat/errorhandler.cpp
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "errorhandler.h"
+
+#include <qdebug.h>
+#include <QTime>
+#include <QStringList>
+#include <qmutex.h>
+#include <iostream>
+
+#include <kolabformat.h>
+
+QDebug operator<<(QDebug dbg, const std::string &s)
+{
+    dbg.nospace() << QString::fromStdString(s);
+    return dbg.space();
+}
+
+namespace Kolab {
+
+DebugStream::DebugStream()
+:   QIODevice()
+{
+    open(WriteOnly);
+}
+
+DebugStream::~DebugStream(){}
+
+qint64 DebugStream::writeData(const char *data, qint64 len) {
+    const QByteArray buf = QByteArray::fromRawData(data, len);
+//         qt_message_output(QtDebugMsg, buf.trimmed().constData());
+    ErrorHandler::instance().addError(m_severity, buf, m_location);
+    return len;
+}
+
+
+QMutex mutex;
+    
+void logMessage(const QString &message, const QString &file, int line, ErrorHandler::Severity s)
+{
+    ErrorHandler::instance().addError(s, message, file+" "+QString::number(line));
+}
+
+ErrorHandler::ErrorHandler()
+:   m_worstError(Debug),
+    m_debugStream(new DebugStream)
+{
+
+};
+
+QDebug ErrorHandler::debugStream(ErrorHandler::Severity severity, int line, const char* file)
+{
+    QMutexLocker locker(&mutex);
+    ErrorHandler::instance().m_debugStream->m_location = QString(QString(file) + "(" + QString::number(line)+")");
+    ErrorHandler::instance().m_debugStream->m_severity = severity;
+    return QDebug(ErrorHandler::instance().m_debugStream.data());
+}
+
+void ErrorHandler::addError(ErrorHandler::Severity s, const QString& message, const QString &location)
+{
+    QMutexLocker locker(&mutex);
+    QString filename = location;
+    if (!filename.split(QLatin1Char('/')).isEmpty()) {
+       filename = filename.split(QLatin1Char('/')).last();
+    }
+    const QString output = QTime::currentTime().toString(QLatin1String("(hh:mm:ss) ")) + filename + QLatin1String(":\t") + message;
+    std::cout << output.toStdString() << std::endl;
+    if (s == Debug) {
+        return;
+    }
+    if (s > m_worstError) {
+        m_worstError = s;
+        m_worstErrorMessage = message;
+    }
+    m_errorQueue.append(Err(s, message, location));
+}
+
+ErrorHandler::Severity ErrorHandler::error() const
+{
+    QMutexLocker locker(&mutex);
+    return m_worstError;
+}
+
+QString ErrorHandler::errorMessage() const
+{
+    QMutexLocker locker(&mutex);
+    return m_worstErrorMessage;
+}
+
+const QList< ErrorHandler::Err >& ErrorHandler::getErrors() const
+{
+    QMutexLocker locker(&mutex);
+    return m_errorQueue;
+}
+
+void ErrorHandler::clear()
+{
+    QMutexLocker locker(&mutex);
+    m_errorQueue.clear();
+    m_worstError = Debug;
+}
+
+void ErrorHandler::handleLibkolabxmlErrors()
+{
+    switch (Kolab::error()) {
+        case Kolab::Warning:
+            instance().addError(ErrorHandler::Warning, QString::fromStdString(Kolab::errorMessage()), "libkolabxml");
+            break;
+        case Kolab::Error:
+            instance().addError(ErrorHandler::Error, QString::fromStdString(Kolab::errorMessage()), "libkolabxml");
+            break;
+        case Kolab::Critical:
+            instance().addError(ErrorHandler::Critical, QString::fromStdString(Kolab::errorMessage()), "libkolabxml");
+            break;
+        default:
+            //Do nothing, there is no message available in this case
+            break;
+    }
+}
+
+
+}
diff --git a/src/kolabformat/errorhandler.h b/src/kolabformat/errorhandler.h
new file mode 100644
index 0000000..5ac5375
--- /dev/null
+++ b/src/kolabformat/errorhandler.h
@@ -0,0 +1,140 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef ERRORHANDLER_H
+#define ERRORHANDLER_H
+
+#include "kolab_export.h"
+
+#include <QString>
+#include <QList>
+#include <QDebug>
+
+namespace Kolab {
+
+class DebugStream;
+/**
+ * Kolab Error Handler
+ * 
+ * Errors are reported during an operation, but the operation might still succeed.
+ * The error handler therefore contains all errors which occured during a single operation,
+ * and must be cleared at the start of a new operation.
+ * 
+ * A user of the kolabobject classes should check ErrorHandler::error() after every operation.
+ * 
+ * all non-const functions are not for the user of this class and only exist for internal usage.
+ * 
+ * TODO: Hide everything which is not meant for the user from the interface.
+ * FIXME: Use Threadlocal storage to make this threadsafe.
+ */
+class KOLAB_EXPORT ErrorHandler
+{
+public:
+    enum Severity {
+        Debug,
+        Warning, //Warning, error could be corrected, object can be used without dataloss. This warning is also used if dataloss is acceptable because a feature is explicitly not supported.
+        Error, //Potentially corrupt object, writing the object back could result in dataloss. (Object could still be used to display the data readonly).
+        Critical //Critical error, produced object cannot be used and should be thrown away (writing back will result in dataloss).
+    };
+    
+    struct Err {
+        Err(Severity s, const QString &m, const QString &l): severity(s), message(m), location(l){};
+        Severity severity;
+        QString message;
+        QString location;
+    };
+    
+    static ErrorHandler &instance()
+    {
+        static ErrorHandler inst;
+        return inst;
+    }
+    
+    void addError(Severity s, const QString &message, const QString &location);
+    const QList <Err> &getErrors() const;
+    Severity error() const;
+    QString errorMessage() const;
+    void clear();
+    
+    /**
+     * Check for errors during the libkolabxml reading/writing process and copy them into this error handler.
+     */
+    static void handleLibkolabxmlErrors();
+    
+    static void clearErrors()
+    {
+        ErrorHandler::instance().clear();
+    }
+    
+    static bool errorOccured()
+    {
+        if (ErrorHandler::instance().error() >= Error) {
+            return true;
+        }
+        return false;
+    }
+    
+    /**
+     * Returns a debug stream to which logs errors
+     */
+    static QDebug debugStream(Severity, int line, const char* file);
+
+private:
+    ErrorHandler();
+    ErrorHandler(const ErrorHandler &);
+    ErrorHandler & operator= (const ErrorHandler &);
+    
+    Severity m_worstError;
+    QString m_worstErrorMessage;
+    QList <Err> m_errorQueue;
+    QScopedPointer<DebugStream> m_debugStream;
+};
+
+void logMessage(const QString &,const QString &, int, ErrorHandler::Severity s);
+
+#define LOG(message) logMessage(message,__FILE__, __LINE__, ErrorHandler::Debug);
+#define WARNING(message) logMessage(message,__FILE__, __LINE__, ErrorHandler::Warning);
+#define ERROR(message) logMessage(message,__FILE__, __LINE__, ErrorHandler::Error);
+#define CRITICAL(message) logMessage(message,__FILE__, __LINE__, ErrorHandler::Critical);
+
+
+class DebugStream: public QIODevice
+{
+public:
+    QString m_location;
+    ErrorHandler::Severity m_severity;
+    DebugStream();
+    virtual ~DebugStream();
+    bool isSequential() const { return true; }
+    qint64 readData(char *, qint64) { return 0; /* eof */ }
+    qint64 readLineData(char *, qint64) { return 0; /* eof */ }
+    qint64 writeData(const char *data, qint64 len);
+private:
+    Q_DISABLE_COPY(DebugStream)
+};
+
+#define Debug() Kolab::ErrorHandler::debugStream(Kolab::ErrorHandler::Debug, __LINE__, __FILE__)
+#define Warning() Kolab::ErrorHandler::debugStream(Kolab::ErrorHandler::Warning, __LINE__, __FILE__)
+#define Error() Kolab::ErrorHandler::debugStream(Kolab::ErrorHandler::Error, __LINE__, __FILE__)
+#define Critical() Kolab::ErrorHandler::debugStream(Kolab::ErrorHandler::Critical, __LINE__, __FILE__)
+
+}
+
+QDebug operator<<(QDebug dbg, const std::string &s);
+
+#endif // ERRORHANDLER_H
diff --git a/src/kolabformat/formathelpers.cpp b/src/kolabformat/formathelpers.cpp
new file mode 100644
index 0000000..b376b8c
--- /dev/null
+++ b/src/kolabformat/formathelpers.cpp
@@ -0,0 +1,95 @@
+#include "formathelpers.h"
+#include <klocalizedstring.h>
+#include "kolabdefinitions.h"
+
+namespace Kolab {
+
+static const struct {
+  const char *name;
+  const char *label;
+} folderTypeData[] = {
+  { KOLAB_FOLDER_TYPE_MAIL,    ""                      },
+  { KOLAB_FOLDER_TYPE_CONTACT, I18N_NOOP( "Contacts" ) },
+  { KOLAB_FOLDER_TYPE_EVENT,   I18N_NOOP( "Calendar" ) },
+  { KOLAB_FOLDER_TYPE_TASK,    I18N_NOOP( "Tasks" )    },
+  { KOLAB_FOLDER_TYPE_JOURNAL, I18N_NOOP( "Journal" )  },
+  { KOLAB_FOLDER_TYPE_NOTE,    I18N_NOOP( "Notes" )    },
+  { KOLAB_FOLDER_TYPE_CONFIGURATION, I18N_NOOP( "Configuration" )    },
+  { KOLAB_FOLDER_TYPE_FREEBUSY,    I18N_NOOP( "Freebusy" ) },
+  { KOLAB_FOLDER_TYPE_FILE,    I18N_NOOP( "Files" ) }
+};
+static const int numFolderTypeData = sizeof folderTypeData / sizeof *folderTypeData;
+
+std::string folderAnnotation(FolderType type, bool isDefault)
+{
+    Q_ASSERT( type >= 0 && type < LastType );
+    std::string result = folderTypeData[ type ].name;
+    if ( isDefault ) {
+        result += KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX;
+    }
+    return result;
+}
+
+FolderType folderTypeFromString(const std::string& folderTypeName)
+{
+    if ( folderTypeName == KOLAB_FOLDER_TYPE_CONTACT ||
+    folderTypeName == KOLAB_FOLDER_TYPE_CONTACT KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
+        return ContactType;
+    }
+
+    if ( folderTypeName == KOLAB_FOLDER_TYPE_EVENT ||
+        folderTypeName == KOLAB_FOLDER_TYPE_EVENT KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
+        return EventType;
+    }
+
+    if ( folderTypeName == KOLAB_FOLDER_TYPE_TASK ||
+        folderTypeName == KOLAB_FOLDER_TYPE_TASK KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
+        return TaskType;
+    }
+
+    if ( folderTypeName == KOLAB_FOLDER_TYPE_JOURNAL ||
+        folderTypeName == KOLAB_FOLDER_TYPE_JOURNAL KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
+        return JournalType;
+    }
+
+    if ( folderTypeName == KOLAB_FOLDER_TYPE_NOTE ||
+        folderTypeName == KOLAB_FOLDER_TYPE_NOTE KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
+        return NoteType;
+    }
+    
+    if ( folderTypeName == KOLAB_FOLDER_TYPE_CONFIGURATION ||
+        folderTypeName == KOLAB_FOLDER_TYPE_CONFIGURATION KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
+        return ConfigurationType;
+    }
+    
+    if ( folderTypeName == KOLAB_FOLDER_TYPE_FREEBUSY ||
+        folderTypeName == KOLAB_FOLDER_TYPE_FREEBUSY KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
+        return FreebusyType;
+    }
+
+    if ( folderTypeName == KOLAB_FOLDER_TYPE_FILE ||
+        folderTypeName == KOLAB_FOLDER_TYPE_FILE KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ) {
+        return FileType;
+    }
+
+    return MailType;
+}
+
+FolderType guessFolderTypeFromName(const std::string& name)
+{
+    for ( int i = 0; i < numFolderTypeData; ++i ) {
+        if ( name == i18n( folderTypeData[ i ].label ).toStdString() ||
+            name == folderTypeData[ i ].label ) {
+            return static_cast<FolderType>( i );
+        }
+    }
+    return MailType;
+}
+
+std::string nameForFolderType(FolderType type)
+{
+    Q_ASSERT( type >= 0 && type < LastType );
+    return i18n( folderTypeData[ type ].label ).toStdString();
+}
+
+}
diff --git a/src/kolabformat/formathelpers.h b/src/kolabformat/formathelpers.h
new file mode 100644
index 0000000..08a1fd4
--- /dev/null
+++ b/src/kolabformat/formathelpers.h
@@ -0,0 +1,43 @@
+
+#ifndef FORMATHELPERS_H
+#define FORMATHELPERS_H
+
+#include <kolab_export.h>
+#include <string>
+
+namespace Kolab {
+    
+enum FolderType {
+    MailType = 0,
+    ContactType,
+    EventType,
+    TaskType,
+    JournalType,
+    NoteType,
+    ConfigurationType,
+    FreebusyType,
+    FileType,
+    LastType
+};
+
+/**
+ * Returns the FolderType from a KOLAB_FOLDER_TYPE_* folder type string
+ */
+KOLAB_EXPORT FolderType folderTypeFromString( const std::string &folderTypeName );
+/**
+ * Returns the annotation string for a folder
+ */
+KOLAB_EXPORT std::string folderAnnotation( FolderType type, bool isDefault = false );
+/**
+ * Guesses the folder type from a user visible string
+ */
+KOLAB_EXPORT FolderType guessFolderTypeFromName( const std::string &name );
+
+/**
+ * Returns a folder name for a type
+ */
+KOLAB_EXPORT std::string nameForFolderType( FolderType type );
+
+}
+
+#endif
diff --git a/src/kolabformat/kolabdefinitions.h b/src/kolabformat/kolabdefinitions.h
new file mode 100644
index 0000000..e1d8e93
--- /dev/null
+++ b/src/kolabformat/kolabdefinitions.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef KOLABDEFINITIONS_H
+#define KOLABDEFINITIONS_H
+
+namespace Kolab {
+
+#define KOLAB_FOLDER_TYPE_MAIL    "mail"
+#define KOLAB_FOLDER_TYPE_CONTACT "contact"
+#define KOLAB_FOLDER_TYPE_EVENT   "event"
+#define KOLAB_FOLDER_TYPE_TASK    "task"
+#define KOLAB_FOLDER_TYPE_JOURNAL "journal"
+#define KOLAB_FOLDER_TYPE_NOTE    "note"
+#define KOLAB_FOLDER_TYPE_CONFIGURATION "configuration"
+#define KOLAB_FOLDER_TYPE_FREEBUSY      "freebusy"
+#define KOLAB_FOLDER_TYPE_FILE    "file"
+
+#define KOLAB_FOLDER_TYPE_DEFAULT_SUFFIX ".default"
+#define KOLAB_FOLDER_TYPE_DRAFT_SUFFIX ".drafts"
+#define KOLAB_FOLDER_TYPE_SENT_SUFFIX ".sentitems"
+#define KOLAB_FOLDER_TYPE_OUTBOX_SUFFIX ".outbox"
+#define KOLAB_FOLDER_TYPE_TRASH_SUFFIX ".wastebasket"
+#define KOLAB_FOLDER_TYPE_JUNK_SUFFIX ".junkemail"
+#define KOLAB_FOLDER_TYPE_INBOX_SUFFIX ".inbox"
+
+#define KOLAB_FOLDER_TYPE_ANNOTATION "/vendor/kolab/folder-type"
+
+#define X_KOLAB_TYPE_HEADER "X-Kolab-Type"
+#define X_KOLAB_MIME_VERSION_HEADER "X-Kolab-Mime-Version"
+#define X_KOLAB_MIME_VERSION_HEADER_COMPAT "X-Kolab-Version"
+#define KOLAB_VERSION_V2 "2.0"
+#define KOLAB_VERSION_V3 "3.0"
+
+#define KOLAB_OBJECT_FILENAME "kolab.xml"
+
+#define MIME_TYPE_XCAL "application/calendar+xml"
+#define MIME_TYPE_XCARD "application/vcard+xml"
+#define MIME_TYPE_KOLAB "application/vnd.kolab+xml"
+
+#define KOLAB_TYPE_EVENT    "application/x-vnd.kolab.event"
+#define KOLAB_TYPE_TASK    "application/x-vnd.kolab.task"
+#define KOLAB_TYPE_JOURNAL    "application/x-vnd.kolab.journal"
+#define KOLAB_TYPE_CONTACT    "application/x-vnd.kolab.contact"
+#define KOLAB_TYPE_DISTLIST_V2    "application/x-vnd.kolab.contact.distlist"
+#define KOLAB_TYPE_DISTLIST  "application/x-vnd.kolab.distribution-list"
+#define KOLAB_TYPE_NOTE   "application/x-vnd.kolab.note"
+#define KOLAB_TYPE_CONFIGURATION    "application/x-vnd.kolab.configuration"
+#define KOLAB_TYPE_DICT    "application/x-vnd.kolab.configuration.dictionary"
+#define KOLAB_TYPE_FREEBUSY    "application/x-vnd.kolab.freebusy"
+#define KOLAB_TYPE_FILE    "application/x-vnd.kolab.file"
+#define KOLAB_TYPE_RELATION "application/x-vnd.kolab.configuration.relation"
+
+enum Version {
+    KolabV2,
+    KolabV3
+};
+
+enum ObjectType {
+    InvalidObject,
+    EventObject,
+    TodoObject,
+    JournalObject,
+    ContactObject,
+    DistlistObject,
+    NoteObject,
+    DictionaryConfigurationObject,
+    FreebusyObject,
+    RelationConfigurationObject
+};
+
+}
+
+#endif
diff --git a/src/kolabformat/kolabobject.cpp b/src/kolabformat/kolabobject.cpp
new file mode 100644
index 0000000..3fbe74a
--- /dev/null
+++ b/src/kolabformat/kolabobject.cpp
@@ -0,0 +1,755 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "kolabobject.h"
+#include "v2helpers.h"
+#include "kolabdefinitions.h"
+#include "errorhandler.h"
+#include "kolab_version.h"
+
+#include "kolabbase.h"
+#include <kolabformatV2/journal.h>
+#include <kolabformatV2/task.h>
+#include <kolabformatV2/event.h>
+#include <kolabformatV2/contact.h>
+#include <kolabformatV2/distributionlist.h>
+#include <kolabformatV2/note.h>
+#include <mime/mimeutils.h>
+#include <conversion/kcalconversion.h>
+#include <conversion/kabcconversion.h>
+#include <conversion/kolabconversion.h>
+#include <conversion/commonconversion.h>
+#include <akonadi/notes/noteutils.h>
+#include <kolabformat.h>
+#include <KDebug>
+#include <kolabconfiguration.h>
+namespace Kolab {
+
+
+static inline QString eventKolabType() { return QString::fromLatin1(KOLAB_TYPE_EVENT); };
+static inline QString todoKolabType() { return QString::fromLatin1(KOLAB_TYPE_TASK); };
+static inline QString journalKolabType() { return QString::fromLatin1(KOLAB_TYPE_JOURNAL); };
+static inline QString contactKolabType() { return QString::fromLatin1(KOLAB_TYPE_CONTACT); };
+static inline QString distlistKolabType() { return QString::fromLatin1(KOLAB_TYPE_DISTLIST); }
+static inline QString distlistKolabTypeCompat() { return QString::fromLatin1(KOLAB_TYPE_DISTLIST_V2); }
+static inline QString noteKolabType() { return QString::fromLatin1(KOLAB_TYPE_NOTE); }
+static inline QString configurationKolabType() { return QString::fromLatin1(KOLAB_TYPE_CONFIGURATION); }
+static inline QString dictKolabType() { return QString::fromLatin1(KOLAB_TYPE_DICT); }
+static inline QString freebusyKolabType() { return QString::fromLatin1(KOLAB_TYPE_FREEBUSY); }
+static inline QString relationKolabType() { return QString::fromLatin1(KOLAB_TYPE_RELATION); }
+
+static inline QString xCalMimeType() { return QString::fromLatin1(MIME_TYPE_XCAL); };
+static inline QString xCardMimeType() { return QString::fromLatin1(MIME_TYPE_XCARD); };
+static inline QString kolabMimeType() { return QString::fromLatin1(MIME_TYPE_KOLAB); };
+
+KCalCore::Event::Ptr readV2EventXML(const QByteArray& xmlData, QStringList& attachments)
+{
+    return fromXML<KCalCore::Event::Ptr, KolabV2::Event>(xmlData, attachments);
+}
+
+RelationMember parseMemberUrl(const QString &string)
+{
+    RelationMember member;
+    QUrl url(QUrl::fromPercentEncoding(string.toLatin1()));
+    QList<QByteArray> path = url.encodedPath().split('/');
+    // qDebug() << path;
+    int start = path.indexOf("user");
+    if (start < 0) {
+        kWarning() << "Couldn't find \"user\" in path: " << path;
+        return RelationMember();
+    }
+    path = path.mid(start + 1);
+    if (path.size() < 2) {
+        kWarning() << "Incomplete path: " << path;
+        return RelationMember();
+    }
+    // user-name
+    path.removeFirst();
+    member.uid = path.takeLast().toLong();
+    member.mailbox = path;
+    member.messageId = url.queryItemValue("message-id");
+    member.subject = url.queryItemValue("subject");
+    member.date = url.queryItemValue("date");
+    // qDebug() << member.uid << member.mailbox;
+    return member;
+}
+
+static QByteArray join(const QList<QByteArray> &list, const QByteArray &c)
+{
+    QByteArray result;
+    Q_FOREACH (const QByteArray &a, list) {
+        result += a + c;
+    }
+    result.chop(c.size());
+    return result;
+}
+
+KOLAB_EXPORT QString generateMemberUrl(const RelationMember &member)
+{
+    QUrl url;
+    url.setScheme("imap");
+    QList<QByteArray> path;
+    path << "user";
+    path << "localuser@localhost";
+    path << member.mailbox;
+    path << QByteArray::number(member.uid);
+    url.setPath(QLatin1String("/") + join(path, "/"));
+
+    QList<QPair<QString, QString> > queryItems;
+    queryItems.append(qMakePair(QString::fromLatin1("message-id"), member.messageId));
+    queryItems.append(qMakePair(QString::fromLatin1("subject"), member.subject));
+    queryItems.append(qMakePair(QString::fromLatin1("date"), member.date));
+    url.setQueryItems(queryItems);
+
+    return QString::fromLatin1(url.toEncoded());
+}
+
+//@cond PRIVATE
+class KolabObjectReader::Private
+{
+public:
+    Private()
+    :   mObjectType( InvalidObject ),
+        mVersion( KolabV3 ),
+        mOverrideObjectType(InvalidObject),
+        mDoOverrideVersion(false)
+    {
+        mAddressee = KABC::Addressee();
+    }
+
+    ObjectType readKolabV2(const KMime::Message::Ptr &msg, Kolab::ObjectType objectType);
+    ObjectType readKolabV3(const KMime::Message::Ptr &msg, Kolab::ObjectType objectType);
+    
+    KCalCore::Incidence::Ptr mIncidence;
+    KABC::Addressee mAddressee;
+    KABC::ContactGroup mContactGroup;
+    KMime::Message::Ptr mNote;
+    QStringList mDictionary;
+    QString mDictionaryLanguage;
+    ObjectType mObjectType;
+    Version mVersion;
+    Kolab::Freebusy mFreebusy;
+    Akonadi::Tag mTag;
+    QStringList mTagMembers;
+    ObjectType mOverrideObjectType;
+    Version mOverrideVersion;
+    bool mDoOverrideVersion;
+};
+//@endcond
+
+KolabObjectReader::KolabObjectReader()
+: d( new KolabObjectReader::Private )
+{
+}
+
+KolabObjectReader::KolabObjectReader(const KMime::Message::Ptr& msg)
+: d( new KolabObjectReader::Private )
+{
+    parseMimeMessage(msg);
+}
+
+KolabObjectReader::~KolabObjectReader()
+{
+    delete d;
+}
+
+void KolabObjectReader::setObjectType(ObjectType type)
+{
+    d->mOverrideObjectType = type;
+}
+
+void KolabObjectReader::setVersion(Version version)
+{
+    d->mOverrideVersion = version;
+    d->mDoOverrideVersion = true;
+}
+
+Kolab::ObjectType getObjectType(const QString &type)
+{
+    if (type == eventKolabType()) {
+        return EventObject;
+    } else if (type == todoKolabType()) {
+        return TodoObject;
+    } else if (type == journalKolabType()) {
+        return JournalObject;
+    } else if (type == contactKolabType()) {
+        return ContactObject;
+    } else if (type == distlistKolabType() || type == distlistKolabTypeCompat()) {
+        return DistlistObject;
+    } else if (type == noteKolabType()) {
+        return NoteObject;
+    } else if (type == freebusyKolabType()) {
+        return FreebusyObject;
+    } else if (type.contains(dictKolabType())) { //Previous versions appended the language to the type
+        return DictionaryConfigurationObject;
+    } else if (type == relationKolabType()) {
+        return RelationConfigurationObject;
+    }
+    Warning() << "Unknown object type: " << type;
+    return Kolab::InvalidObject;
+}
+
+QByteArray getTypeString(Kolab::ObjectType type)
+{
+    switch (type) {
+        case EventObject:
+            return KOLAB_TYPE_EVENT;
+        case TodoObject:
+            return KOLAB_TYPE_TASK;
+        case JournalObject:
+            return KOLAB_TYPE_JOURNAL;
+        case FreebusyObject:
+            return KOLAB_TYPE_FREEBUSY;
+        case ContactObject:
+            return KOLAB_TYPE_CONTACT;
+        case DistlistObject:
+            return KOLAB_TYPE_DISTLIST;
+        case NoteObject:
+            return KOLAB_TYPE_NOTE;
+        case DictionaryConfigurationObject:
+            return KOLAB_TYPE_CONFIGURATION;
+        case RelationConfigurationObject:
+            return KOLAB_TYPE_RELATION;
+        default:
+            Critical() << "unknown type "<< type;
+    }
+    return QByteArray();
+}
+
+QByteArray getMimeType(Kolab::ObjectType type)
+{
+    switch (type) {
+        case EventObject:
+        case TodoObject:
+        case JournalObject:
+        case FreebusyObject:
+            return MIME_TYPE_XCAL;
+        case ContactObject:
+        case DistlistObject:
+            return MIME_TYPE_XCARD;
+        case NoteObject:
+        case DictionaryConfigurationObject:
+        case RelationConfigurationObject:
+            return MIME_TYPE_KOLAB;
+        default:
+            Critical() << "unknown type "<< type;
+    }
+    return QByteArray();
+}
+
+Kolab::ObjectType detectType(const KMime::Message::Ptr &msg)
+{
+    Q_FOREACH(const QByteArray &type, Mime::getContentMimeTypeList(msg)) {
+        Kolab::ObjectType t = getObjectType(type); //works for v2 types
+        if (t != InvalidObject) {
+            return t;
+        }
+    }
+    return InvalidObject;
+}
+
+void printMessageDebugInfo(const KMime::Message::Ptr &msg)
+{
+    //TODO replace by Debug stream for Mimemessage
+    Debug() << "MessageId: " << msg->messageID()->asUnicodeString();
+    Debug() << "Subject: " << msg->subject()->asUnicodeString();
+//     Debug() << msg->encodedContent();
+}
+
+ObjectType KolabObjectReader::Private::readKolabV2(const KMime::Message::Ptr &msg, Kolab::ObjectType objectType)
+{
+    if (objectType == DictionaryConfigurationObject) {
+        KMime::Content *xmlContent = Mime::findContentByType( msg, "application/xml" );
+        if ( !xmlContent ) {
+            Critical() << "no application/xml part found";
+            printMessageDebugInfo(msg);
+            return InvalidObject;
+        }
+        const QByteArray &xmlData = xmlContent->decodedContent();
+        mDictionary = readLegacyDictionaryConfiguration(xmlData, mDictionaryLanguage);
+        mObjectType = objectType;
+        return mObjectType;
+    }
+    KMime::Content *xmlContent = Mime::findContentByType( msg, getTypeString(objectType)  );
+    if ( !xmlContent ) {
+        Critical() << "no part with type" << getTypeString(objectType) << " found";
+        printMessageDebugInfo(msg);
+        return InvalidObject;
+    }
+    const QByteArray &xmlData = xmlContent->decodedContent();
+    Q_ASSERT(!xmlData.isEmpty());
+    QStringList attachments;
+
+    switch (objectType) {
+        case EventObject:
+            mIncidence = fromXML<KCalCore::Event::Ptr, KolabV2::Event>(xmlData, attachments);
+            break;
+        case TodoObject:
+            mIncidence = fromXML<KCalCore::Todo::Ptr, KolabV2::Task>(xmlData, attachments);
+            break;
+        case JournalObject:
+            mIncidence = fromXML<KCalCore::Journal::Ptr, KolabV2::Journal>(xmlData, attachments);
+            break;
+        case ContactObject:
+            mAddressee = addresseeFromKolab(xmlData, msg);
+            break;
+        case DistlistObject:
+            mContactGroup = contactGroupFromKolab(xmlData);
+            break;
+        case NoteObject:
+            mNote = noteFromKolab(xmlData, KDateTime(msg->date()->dateTime()));
+            break;
+        default:
+            CRITICAL("no kolab object found ");
+            break;
+    }
+    if (!mIncidence.isNull()) {
+//             kDebug() << "v2 attachments " << attachments.size() << d->mIncidence->attachments().size();
+        mIncidence->clearAttachments();
+        Mime::getAttachments(mIncidence, attachments, msg);
+        if (mIncidence->attachments().size() != attachments.size()) {
+            Error() << "Could not extract all attachments. " << mIncidence->attachments().size() << " out of " << attachments.size();
+        }
+    }
+    if (ErrorHandler::errorOccured()) {
+        printMessageDebugInfo(msg);
+        return InvalidObject;
+    }
+    mObjectType = objectType;
+    return mObjectType;
+}
+
+ObjectType KolabObjectReader::Private::readKolabV3(const KMime::Message::Ptr &msg, Kolab::ObjectType objectType)
+{
+    KMime::Content * const xmlContent = Mime::findContentByType( msg, getMimeType(objectType) );
+    if ( !xmlContent ) {
+        Critical() << "no " << getMimeType(objectType) << " part found";
+        printMessageDebugInfo(msg);
+        return InvalidObject;
+    }
+    const QByteArray &content = xmlContent->decodedContent();
+    const std::string xml = std::string(content.data(), content.size());
+    switch (objectType) {
+        case EventObject: {
+            const Kolab::Event & event = Kolab::readEvent(xml, false);
+            mIncidence = Kolab::Conversion::toKCalCore(event);
+        }
+            break;
+        case TodoObject: {
+            const Kolab::Todo & event = Kolab::readTodo(xml, false);
+            mIncidence = Kolab::Conversion::toKCalCore(event);
+        }
+            break;
+        case JournalObject: {
+            const Kolab::Journal & event = Kolab::readJournal(xml, false);
+            mIncidence = Kolab::Conversion::toKCalCore(event);
+        }
+            break;
+        case ContactObject: {
+            const Kolab::Contact &contact = Kolab::readContact(xml, false);
+            mAddressee = Kolab::Conversion::toKABC(contact); //TODO extract attachments
+        }
+            break;
+        case DistlistObject: {
+            const Kolab::DistList &distlist = Kolab::readDistlist(xml, false);
+            mContactGroup = Kolab::Conversion::toKABC(distlist);
+        }
+            break;
+        case NoteObject: {
+            const Kolab::Note &note = Kolab::readNote(xml, false);
+            mNote = Kolab::Conversion::toNote(note);
+        }
+            break;
+        case DictionaryConfigurationObject: {
+            const Kolab::Configuration &configuration = Kolab::readConfiguration(xml, false);
+            const Kolab::Dictionary &dictionary = configuration.dictionary();
+            mDictionary.clear();
+            foreach (const std::string &entry, dictionary.entries()) {
+                mDictionary.append(Conversion::fromStdString(entry));
+            }
+            mDictionaryLanguage = Conversion::fromStdString(dictionary.language());
+        }
+            break;
+        case FreebusyObject: {
+            const Kolab::Freebusy &fb = Kolab::readFreebusy(xml, false);
+            mFreebusy = fb;
+        }
+            break;
+        case RelationConfigurationObject: {
+#if 0 //QT5
+            const Kolab::Configuration &configuration = Kolab::readConfiguration(xml, false);
+            const Kolab::Relation &relation = configuration.relation();
+
+            mTag = Akonadi::Tag();
+            mTag.setName(Conversion::fromStdString(relation.name()));
+            mTag.setGid(Conversion::fromStdString(configuration.uid()).toLatin1());
+            mTag.setType(Akonadi::Tag::PLAIN);
+
+            mTagMembers.reserve(relation.members().size());
+            foreach (const std::string &member, relation.members()) {
+                mTagMembers << Conversion::fromStdString(member);
+            }
+#endif
+        }
+            break;
+        default:
+            Critical() << "no kolab object found ";
+            printMessageDebugInfo(msg);
+            break;
+    }
+
+    if (!mIncidence.isNull()) {
+//             kDebug() << "getting attachments";
+        Mime::getAttachmentsById(mIncidence, msg);
+    }
+    ErrorHandler::handleLibkolabxmlErrors();
+    if (ErrorHandler::errorOccured()) {
+        printMessageDebugInfo(msg);
+        return InvalidObject;
+    }
+    mObjectType = objectType;
+    return mObjectType;
+}
+
+ObjectType KolabObjectReader::parseMimeMessage(const KMime::Message::Ptr &msg)
+{
+    ErrorHandler::clearErrors();
+    d->mObjectType = InvalidObject;
+    if (msg->contents().isEmpty()) {
+        Critical() << "message has no contents (we likely failed to parse it correctly)";
+        printMessageDebugInfo(msg);
+        return InvalidObject;
+    }
+    Kolab::ObjectType objectType = InvalidObject;
+    if (d->mOverrideObjectType == InvalidObject) {
+        if (KMime::Headers::Base *xKolabHeader = msg->getHeaderByType(X_KOLAB_TYPE_HEADER)) {
+            objectType = getObjectType(xKolabHeader->asUnicodeString().trimmed());
+        } else {
+            Warning() << "could not find the X-Kolab-Type Header, trying autodetection" ;
+            //This works only for v2 messages atm.
+            objectType = detectType(msg);
+        }
+    } else {
+        objectType = d->mOverrideObjectType;
+    }
+    if (objectType == InvalidObject) {
+        Critical() << "unable to detect object type";
+        printMessageDebugInfo(msg);
+        return InvalidObject;
+    }
+
+    if (!d->mDoOverrideVersion) {
+        KMime::Headers::Base *xKolabVersion = msg->getHeaderByType(X_KOLAB_MIME_VERSION_HEADER);
+        if (!xKolabVersion) {
+            //For backwards compatibility to development versions, can be removed in future versions
+            xKolabVersion = msg->getHeaderByType(X_KOLAB_MIME_VERSION_HEADER_COMPAT);
+        }
+        if (!xKolabVersion || xKolabVersion->asUnicodeString() == KOLAB_VERSION_V2) {
+            d->mVersion = KolabV2;
+        } else {
+            if (xKolabVersion->asUnicodeString() != KOLAB_VERSION_V3) { //TODO version compatibility check?
+                Warning() << "Kolab Version Header available but not on the same version as the implementation: " << xKolabVersion->asUnicodeString();
+            }
+            d->mVersion = KolabV3;
+        }
+    } else {
+        d->mVersion = d->mOverrideVersion;
+    }
+
+    if (d->mVersion == KolabV2) {
+        return d->readKolabV2(msg, objectType);
+    }
+    return d->readKolabV3(msg, objectType);
+}
+
+Version KolabObjectReader::getVersion() const
+{
+    return d->mVersion;
+}
+
+ObjectType KolabObjectReader::getType() const
+{
+    return d->mObjectType;
+}
+
+KCalCore::Event::Ptr KolabObjectReader::getEvent() const
+{
+    return d->mIncidence.dynamicCast<KCalCore::Event>();
+}
+
+KCalCore::Todo::Ptr KolabObjectReader::getTodo() const
+{
+    return d->mIncidence.dynamicCast<KCalCore::Todo>();
+}
+
+KCalCore::Journal::Ptr KolabObjectReader::getJournal() const
+{
+    return d->mIncidence.dynamicCast<KCalCore::Journal>();
+}
+
+KCalCore::Incidence::Ptr KolabObjectReader::getIncidence() const
+{
+    return d->mIncidence;
+}
+
+KABC::Addressee KolabObjectReader::getContact() const
+{
+    return d->mAddressee;
+}
+
+KABC::ContactGroup KolabObjectReader::getDistlist() const
+{
+    return d->mContactGroup;
+}
+
+KMime::Message::Ptr KolabObjectReader::getNote() const
+{
+    return d->mNote;
+}
+
+QStringList KolabObjectReader::getDictionary(QString& lang) const
+{
+    lang = d->mDictionaryLanguage;
+    return d->mDictionary;
+}
+
+Freebusy KolabObjectReader::getFreebusy() const
+{
+    return d->mFreebusy;
+}
+
+Akonadi::Tag KolabObjectReader::getTag() const
+{
+    return d->mTag;
+}
+
+QStringList KolabObjectReader::getTagMembers() const
+{
+    return d->mTagMembers;
+}
+
+
+//Normalize incidences before serializing them
+KCalCore::Incidence::Ptr normalizeIncidence(KCalCore::Incidence::Ptr original)
+{
+    KCalCore::Incidence::Ptr i = KCalCore::Incidence::Ptr(original->clone()); //We copy to avoid destructive writing
+    Q_FOREACH (KCalCore::Attachment::Ptr attachment, i->attachments()) {
+        attachment->setUri(QString::fromLatin1("cid:")+QString::fromLatin1(KMime::uniqueString() + '@' + "kolab.resource.akonadi")); //Serialize the attachment as attachment with uri, referencing the created mime-part
+    }
+    return i;
+}
+/*
+KABC::Addressee normalizeContact(const KABC::Addressee &a)
+{
+    KABC::Addressee addresee = a;
+    Q_FOREACH (KCalCore::Attachment::Ptr attachment, addresee.photo()) {
+        attachment->setUri(QString::fromLatin1("cid:")+QString::fromLatin1(KMime::uniqueString() + '@' + "kolab.resource.akonadi")); //Serialize the attachment as attachment with uri, referencing the created mime-part
+    }
+    return i;
+}*/
+
+QString getProductId(const QString &pId)
+{
+    if (pId.isEmpty()) {
+        return KOLAB_VERSION_STRING;
+    }
+    return pId+" "+KOLAB_VERSION_STRING;
+}
+
+KMime::Message::Ptr KolabObjectWriter::writeEvent(const KCalCore::Event::Ptr &i, Version v, const QString &productId, const QString &tz)
+{
+    ErrorHandler::clearErrors();
+    if (!i) {
+        Critical() << "passed a null pointer";
+        return KMime::Message::Ptr();
+    }
+    Q_ASSERT(!i.isNull());
+    if (v == KolabV3) {
+        KCalCore::Event::Ptr ic = normalizeIncidence(i).dynamicCast<KCalCore::Event>();
+        const Kolab::Event &incidence = Kolab::Conversion::fromKCalCore(*ic);
+        const std::string &v3String = Kolab::writeEvent(incidence, std::string(getProductId(productId).toUtf8().constData()));
+        ErrorHandler::handleLibkolabxmlErrors();
+        return Mime::createMessage(ic, xCalMimeType(), eventKolabType(), QString::fromUtf8(v3String.c_str()).toUtf8(), true, getProductId(productId));
+    }
+    const QString &xml = KolabV2::Event::eventToXML(i, tz);
+    return Mime::createMessage(i, eventKolabType(), eventKolabType(), xml.toUtf8(), false, getProductId(productId));
+}
+
+KMime::Message::Ptr KolabObjectWriter::writeTodo(const KCalCore::Todo::Ptr &i, Version v, const QString &productId, const QString &tz)
+{
+    ErrorHandler::clearErrors();
+    if (!i) {
+        Critical() << "passed a null pointer";
+        return KMime::Message::Ptr();
+    }
+    Q_ASSERT(!i.isNull());
+    if (v == KolabV3) {
+        KCalCore::Todo::Ptr ic = normalizeIncidence(i).dynamicCast<KCalCore::Todo>();
+        const Kolab::Todo &incidence = Kolab::Conversion::fromKCalCore(*ic);
+        const std::string &v3String = Kolab::writeTodo(incidence, Conversion::toStdString(getProductId(productId)));
+        ErrorHandler::handleLibkolabxmlErrors();
+        return Mime::createMessage(ic, xCalMimeType(), todoKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
+    }
+    const QString &xml = KolabV2::Task::taskToXML(i, tz);
+    return Mime::createMessage(i, todoKolabType(), todoKolabType(), xml.toUtf8(), false, getProductId(productId));
+}
+
+KMime::Message::Ptr KolabObjectWriter::writeJournal(const KCalCore::Journal::Ptr &i, Version v, const QString &productId, const QString &tz)
+{
+    ErrorHandler::clearErrors();
+    if (!i) {
+        Critical() << "passed a null pointer";
+        return KMime::Message::Ptr();
+    }
+    Q_ASSERT(!i.isNull());
+    if (v == KolabV3) {
+        KCalCore::Journal::Ptr ic = normalizeIncidence(i).dynamicCast<KCalCore::Journal>();
+        const Kolab::Journal &incidence = Kolab::Conversion::fromKCalCore(*ic);
+        const std::string &v3String = Kolab::writeJournal(incidence, Conversion::toStdString(getProductId(productId)));
+        ErrorHandler::handleLibkolabxmlErrors();
+        return  Mime::createMessage(ic, xCalMimeType(), journalKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
+    }
+    const QString &xml = KolabV2::Journal::journalToXML(i, tz);
+    return Mime::createMessage(i, journalKolabType(), journalKolabType(), xml.toUtf8(), false, getProductId(productId));
+}
+
+KMime::Message::Ptr KolabObjectWriter::writeIncidence(const KCalCore::Incidence::Ptr &i, Version v, const QString& productId, const QString& tz)
+{
+    if (!i) {
+        Critical() << "passed a null pointer";
+        return KMime::Message::Ptr();
+    }
+    switch (i->type()) {
+        case KCalCore::IncidenceBase::TypeEvent:
+            return writeEvent(i.dynamicCast<KCalCore::Event>(),v,productId,tz);
+        case KCalCore::IncidenceBase::TypeTodo:
+            return writeTodo(i.dynamicCast<KCalCore::Todo>(),v,productId,tz);
+        case KCalCore::IncidenceBase::TypeJournal:
+            return writeJournal(i.dynamicCast<KCalCore::Journal>(),v,productId,tz);
+        default:
+            Critical() << "unknown incidence type";
+    }
+    return KMime::Message::Ptr();
+}
+
+
+KMime::Message::Ptr KolabObjectWriter::writeContact(const KABC::Addressee &addressee, Version v, const QString &productId)
+{
+    ErrorHandler::clearErrors();
+    if (v == KolabV3) {
+        const Kolab::Contact &contact = Kolab::Conversion::fromKABC(addressee);
+        const std::string &v3String = Kolab::writeContact(contact, Conversion::toStdString(getProductId(productId)));
+        ErrorHandler::handleLibkolabxmlErrors();
+        return  Mime::createMessage(addressee, xCardMimeType(), contactKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
+    }
+    KolabV2::Contact contact(&addressee);
+    return contactToKolabFormat(contact, getProductId(productId));
+}
+
+KMime::Message::Ptr KolabObjectWriter::writeDistlist(const KABC::ContactGroup &distlist, Version v, const QString &productId)
+{
+    ErrorHandler::clearErrors();
+    if (v == KolabV3) {
+        const Kolab::DistList &dist = Kolab::Conversion::fromKABC(distlist);
+        const std::string &v3String = Kolab::writeDistlist(dist, Conversion::toStdString(getProductId(productId)));
+        ErrorHandler::handleLibkolabxmlErrors();
+        return  Mime::createMessage(Conversion::fromStdString(dist.uid()), xCardMimeType(), distlistKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
+    }
+    KolabV2::DistributionList d(&distlist);
+    return distListToKolabFormat(d, getProductId(productId));
+}
+
+KMime::Message::Ptr KolabObjectWriter::writeNote(const KMime::Message::Ptr &note, Version v, const QString &productId)
+{
+    ErrorHandler::clearErrors();
+    if (!note) {
+        Critical() << "passed a null pointer";
+        return KMime::Message::Ptr();
+    }
+    Q_ASSERT(note.get());
+    if (v == KolabV3) {
+        const Kolab::Note &n = Kolab::Conversion::fromNote(note);
+        const std::string &v3String = Kolab::writeNote(n, Conversion::toStdString(getProductId(productId)));
+        ErrorHandler::handleLibkolabxmlErrors();
+        return  Mime::createMessage(Conversion::fromStdString(n.uid()), kolabMimeType(), noteKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
+    }
+    return noteToKolab(note, getProductId(productId));
+}
+
+KMime::Message::Ptr KolabObjectWriter::writeDictionary(const QStringList &entries, const QString& lang, Version v, const QString& productId)
+{
+    ErrorHandler::clearErrors();
+    if (v != KolabV3) {
+        Critical() << "only v3 implementation available";
+    }
+
+    Kolab::Dictionary dictionary(Conversion::toStdString(lang));
+    std::vector <std::string> ent;
+    foreach (const QString &e, entries) {
+        ent.push_back(Conversion::toStdString(e));
+    }
+    dictionary.setEntries(ent);
+    Kolab::Configuration configuration(dictionary); //TODO preserve creation/lastModified date
+    const std::string &v3String = Kolab::writeConfiguration(configuration, Conversion::toStdString(getProductId(productId)));
+    ErrorHandler::handleLibkolabxmlErrors();
+    return  Mime::createMessage(Conversion::fromStdString(configuration.uid()), kolabMimeType(), dictKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
+}
+
+KMime::Message::Ptr KolabObjectWriter::writeFreebusy(const Freebusy &freebusy, Version v, const QString& productId)
+{
+    ErrorHandler::clearErrors();
+    if (v != KolabV3) {
+        Critical() << "only v3 implementation available";
+    }
+    const std::string &v3String = Kolab::writeFreebusy(freebusy, Conversion::toStdString(getProductId(productId)));
+    ErrorHandler::handleLibkolabxmlErrors();
+    return  Mime::createMessage(Conversion::fromStdString(freebusy.uid()), xCalMimeType(), freebusyKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
+}
+
+KMime::Message::Ptr KolabObjectWriter::writeTag(const Akonadi::Tag &tag, const QStringList &members, Version v, const QString &productId)
+{
+    ErrorHandler::clearErrors();
+    if (v != KolabV3) {
+        Critical() << "only v3 implementation available";
+    }
+#if  0 //QT5
+    Kolab::Relation relation(Conversion::toStdString(tag.name()), "tag");
+    std::vector<std::string> m;
+    m.reserve(members.count());
+    foreach (const QString &member, members) {
+        m.push_back(Conversion::toStdString(member));
+    }
+    relation.setMembers(m);
+
+    Kolab::Configuration configuration(relation); //TODO preserve creation/lastModified date
+    configuration.setUid(tag.gid().constData());
+    const std::string &v3String = Kolab::writeConfiguration(configuration, Conversion::toStdString(getProductId(productId)));
+    ErrorHandler::handleLibkolabxmlErrors();
+    return  Mime::createMessage(Conversion::fromStdString(configuration.uid()), kolabMimeType(), relationKolabType(), Conversion::fromStdString(v3String).toUtf8(), true, getProductId(productId));
+#else
+    return KMime::Message::Ptr();
+#endif
+}
+
+
+
+
+
+
+}; //Namespace
+
diff --git a/src/kolabformat/kolabobject.h b/src/kolabformat/kolabobject.h
new file mode 100644
index 0000000..c94f97d
--- /dev/null
+++ b/src/kolabformat/kolabobject.h
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef KOLABOBJECT_H
+#define KOLABOBJECT_H
+
+#include <kolab_export.h>
+
+#include <AkonadiCore/tag.h>
+#include <kabc/addressee.h>
+#include <kabc/contactgroup.h>
+#include <kcalcore/incidence.h>
+#include <kcalcore/event.h>
+#include <kcalcore/journal.h>
+#include <kcalcore/todo.h>
+#include <kmime/kmime_message.h>
+
+#include "kolabdefinitions.h"
+
+namespace Kolab {
+
+class Freebusy;
+
+
+KOLAB_EXPORT KCalCore::Event::Ptr readV2EventXML(const QByteArray &xmlData, QStringList &attachments);
+
+struct KOLAB_EXPORT RelationMember {
+    QString messageId;
+    QString subject;
+    QString date;
+    QList<QByteArray> mailbox;
+    QString user;
+    qint64 uid;
+};
+KOLAB_EXPORT RelationMember parseMemberUrl(const QString &url);
+KOLAB_EXPORT QString generateMemberUrl(const RelationMember &url);
+
+/**
+ * Class to read Kolab Mime files
+ * 
+ * It implements the Kolab specifics of Mime message handling.
+ * This class is not reusable and only meant to read a single object.
+ * Parse the mime message and then call the correct getter, based on the type
+ * 
+ */
+class KOLAB_EXPORT KolabObjectReader {
+public:
+    KolabObjectReader();
+    explicit KolabObjectReader(const KMime::Message::Ptr &msg);
+    ~KolabObjectReader();
+    
+    ObjectType parseMimeMessage(const KMime::Message::Ptr &msg);
+
+    /**
+     * Set to Q_DECL_OVERRIDE the autodetected object type, before parsing the message.
+     */
+    void setObjectType(ObjectType);
+    
+    /**
+     * Set to Q_DECL_OVERRIDE the autodetected version, before parsing the message.
+     */
+    void setVersion(Version);
+    
+    /**
+     * Returns the Object type of the parsed kolab object.
+     */
+    ObjectType getType() const;
+    /**
+     * Returns the kolab-format version of the parsed kolab object.
+     */
+    Version getVersion() const;
+    
+    /**
+     * Getter to get the retrieved object.
+     * Only the correct one will return a valid object.
+     * 
+     * Use getType() to determine the correct one to call.
+     */
+    KCalCore::Event::Ptr getEvent() const;
+    KCalCore::Todo::Ptr getTodo() const;
+    KCalCore::Journal::Ptr getJournal() const;
+    KCalCore::Incidence::Ptr getIncidence() const;
+    KABC::Addressee getContact() const;
+    KABC::ContactGroup getDistlist() const;
+    KMime::Message::Ptr getNote() const;
+    QStringList getDictionary(QString &lang) const;
+    Freebusy getFreebusy() const;
+    Akonadi::Tag getTag() const;
+    QStringList getTagMembers() const;
+
+private:
+    //@cond PRIVATE
+    class Private;
+    Private *const d;
+    //@endcond
+};
+
+/**
+ * Class to write Kolab Mime files
+ * 
+ */
+class KOLAB_EXPORT KolabObjectWriter {
+public:
+
+    static KMime::Message::Ptr writeEvent(const KCalCore::Event::Ptr &, Version v = KolabV3, const QString &productId = QString(), const QString &tz = QString());
+    static KMime::Message::Ptr writeTodo(const KCalCore::Todo::Ptr &, Version v = KolabV3, const QString &productId = QString(),const QString &tz = QString());
+    static KMime::Message::Ptr writeJournal(const KCalCore::Journal::Ptr &, Version v = KolabV3, const QString &productId = QString(),const QString &tz = QString());
+    static KMime::Message::Ptr writeIncidence(const KCalCore::Incidence::Ptr &, Version v = KolabV3, const QString &productId = QString(),const QString &tz = QString());
+    static KMime::Message::Ptr writeContact(const KABC::Addressee &, Version v = KolabV3, const QString &productId = QString());
+    static KMime::Message::Ptr writeDistlist(const KABC::ContactGroup &, Version v = KolabV3, const QString &productId = QString());
+    static KMime::Message::Ptr writeNote(const KMime::Message::Ptr &, Version v = KolabV3, const QString &productId = QString());
+    static KMime::Message::Ptr writeDictionary(const QStringList &, const QString &lang, Version v = KolabV3, const QString &productId = QString());
+    static KMime::Message::Ptr writeFreebusy(const Kolab::Freebusy &, Version v = KolabV3, const QString &productId = QString());
+    static KMime::Message::Ptr writeTag(const Akonadi::Tag &, const QStringList &items, Version v = KolabV3, const QString &productId = QString());
+    
+};
+
+} //Namespace
+
+#endif // KOLABOBJECT_H
diff --git a/src/kolabformat/kolabobject.i b/src/kolabformat/kolabobject.i
new file mode 100644
index 0000000..6de018d
--- /dev/null
+++ b/src/kolabformat/kolabobject.i
@@ -0,0 +1,18 @@
+%{
+    /* This macro ensures that return vectors remain a vector also in python and are not converted to tuples */
+    #define SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
+    
+    #include "../kolabformat/xmlobject.h"
+    #include "../kolabformat/kolabdefinitions.h"
+    #include "../kolabformat/mimeobject.h"
+%}
+
+%include "std_string.i"
+%include "std_vector.i"
+
+%import(module="kolabformat") <kolabevent.h>
+%import "../shared.i"
+
+%include "../kolabformat/xmlobject.h"
+%include "../kolabformat/kolabdefinitions.h"
+%include "../kolabformat/mimeobject.h"
diff --git a/src/kolabformat/mimeobject.cpp b/src/kolabformat/mimeobject.cpp
new file mode 100644
index 0000000..559cf75
--- /dev/null
+++ b/src/kolabformat/mimeobject.cpp
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2012  Sofia Balicka <balicka@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "mimeobject.h"
+#include "conversion/kcalconversion.h"
+#include "conversion/kolabconversion.h"
+#include "conversion/kabcconversion.h"
+#include "kolabformat/kolabobject.h"
+#include <QString>
+
+namespace Kolab
+{
+
+MIMEObject::MIMEObject()
+{
+
+}
+
+std::string MIMEObject::writeEvent(const Event &event, Version version, const std::string &productId)
+{
+
+    KCalCore::Event::Ptr KEvent = Conversion::toKCalCore(event);
+
+    KMime::Message::Ptr msg = KolabObjectWriter().writeEvent(KEvent, version, QString::fromStdString(productId));
+    msg->assemble();
+
+    return msg->encodedContent().data();
+}
+
+Event MIMEObject::readEvent(const std::string &s)
+{
+
+    KMime::Message::Ptr msg(new KMime::Message);
+    msg->setContent(QByteArray(s.c_str()));
+    msg->parse();
+    
+    KCalCore::Event::Ptr event = KolabObjectReader(msg).getEvent();
+    
+    return Conversion::fromKCalCore(*event); 
+}
+
+std::string MIMEObject::writeTodo(const Todo &todo, Version version, const std::string &productId){
+    KCalCore::Todo::Ptr kTodo = Conversion::toKCalCore(todo);
+
+    KMime::Message::Ptr msg = KolabObjectWriter().writeTodo(kTodo, version, QString::fromStdString(productId));
+    msg->assemble();
+
+    return msg->encodedContent().data();
+}
+
+
+Todo MIMEObject::readTodo(const std::string &s){
+
+    KMime::Message::Ptr msg(new KMime::Message);
+    msg->setContent(QByteArray(s.c_str()));
+    msg->parse();
+    
+    KCalCore::Todo::Ptr todo = KolabObjectReader(msg).getTodo();
+    
+    return Conversion::fromKCalCore(*todo);
+}
+
+
+std::string MIMEObject::writeJournal(const Journal &journal, Version version, const std::string &productId){
+    KCalCore::Journal::Ptr kJournal = Conversion::toKCalCore(journal);
+
+    KMime::Message::Ptr msg = KolabObjectWriter().writeJournal(kJournal, version, QString::fromStdString(productId));
+    msg->assemble();
+
+    return msg->encodedContent().data();
+}
+
+
+Journal MIMEObject::readJournal(const std::string &s){
+
+    KMime::Message::Ptr msg(new KMime::Message);
+    msg->setContent(QByteArray(s.c_str()));
+    msg->parse();
+    
+    KCalCore::Journal::Ptr journal = KolabObjectReader(msg).getJournal();
+    
+    return Conversion::fromKCalCore(*journal);
+}
+
+std::string MIMEObject::writeNote(const Note &note, Version version, const std::string &productId){
+    KMime::Message::Ptr kNote = Conversion::toNote(note);
+
+    KMime::Message::Ptr msg = KolabObjectWriter().writeNote(kNote, version, QString::fromStdString(productId));
+    msg->assemble();
+
+    return msg->encodedContent().data();
+}
+
+
+Note MIMEObject::readNote(const std::string &s){
+
+    KMime::Message::Ptr msg(new KMime::Message);
+    msg->setContent(QByteArray(s.c_str()));
+    msg->parse();
+    
+    KMime::Message::Ptr note = KolabObjectReader(msg).getNote();
+    
+    return Conversion::fromNote(note);
+}
+
+std::string MIMEObject::writeContact(const Contact &contact, Version version, const std::string &productId){
+    KABC::Addressee kContact = Conversion::toKABC(contact);
+
+    KMime::Message::Ptr msg = KolabObjectWriter().writeContact(kContact, version, QString::fromStdString(productId));
+    msg->assemble();
+
+    return msg->encodedContent().data();
+}
+
+
+Contact MIMEObject::readContact(const std::string &s){
+
+    KMime::Message::Ptr msg(new KMime::Message);
+    msg->setContent(QByteArray(s.c_str()));
+    msg->parse();
+    
+    KABC::Addressee contact = KolabObjectReader(msg).getContact();
+    
+    return Conversion::fromKABC(contact);
+}
+
+std::string MIMEObject::writeDistlist(const DistList &distlist, Version version, const std::string &productId){
+    KABC::ContactGroup kDistlist = Conversion::toKABC(distlist);
+
+    KMime::Message::Ptr msg = KolabObjectWriter().writeDistlist(kDistlist, version, QString::fromStdString(productId));
+    msg->assemble();
+
+    return msg->encodedContent().data();
+}
+
+
+DistList MIMEObject::readDistlist(const std::string &s){
+
+    KMime::Message::Ptr msg(new KMime::Message);
+    msg->setContent(QByteArray(s.c_str()));
+    msg->parse();
+    
+    KABC::ContactGroup distlist = KolabObjectReader(msg).getDistlist();
+    
+    return Conversion::fromKABC(distlist);
+}
+}
+
diff --git a/src/kolabformat/mimeobject.h b/src/kolabformat/mimeobject.h
new file mode 100644
index 0000000..89ff788
--- /dev/null
+++ b/src/kolabformat/mimeobject.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2012  Sofia Balicka <balicka@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef MIMEOBJECT_H
+#define MIMEOBJECT_H
+
+#ifndef SWIG
+#include "kolab_export.h"
+#else
+/* No export/import SWIG interface files */
+#define KOLAB_EXPORT
+#endif
+
+#include <kolabformat.h>
+#include "kolabdefinitions.h"
+
+
+namespace Kolab
+{
+
+class KOLAB_EXPORT MIMEObject
+{
+public:
+    MIMEObject();
+
+    std::string writeEvent(const Kolab::Event  &event, Version version, const std::string &productId = std::string());
+    Kolab::Event readEvent(const std::string &s);
+
+    std::string writeTodo(const Kolab::Todo &todo, Version version, const std::string &productId = std::string());
+    Kolab::Todo readTodo(const std::string &s);
+
+    std::string writeJournal(const Kolab::Journal &journal, Version version, const std::string &productId = std::string());
+    Kolab::Journal readJournal(const std::string &s);
+
+    std::string writeNote(const Kolab::Note &note, Version version, const std::string &productId = std::string());
+    Kolab::Note readNote(const std::string &s);
+
+    std::string writeContact(const Kolab::Contact &contact, Version version, const std::string &productId = std::string());
+    Kolab::Contact readContact(const std::string &s);
+
+    std::string writeDistlist(const Kolab::DistList &distlist, Version version, const std::string &productId = std::string());
+    Kolab::DistList readDistlist(const std::string &s);
+
+};
+}
+#endif  
diff --git a/src/kolabformat/php/CMakeLists.txt b/src/kolabformat/php/CMakeLists.txt
new file mode 100644
index 0000000..2d18e19
--- /dev/null
+++ b/src/kolabformat/php/CMakeLists.txt
@@ -0,0 +1,4 @@
+#Generate PHP wrapper
+include_directories(../)
+include(SWIGUtils)
+generatePHPBindings(kolabobject ../kolabobject.i)
diff --git a/src/kolabformat/php/test.php b/src/kolabformat/php/test.php
new file mode 100644
index 0000000..ec3d8e4
--- /dev/null
+++ b/src/kolabformat/php/test.php
@@ -0,0 +1,88 @@
+<?php
+//run using:
+// php -d enable_dl=On -dextension=/usr/local/lib/php/modules/kolabshared.so -dextension=/usr/local/lib/php/modules/kolabformat.so -dextension=/usr/local/lib/php/modules/kolabobject.so test.php
+
+include("kolabformat.php");
+include("kolabobject.php");
+
+/////// Test Event
+$e = new Event();
+$e->setCreated(new cDateTime(2012,3,14, 9,5,30, true));
+$e->setStart(new cDateTime(2012,7,31));
+$e->setUid("uid");
+$e->setPriority(1);
+
+$xo = new XMLObject;
+print $xo->writeEvent($e, kolabobject::KolabV2, "test.php");
+print $xo->writeEvent($e, kolabobject::KolabV3, "test.php");
+
+////// Test Contact
+$c = new Contact();
+$nc = new NameComponents;
+$sn = new vectors;
+$sn->push("Contact");
+$nc->setSurnames($sn);
+$gn = new vectors;
+$gn->push("Sample");
+$nc->setGiven($gn);
+$c->setNameComponents($nc);
+$c->setName("Sample Contact");
+$em = new vectors;
+$em->push("sample.v2@localhost");
+$c->setEmailAddresses($em);
+
+$xo = new XMLObject;
+print $xo->writeContact($c, kolabobject::KolabV2, "test.php");
+print "UID = " . $xo->getSerializedUID() . "\n\n";
+
+print $xo->writeContact($c, kolabobject::KolabV3, "test.php");
+print "UID = " . $xo->getSerializedUID() . "\n\n";
+
+
+$dlxml = <<<EOL
+<?xml version="1.0"?>
+<distribution-list version="1.0">
+  <uid>ebb1774429a2e03afafb31f233e23b42</uid>
+  <body></body>
+  <categories></categories>
+  <creation-date>2010-11-25T18:02:32Z</creation-date>
+  <last-modification-date>2011-07-23T09:06:38Z</last-modification-date>
+  <sensitivity>public</sensitivity>
+  <product-id>Horde::Kolab</product-id>
+  <display-name>Another lista</display-name>
+  <member>
+    <display-name>Another  User</display-name>
+    <smtp-address>other@debian-vm.local</smtp-address>
+    <uid>a2cfdc52365ef429042413bf7717dc85</uid>
+  </member>
+  <member>
+    <display-name>Sample A. User Jr.</display-name>
+    <smtp-address>sample@debian-vm.local</smtp-address>
+    <uid>f538c7e9ad5a63e4452b7db3bc291231</uid>
+  </member>
+</distribution-list>
+EOL;
+
+$xo = new XMLObject;
+$dl = new DistList($xo->readDistList($dlxml, kolabobject::KolabV2));
+
+echo $dl->uid() . "\n\n";
+$ml = $dl->members();
+for ($i=0; $i < $ml->size(); $i++) {
+    $m = $ml->get($i);
+    echo "Member [" . $m->type() . "]: " . $m->uid() . "; " . $m->email() . "\n";
+}
+
+
+$dl2 = new DistList();
+$ml = new vectorcontactref;
+$m1 = new ContactReference(ContactReference::UidReference, 'some-uid-value');
+$ml->push($m1);
+$m2 = new ContactReference(ContactReference::EmailReference, 'sample@localhost');
+$ml->push($m2);
+
+$dl2->setMembers($ml);
+echo $xo->writeDistList($dl2, kolabobject::KolabV2);
+echo $xo->writeDistList($dl2, kolabobject::KolabV3);
+
+?>
diff --git a/src/kolabformat/python/CMakeLists.txt b/src/kolabformat/python/CMakeLists.txt
new file mode 100644
index 0000000..5ff8bfe
--- /dev/null
+++ b/src/kolabformat/python/CMakeLists.txt
@@ -0,0 +1,4 @@
+include_directories(../)
+include(SWIGUtils)
+generatePythonBindings(kolabobject ../kolabobject.i)
+
diff --git a/src/kolabformat/v2helpers.cpp b/src/kolabformat/v2helpers.cpp
new file mode 100644
index 0000000..22b3cde
--- /dev/null
+++ b/src/kolabformat/v2helpers.cpp
@@ -0,0 +1,279 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "v2helpers.h"
+
+#include "kolabdefinitions.h"
+
+#include "kolabformatV2/kolabbase.h"
+#include "kolabformatV2/journal.h"
+#include "kolabformatV2/task.h"
+#include "kolabformatV2/event.h"
+#include "kolabformatV2/contact.h"
+#include "kolabformatV2/distributionlist.h"
+#include "kolabformatV2/note.h"
+#include "mime/mimeutils.h"
+#include "kolabformat/errorhandler.h"
+
+#include <kabc/contactgroup.h>
+
+#include <qdom.h>
+#include <kdebug.h>
+#include <qbuffer.h>
+#include <akonadi/notes/noteutils.h>
+
+namespace Kolab {
+
+static QImage getPicture(const QString &pictureAttachmentName, const KMime::Message::Ptr &data, QByteArray &type)
+{
+    if (!data) {
+        Critical() << "empty message";
+        return QImage();
+    }
+    KMime::Content *imgContent = Mime::findContentByName(data, pictureAttachmentName/*"kolab-picture.png"*/, type);
+    if (!imgContent) {
+        Warning() << "could not find picture: " << pictureAttachmentName;
+        return QImage();
+    }
+    QByteArray imgData = imgContent->decodedContent();
+    QBuffer buffer(&imgData);
+    buffer.open(QIODevice::ReadOnly);
+    QImage image;
+    bool success = false;
+    if (type == "image/jpeg") {
+        success = image.load(&buffer, "JPEG");
+        //FIXME I tried getting the code to interpret the picture as PNG, but the VCard implementation writes it as JPEG anyways...
+//         if (success) {
+//             QByteArray pic;
+//             QBuffer b(&pic);
+//             b.open(QIODevice::ReadWrite);
+//             Q_ASSERT(image.save(&b, "PNG"));
+//             b.close();
+//             Debug() << pic.toBase64();
+//             QBuffer b2(&pic);
+//             b2.open(QIODevice::ReadOnly);
+//             success = image.load(&b2, "PNG");
+//             b2.close();
+//             Q_ASSERT(success);
+//         }
+    } else {
+        type = "image/png";
+        success = image.load(&buffer, "PNG");
+    }
+    buffer.close();
+    if (!success) {
+        Warning() << "failed to load picture";
+    }
+    return image;
+}
+
+KABC::Addressee addresseeFromKolab( const QByteArray &xmlData, const KMime::Message::Ptr &data)
+{
+    if (!data) {
+        Critical() << "empty message";
+        return KABC::Addressee();
+    }
+    KABC::Addressee addressee;
+//     Debug() << "xmlData " << xmlData;
+    KolabV2::Contact contact(QString::fromUtf8(xmlData));
+    QByteArray type;
+    const QString &pictureAttachmentName = contact.pictureAttachmentName();
+    if (!pictureAttachmentName.isEmpty()) {
+        const QImage &img = getPicture(pictureAttachmentName, data, type);
+        contact.setPicture(img, type);
+    }
+    
+    const QString &logoAttachmentName = contact.logoAttachmentName();
+    if (!logoAttachmentName.isEmpty()) {
+        contact.setLogo(getPicture(logoAttachmentName, data, type), type);
+    }
+    
+    const QString &soundAttachmentName = contact.soundAttachmentName();
+    if (!soundAttachmentName.isEmpty()) {
+        QByteArray type;
+        KMime::Content *content = Mime::findContentByName(data, soundAttachmentName/*"sound"*/, type);
+        if (content) {
+            const QByteArray &sData = content->decodedContent();
+            contact.setSound(sData);
+        } else {
+            Warning() << "could not find sound: " << soundAttachmentName;
+        }
+    }
+    contact.saveTo(&addressee);
+    return addressee;
+}
+
+KABC::Addressee addresseeFromKolab(const QByteArray &xmlData, QString &pictureAttachmentName, QString &logoAttachmentName, QString &soundAttachmentName)
+{
+    KABC::Addressee addressee;
+    KolabV2::Contact contact(QString::fromUtf8(xmlData));
+    pictureAttachmentName = contact.pictureAttachmentName();
+    logoAttachmentName = contact.logoAttachmentName();
+    soundAttachmentName = contact.soundAttachmentName();
+    contact.saveTo(&addressee);
+    return addressee;
+}
+
+static QByteArray createPicture(const QImage &img, const QString &/*format*/, QString &type)
+{
+    QByteArray pic;
+    QBuffer buffer(&pic);
+    buffer.open(QIODevice::WriteOnly);
+    type = "image/png";
+    //FIXME it's not possible to save jpegs lossless, so we always use png. otherwise we would compress the image on every write.
+//     if (format == "image/jpeg") {
+//         type = "image/jpeg";
+//         img.save(&buffer, "JPEG");
+//     } else {
+        img.save(&buffer, "PNG");
+//     }
+    buffer.close();
+    return pic;
+}
+
+KMime::Message::Ptr contactToKolabFormat(const KolabV2::Contact& contact, const QString &productId)
+{
+    KMime::Message::Ptr message = Mime::createMessage( KOLAB_TYPE_CONTACT, false, productId );
+    if (!message) {
+        Critical() << "empty message";
+        return KMime::Message::Ptr();
+    }
+    message->subject()->fromUnicodeString( contact.uid(), "utf-8" );
+    message->from()->fromUnicodeString( contact.fullEmail(), "utf-8" );
+    
+    KMime::Content* content = Mime::createMainPart( KOLAB_TYPE_CONTACT, contact.saveXML().toUtf8() );
+    message->addContent( content );
+    
+    if ( !contact.picture().isNull() ) {
+        QString type;
+        const QByteArray &pic = createPicture(contact.picture(), contact.pictureFormat(), type);
+        content = Mime::createAttachmentPart(QByteArray(), type, /*"kolab-picture.png"*/contact.pictureAttachmentName(), pic );
+        message->addContent(content);
+    }
+    
+    if ( !contact.logo().isNull() ) {
+        QString type;
+        const QByteArray &pic = createPicture(contact.logo(), contact.logoFormat(), type);
+        content = Mime::createAttachmentPart(QByteArray(), type, /*"kolab-logo.png"*/contact.logoAttachmentName(), pic );
+        message->addContent(content);
+    }
+    
+    if ( !contact.sound().isEmpty() ) {
+        content = Mime::createAttachmentPart(QByteArray(), "audio/unknown", /*"sound"*/contact.soundAttachmentName(), contact.sound() );
+        message->addContent(content);
+    }
+    
+    message->assemble();
+    return message;
+}
+
+KABC::ContactGroup contactGroupFromKolab(const QByteArray &xmlData)
+{
+    KABC::ContactGroup contactGroup;
+    //     kDebug() << "xmlData " << xmlData;
+    KolabV2::DistributionList distList(QString::fromUtf8(xmlData));
+    distList.saveTo(&contactGroup);
+    return contactGroup;
+}
+
+KMime::Message::Ptr distListToKolabFormat(const KolabV2::DistributionList& distList, const QString &productId)
+{    
+    KMime::Message::Ptr message = Mime::createMessage( KOLAB_TYPE_DISTLIST_V2, false, productId );
+    if (!message) {
+        Critical() << "empty message";
+        return KMime::Message::Ptr();
+    }
+    message->subject()->fromUnicodeString( distList.uid(), "utf-8" );
+    message->from()->fromUnicodeString( distList.uid(), "utf-8" );
+    
+    KMime::Content* content = Mime::createMainPart( KOLAB_TYPE_DISTLIST_V2, distList.saveXML().toUtf8() );
+    message->addContent( content );
+    
+    message->assemble();
+    return message;
+}
+
+KMime::Message::Ptr noteFromKolab(const QByteArray &xmlData, const KDateTime &creationDate)
+{
+    KolabV2::Note j;
+    if ( !j.load( xmlData ) ) {
+        Warning() << "failed to read note";
+        return KMime::Message::Ptr();
+    }
+    
+    Akonadi::NoteUtils::NoteMessageWrapper note;
+    note.setTitle(j.summary());
+    note.setText(j.body().toUtf8());
+    note.setFrom("kolab@kde4");
+    note.setCreationDate(creationDate.dateTime());
+    return note.message();
+}
+
+KMime::Message::Ptr noteToKolab(const KMime::Message::Ptr& msg, const QString &productId)
+{
+    if (!msg) {
+        Critical() << "empty message";
+        return KMime::Message::Ptr();
+    }
+    Akonadi::NoteUtils::NoteMessageWrapper note(msg);
+    return Mime::createMessage(note.title(), KOLAB_TYPE_NOTE, KOLAB_TYPE_NOTE, noteToKolabXML(msg), false, productId);
+}
+
+QByteArray noteToKolabXML(const KMime::Message::Ptr& msg)
+{
+    if (!msg) {
+        Critical() << "empty message";
+        return QByteArray();
+    }
+    Akonadi::NoteUtils::NoteMessageWrapper note(msg);
+    KolabV2::Note j;
+    j.setSummary( note.title() );
+    j.setBody( note.text() );
+    return j.saveXML().toUtf8();
+}
+
+QStringList readLegacyDictionaryConfiguration(const QByteArray &xmlData, QString &language)
+{
+    QStringList dictionary;
+    const QDomDocument xmlDoc = KolabV2::KolabBase::loadDocument( QString::fromUtf8(xmlData) ); //TODO extract function from V2 format
+    if ( xmlDoc.isNull() ) {
+        Error() << "Failed to read the xml document";
+        return QStringList();
+    }
+
+    QDomElement top = xmlDoc.documentElement();
+
+    if ( top.tagName() != "configuration" ) {
+        qWarning( "XML error: Top tag was %s instead of the expected configuration",
+                top.tagName().toAscii().data() );
+        return QStringList();
+    }
+
+    for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+        if ( n.isComment() || !n.isElement() )
+            continue;
+        QDomElement e = n.toElement();
+        if (e.tagName() == "language") {
+            language = e.text();
+        } else if (e.tagName() == "e") {
+            dictionary.append(e.text());
+        }
+    }
+    return dictionary;
+}
+
+}
diff --git a/src/kolabformat/v2helpers.h b/src/kolabformat/v2helpers.h
new file mode 100644
index 0000000..e047d35
--- /dev/null
+++ b/src/kolabformat/v2helpers.h
@@ -0,0 +1,96 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef V2HELPERS_H
+#define V2HELPERS_H
+
+#include "kolabdefinitions.h"
+
+#include "kolabformatV2/kolabbase.h"
+#include "kolabformatV2/journal.h"
+#include "kolabformatV2/task.h"
+#include "kolabformatV2/event.h"
+#include "kolabformatV2/contact.h"
+#include "kolabformatV2/distributionlist.h"
+#include "kolabformatV2/note.h"
+#include "mime/mimeutils.h"
+#include "kolabformat/errorhandler.h"
+
+#include <kabc/contactgroup.h>
+
+#include <qdom.h>
+#include <qbuffer.h>
+#include <akonadi/notes/noteutils.h>
+
+namespace Kolab {
+
+
+/*
+ * Parse XML, create KCalCore container and extract attachments
+ */
+template <typename KCalPtr, typename Container>
+static KCalPtr fromXML(const QByteArray &xmlData, QStringList &attachments)
+{
+    const QDomDocument xmlDoc = KolabV2::KolabBase::loadDocument( QString::fromUtf8(xmlData) ); //TODO extract function from V2 format
+    if ( xmlDoc.isNull() ) {
+        Critical() << "Failed to read the xml document";
+        return KCalPtr();
+    }
+    const KCalPtr i = Container::fromXml( xmlDoc, QString() ); //For parsing we don't need the timezone, so we don't set one
+    Q_ASSERT ( i );
+    QDomNodeList nodes = xmlDoc.elementsByTagName("inline-attachment");
+    for (int i = 0; i < nodes.size(); i++ ) {
+        attachments.append(nodes.at(i).toElement().text());
+    }
+    return i;
+}
+
+template <typename IncidencePtr, typename Converter>
+static inline IncidencePtr incidenceFromKolabImpl( const KMime::Message::Ptr &data, const QByteArray &mimetype, const QString &timezoneId )
+{
+    KMime::Content *xmlContent = Mime::findContentByType( data, mimetype );
+    if ( !xmlContent ) {
+        Critical() << "couldn't find part";
+        return IncidencePtr();
+    }
+    const QByteArray &xmlData = xmlContent->decodedContent();
+    
+    QStringList attachments;
+    IncidencePtr ptr = fromXML<IncidencePtr, Converter>(xmlData, attachments); //TODO do we care about timezone?
+    Mime::getAttachments(ptr, attachments, data);
+    
+    return ptr;
+}
+
+KABC::Addressee addresseeFromKolab( const QByteArray &xmlData, const KMime::Message::Ptr &data);
+KABC::Addressee addresseeFromKolab( const QByteArray &xmlData, QString &pictureAttachmentName, QString &logoAttachmentName, QString &soundAttachmentName);
+
+KMime::Message::Ptr contactToKolabFormat(const KolabV2::Contact& contact, const QString &productId);
+
+KABC::ContactGroup contactGroupFromKolab(const QByteArray &xmlData);
+
+KMime::Message::Ptr distListToKolabFormat(const KolabV2::DistributionList& distList, const QString &productId);
+KMime::Message::Ptr noteFromKolab(const QByteArray &xmlData, const KDateTime &creationDate);
+
+KMime::Message::Ptr noteToKolab(const KMime::Message::Ptr& msg, const QString &productId);
+QByteArray noteToKolabXML(const KMime::Message::Ptr& msg);
+
+QStringList readLegacyDictionaryConfiguration(const QByteArray &xmlData, QString &language);
+
+}
+
+#endif
diff --git a/src/kolabformat/xmlobject.cpp b/src/kolabformat/xmlobject.cpp
new file mode 100644
index 0000000..e9e2f7a
--- /dev/null
+++ b/src/kolabformat/xmlobject.cpp
@@ -0,0 +1,352 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "xmlobject.h"
+#include "v2helpers.h"
+#include "kolabformatV2/event.h"
+#include "conversion/kcalconversion.h"
+#include "conversion/kolabconversion.h"
+#include "conversion/commonconversion.h"
+#include "conversion/kabcconversion.h"
+#include <QUuid>
+
+namespace Kolab {
+
+static QString createUuid()
+{
+    const QString uuid = QUuid::createUuid().toString();
+    return uuid.mid(1, uuid.size()-2);
+}
+
+XMLObject::XMLObject()
+{
+
+}
+
+std::string XMLObject::getSerializedUID() const
+{
+    return mWrittenUID;
+}
+    
+std::vector< std::string > XMLObject::getAttachments() const
+{
+    return mAttachments;
+}
+
+std::string XMLObject::writeEvent(const Event &event, Version version, const std::string& productId)
+{
+    mWrittenUID.clear();
+    if (version == KolabV2) {
+        const KCalCore::Event::Ptr i = Conversion::toKCalCore(event);
+        if (!i) {
+            Critical() << "invalid incidence";
+            return std::string();
+        }
+        if (i->uid().isEmpty()) {
+            i->setUid(createUuid());
+        }
+        mWrittenUID = Conversion::toStdString(i->uid());
+        //The timezone is used for created and last modified dates
+        const QString &xml = KolabV2::Event::eventToXML(i, QLatin1String("UTC"));
+        return Conversion::toStdString(xml);
+    }
+    const std::string result = Kolab::writeEvent(event, productId);
+    mWrittenUID = Kolab::getSerializedUID();
+    return result;
+}
+
+Event XMLObject::readEvent(const std::string& s, Version version)
+{
+    if (version == KolabV2) {
+        QStringList attachments;
+        const KCalCore::Event::Ptr event = Kolab::fromXML<KCalCore::Event::Ptr, KolabV2::Event>(QString::fromUtf8(s.c_str()).toUtf8(), attachments);
+        if (!event || Kolab::ErrorHandler::errorOccured()) {
+            Critical() << "failed to read xml";
+            return Event();
+        }
+        mAttachments.clear();
+        foreach (const QString &attachment, attachments) {
+            mAttachments.push_back(Conversion::toStdString(attachment));
+        }
+        return Conversion::fromKCalCore(*event);
+    }
+    return Kolab::readEvent(s, false);
+}
+
+std::string XMLObject::writeTodo(const Todo &event, Version version, const std::string& productId)
+{
+    mWrittenUID.clear();
+    if (version == KolabV2) {
+        const KCalCore::Todo::Ptr i = Conversion::toKCalCore(event);
+        if (!i) {
+            Critical() << "invalid incidence";
+            return std::string();
+        }
+        if (i->uid().isEmpty()) {
+            i->setUid(createUuid());
+        }
+        mWrittenUID = Conversion::toStdString(i->uid());
+        //The timezone is used for created and last modified dates
+        const QString &xml = KolabV2::Task::taskToXML(i, QLatin1String("UTC"));
+        return Conversion::toStdString(xml);
+    }
+    const std::string result = Kolab::writeTodo(event, productId);
+    mWrittenUID = Kolab::getSerializedUID();
+    return result;
+}
+
+Todo XMLObject::readTodo(const std::string& s, Version version)
+{
+    if (version == KolabV2) {
+        QStringList attachments;
+        const KCalCore::Todo::Ptr event = Kolab::fromXML<KCalCore::Todo::Ptr, KolabV2::Task>(QString::fromUtf8(s.c_str()).toUtf8(), attachments);
+        if (!event || Kolab::ErrorHandler::errorOccured()) {
+            Error() << "failed to read xml";
+            return Todo();
+        }
+        mAttachments.clear();
+        foreach (const QString &attachment, attachments) {
+            mAttachments.push_back(Conversion::toStdString(attachment));
+        }
+        return Conversion::fromKCalCore(*event);
+    }
+    return Kolab::readTodo(s, false);
+}
+
+std::string XMLObject::writeJournal(const Journal &event, Version version, const std::string& productId)
+{
+    mWrittenUID.clear();
+    if (version == KolabV2) {
+        const KCalCore::Journal::Ptr i = Conversion::toKCalCore(event);
+        if (!i) {
+            Critical() << "invalid journal";
+            return std::string();
+        }
+        if (i->uid().isEmpty()) {
+            i->setUid(createUuid());
+        }
+        mWrittenUID = Conversion::toStdString(i->uid());
+        //The timezone is used for created and last modified dates
+        const QString &xml = KolabV2::Journal::journalToXML(i, QLatin1String("UTC"));
+        return Conversion::toStdString(xml);
+    }
+    const std::string result = Kolab::writeJournal(event, productId);
+    mWrittenUID = Kolab::getSerializedUID();
+    return result;
+}
+
+Journal XMLObject::readJournal(const std::string& s, Version version)
+{
+    if (version == KolabV2) {
+        QStringList attachments;
+        const KCalCore::Journal::Ptr event = Kolab::fromXML<KCalCore::Journal::Ptr, KolabV2::Journal>(QString::fromUtf8(s.c_str()).toUtf8(), attachments);
+        if (!event || Kolab::ErrorHandler::errorOccured()) {
+            Critical() << "failed to read xml";
+            return Journal();
+        }
+        mAttachments.clear();
+        foreach (const QString &attachment, attachments) {
+            mAttachments.push_back(Conversion::toStdString(attachment));
+        }
+        return Conversion::fromKCalCore(*event);
+    }
+    return Kolab::readJournal(s, false);
+}
+
+std::string XMLObject::writeFreebusy(const Freebusy &event, Version version, const std::string& productId)
+{
+    mWrittenUID.clear();
+    if (version != KolabV3) {
+        Critical() << "only v3 implementation available";
+        return std::string();
+    }
+    const std::string result = Kolab::writeFreebusy(event, productId);
+    mWrittenUID = Kolab::getSerializedUID();
+    return result;
+}
+
+Freebusy XMLObject::readFreebusy(const std::string& s, Version version)
+{
+    if (version != KolabV3) {
+        Critical() << "only v3 implementation available";
+        return Freebusy();
+    }
+    return Kolab::readFreebusy(s, false);
+}
+
+std::string XMLObject::logoAttachmentName() const
+{
+    return mLogoAttachmentName;
+}
+
+std::string XMLObject::pictureAttachmentName() const
+{
+    return mPictureAttachmentName;
+}
+
+std::string XMLObject::soundAttachmentName() const
+{
+    return mSoundAttachmentName;
+}
+
+Contact XMLObject::readContact(const std::string& s, Version version)
+{
+    if (version == KolabV2) {        
+        const QByteArray xmlData(s.c_str(), s.size());
+        QString pictureAttachmentName;
+        QString logoAttachmentName;
+        QString soundAttachmentName;
+        const KABC::Addressee addressee = addresseeFromKolab(xmlData, pictureAttachmentName, logoAttachmentName, soundAttachmentName);
+        mPictureAttachmentName = Conversion::toStdString(pictureAttachmentName);
+        mLogoAttachmentName = Conversion::toStdString(logoAttachmentName);
+        mSoundAttachmentName = Conversion::toStdString(soundAttachmentName);
+        return Conversion::fromKABC(addressee);
+    }
+    return Kolab::readContact(s, false);
+}
+
+std::string XMLObject::writeContact(const Contact &contact, Version version, const std::string& productId)
+{
+    mWrittenUID.clear();
+    if (version == KolabV2) {
+        //FIXME attachment names are hardcoded for now
+        KABC::Addressee addressee = Conversion::toKABC(contact);
+        if (addressee.uid().isEmpty()) {
+            addressee.setUid(createUuid());
+        }
+        mWrittenUID = Conversion::toStdString(addressee.uid());
+        const KolabV2::Contact contact(&addressee);
+        return Conversion::toStdString(contact.saveXML());
+    }
+    const std::string result = Kolab::writeContact(contact, productId);
+    mWrittenUID = Kolab::getSerializedUID();
+    return result;
+}
+
+DistList XMLObject::readDistlist(const std::string& s, Version version)
+{
+    if (version == KolabV2) {        
+        const QByteArray xmlData(s.c_str(), s.size());
+        const KABC::ContactGroup contactGroup = contactGroupFromKolab(xmlData);
+        return Conversion::fromKABC(contactGroup);
+    }
+    return Kolab::readDistlist(s, false);
+}
+
+std::string XMLObject::writeDistlist(const DistList &distlist, Version version, const std::string& productId)
+{
+    mWrittenUID.clear();
+    if (version == KolabV2) {
+        KABC::ContactGroup contactGroup = Conversion::toKABC(distlist);
+        if (contactGroup.id().isEmpty()) {
+            contactGroup.setId(createUuid());
+        }
+        mWrittenUID = Conversion::toStdString(contactGroup.id());
+        const KolabV2::DistributionList d(&contactGroup);
+        return Conversion::toStdString(d.saveXML());
+    }
+    const std::string result = Kolab::writeDistlist(distlist, productId);
+    mWrittenUID = Kolab::getSerializedUID();
+    return result;
+}
+
+Note XMLObject::readNote(const std::string& s, Version version)
+{
+    if (version == KolabV2) {
+        const KMime::Message::Ptr msg = noteFromKolab(QByteArray(s.c_str(), s.length()), KDateTime());
+        if (!msg || Kolab::ErrorHandler::errorOccured()) {
+            Critical() << "failed to read xml";
+            return Note();
+        }
+        return Conversion::fromNote(msg);
+    }
+    return Kolab::readNote(s, false);
+}
+
+std::string XMLObject::writeNote(const Note &note, Version version, const std::string& productId)
+{
+    mWrittenUID.clear();
+    if (version == KolabV2) {
+        Note noteWithUID = note;
+        if (noteWithUID.uid().empty()) {
+            noteWithUID.setUid(Conversion::toStdString(createUuid()));
+        }
+        mWrittenUID = noteWithUID.uid();
+        const KMime::Message::Ptr n = Conversion::toNote(noteWithUID);
+        const QByteArray &xml = noteToKolabXML(n);
+        return std::string(xml.constData());
+    }
+    const std::string result = Kolab::writeNote(note, productId);
+    mWrittenUID = Kolab::getSerializedUID();
+    return result;
+}
+
+Configuration XMLObject::readConfiguration(const std::string& s, Version version)
+{
+    if (version == KolabV2) {
+        QString lang;
+        const QStringList dict = readLegacyDictionaryConfiguration(QByteArray(s.c_str(), s.length()), lang);
+        if (lang.isEmpty()) {
+            Critical() << "not a dictionary or not a v2 configuration object";
+            return Kolab::Configuration();
+        }
+        std::vector<std::string> entries;
+        foreach (const QString e, dict) {
+            entries.push_back(Conversion::toStdString(e));
+        }
+        Kolab::Dictionary dictionary(Conversion::toStdString(lang));
+        dictionary.setEntries(entries);
+        return Configuration(dictionary);
+    }
+    return Kolab::readConfiguration(s, false);
+}
+
+std::string XMLObject::writeConfiguration(const Configuration &configuration, Version version, const std::string& productId)
+{
+    mWrittenUID.clear();
+    if (version != KolabV3) {
+        Critical() << "only v3 implementation available";
+        return std::string();
+    }
+    const std::string result = Kolab::writeConfiguration(configuration, productId);
+    mWrittenUID = Kolab::getSerializedUID();
+    return result;
+}
+
+File XMLObject::readFile(const std::string& s, Version version)
+{
+    if (version == KolabV2) {
+        Critical() << "only v3 implementation available";
+        return File();
+    }
+    return Kolab::readFile(s, false);
+}
+
+std::string XMLObject::writeFile(const File &file, Version version, const std::string& productId)
+{
+    mWrittenUID.clear();
+    if (version != KolabV3) {
+        Critical() << "only v3 implementation available";
+        return std::string();
+    }
+    const std::string result = Kolab::writeFile(file, productId);
+    mWrittenUID = Kolab::getSerializedUID();
+    return result;
+}
+
+    
+};
diff --git a/src/kolabformat/xmlobject.h b/src/kolabformat/xmlobject.h
new file mode 100644
index 0000000..5066e8f
--- /dev/null
+++ b/src/kolabformat/xmlobject.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Affero General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Affero General Public License for more details.
+ *
+ * You should have received a copy of the GNU Affero General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef KOLABXMLOBJECT_H
+#define KOLABXMLOBJECT_H
+
+#ifndef SWIG
+#include "kolab_export.h"
+#else
+/* No export/import SWIG interface files */
+#define KOLAB_EXPORT
+#endif
+
+#include <kolabformat.h>
+
+#include "kolabdefinitions.h"
+
+namespace Kolab {
+
+class KOLAB_EXPORT XMLObject
+{
+public:
+    XMLObject();
+
+    std::string getSerializedUID() const;
+    
+    ///List of attachment names to be retrieved from the mime message (only when reading v2, for v3 attachments containing the cid: of the attachment-part are created )
+    std::vector<std::string> getAttachments() const;
+    
+    Kolab::Event readEvent(const std::string& s, Kolab::Version version);
+    std::string writeEvent(const Kolab::Event &, Kolab::Version version, const std::string& productId = std::string());
+    
+    Kolab::Todo readTodo(const std::string& s, Kolab::Version version);
+    std::string writeTodo(const Kolab::Todo &, Kolab::Version version, const std::string& productId = std::string());
+
+    Kolab::Journal readJournal(const std::string& s, Kolab::Version version);
+    std::string writeJournal(const Kolab::Journal &, Kolab::Version version, const std::string& productId = std::string());
+
+    Kolab::Freebusy readFreebusy(const std::string& s, Kolab::Version version);
+    std::string writeFreebusy(const Kolab::Freebusy &, Kolab::Version version, const std::string& productId = std::string());
+
+    std::string pictureAttachmentName() const;
+    std::string logoAttachmentName() const;
+    std::string soundAttachmentName() const;
+    /**
+     * Find the attachments and set them on the read Contact object.
+     *
+     * V2 Notes:
+     * Picture, logo and sound must be retrieved from Mime Message attachments using they're corresponding attachment name.
+     */
+    Kolab::Contact readContact(const std::string& s, Kolab::Version version);
+    
+    /**
+     * V2 Notes:
+     * * Uses the following attachment names:
+     * ** kolab-picture.png
+     * ** kolab-logo.png
+     * ** sound
+     */
+    std::string writeContact(const Kolab::Contact &, Kolab::Version version, const std::string& productId = std::string());
+    
+    Kolab::DistList readDistlist(const std::string& s, Kolab::Version version);
+    std::string writeDistlist(const Kolab::DistList &, Kolab::Version version, const std::string& productId = std::string());
+
+    /**
+     * V2 notes:
+     * * set the creation date from the mime date header.
+     */
+    Kolab::Note readNote(const std::string& s, Kolab::Version version);
+    std::string writeNote(const Kolab::Note &, Kolab::Version version, const std::string& productId = std::string());
+
+    Kolab::Configuration readConfiguration(const std::string& s, Kolab::Version version);
+    std::string writeConfiguration(const Kolab::Configuration &, Kolab::Version version, const std::string& productId = std::string());
+
+    Kolab::File readFile(const std::string& s, Kolab::Version version);
+    std::string writeFile(const Kolab::File &, Kolab::Version version, const std::string& productId = std::string());
+    
+private:
+    std::vector<std::string> mAttachments;
+    std::string mLogoAttachmentName;
+    std::string mSoundAttachmentName;
+    std::string mPictureAttachmentName;
+    std::string mWrittenUID;
+};
+
+}
+#endif // KOLABXMLOBJECT_H
diff --git a/src/kolabformatV2/CMakeLists.txt b/src/kolabformatV2/CMakeLists.txt
new file mode 100644
index 0000000..7c3071f
--- /dev/null
+++ b/src/kolabformatV2/CMakeLists.txt
@@ -0,0 +1,12 @@
+
+set( kolabformatv2_SRCS
+    ${CMAKE_CURRENT_SOURCE_DIR}/kolabbase.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/contact.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/distributionlist.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/event.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/task.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/journal.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/incidence.cpp
+    ${CMAKE_CURRENT_SOURCE_DIR}/note.cpp
+#     kolabformatv2.cpp
+    PARENT_SCOPE)
diff --git a/src/kolabformatV2/contact.cpp b/src/kolabformatV2/contact.cpp
new file mode 100644
index 0000000..0e59709
--- /dev/null
+++ b/src/kolabformatV2/contact.cpp
@@ -0,0 +1,1214 @@
+/*
+    This file is part of libkabc and/or kaddressbook.
+    Copyright (c) 2004 Klarlvdalens Datakonsult AB
+        <info@klaralvdalens-datakonsult.se>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#include "contact.h"
+
+#include <kabc/addressee.h>
+#include <kdebug.h>
+#include <QFile>
+#include <float.h>
+
+using namespace KolabV2;
+
+static const char* s_pictureAttachmentName = "kolab-picture.png";
+static const char* s_logoAttachmentName = "kolab-logo.png";
+static const char* s_soundAttachmentName = "sound";
+static const char* s_unhandledTagAppName = "KOLABUNHANDLED"; // no hyphens in appnames!
+
+// saving (addressee->xml)
+Contact::Contact( const KABC::Addressee* addr )
+  : mHasGeo( false )
+{
+  setFields( addr );
+}
+
+// loading (xml->addressee)
+Contact::Contact( const QString& xml )
+  : mHasGeo( false )
+{
+  load( xml );
+}
+
+Contact::~Contact()
+{
+}
+
+void Contact::setGivenName( const QString& name )
+{
+  mGivenName = name;
+}
+
+QString Contact::givenName() const
+{
+  return mGivenName;
+}
+
+void Contact::setMiddleNames( const QString& names )
+{
+  mMiddleNames = names;
+}
+
+QString Contact::middleNames() const
+{
+  return mMiddleNames;
+}
+
+void Contact::setLastName( const QString& name )
+{
+  mLastName = name;
+}
+
+QString Contact::lastName() const
+{
+  return mLastName;
+}
+
+void Contact::setFullName( const QString& name )
+{
+  mFullName = name;
+}
+
+QString Contact::fullName() const
+{
+  return mFullName;
+}
+
+void Contact::setInitials( const QString& initials )
+{
+  mInitials = initials;
+}
+
+QString Contact::initials() const
+{
+  return mInitials;
+}
+
+void Contact::setPrefix( const QString& prefix )
+{
+  mPrefix = prefix;
+}
+
+QString Contact::prefix() const
+{
+  return mPrefix;
+}
+
+void Contact::setSuffix( const QString& suffix )
+{
+  mSuffix = suffix;
+}
+
+QString Contact::suffix() const
+{
+  return mSuffix;
+}
+
+void Contact::setRole( const QString& role )
+{
+  mRole = role;
+}
+
+QString Contact::role() const
+{
+  return mRole;
+}
+
+void Contact::setFreeBusyUrl( const QString& fbUrl )
+{
+  mFreeBusyUrl = fbUrl;
+}
+
+QString Contact::freeBusyUrl() const
+{
+  return mFreeBusyUrl;
+}
+
+void Contact::setOrganization( const QString& organization )
+{
+  mOrganization = organization;
+}
+
+QString Contact::organization() const
+{
+  return mOrganization;
+}
+
+void Contact::setWebPage( const QString& url )
+{
+  mWebPage = url;
+}
+
+QString Contact::webPage() const
+{
+  return mWebPage;
+}
+
+void Contact::setIMAddress( const QString& imAddress )
+{
+  mIMAddress = imAddress;
+}
+
+QString Contact::imAddress() const
+{
+  return mIMAddress;
+}
+
+void Contact::setDepartment( const QString& department )
+{
+  mDepartment = department;
+}
+
+QString Contact::department() const
+{
+  return mDepartment;
+}
+
+void Contact::setOfficeLocation( const QString& location )
+{
+  mOfficeLocation = location;
+}
+
+QString Contact::officeLocation() const
+{
+  return mOfficeLocation;
+}
+
+void Contact::setProfession( const QString& profession )
+{
+  mProfession = profession;
+}
+
+QString Contact::profession() const
+{
+  return mProfession;
+}
+
+void Contact::setTitle( const QString& title )
+{
+  mTitle = title;
+}
+
+QString Contact::title() const
+{
+  return mTitle;
+}
+
+void Contact::setManagerName( const QString& name )
+{
+  mManagerName = name;
+}
+
+QString Contact::managerName() const
+{
+  return mManagerName;
+}
+
+void Contact::setAssistant( const QString& name )
+{
+  mAssistant = name;
+}
+
+QString Contact::assistant() const
+{
+  return mAssistant;
+}
+
+void Contact::setNickName( const QString& name )
+{
+  mNickName = name;
+}
+
+QString Contact::nickName() const
+{
+  return mNickName;
+}
+
+void Contact::setSpouseName( const QString& name )
+{
+  mSpouseName = name;
+}
+
+QString Contact::spouseName() const
+{
+  return mSpouseName;
+}
+
+void Contact::setBirthday( const QDate& date )
+{
+  mBirthday = date;
+}
+
+QDate Contact::birthday() const
+{
+  return mBirthday;
+}
+
+void Contact::setAnniversary( const QDate& date )
+{
+  mAnniversary = date;
+}
+
+QDate Contact::anniversary() const
+{
+  return mAnniversary;
+}
+
+void Contact::setChildren( const QString& children )
+{
+  mChildren = children;
+}
+
+QString Contact::children() const
+{
+  return mChildren;
+}
+
+void Contact::setGender( const QString& gender )
+{
+  mGender = gender;
+}
+
+QString Contact::gender() const
+{
+  return mGender;
+}
+
+void Contact::setLanguage( const QString& language )
+{
+  mLanguage = language;
+}
+
+QString Contact::language() const
+{
+  return mLanguage;
+}
+
+void Contact::addPhoneNumber( const PhoneNumber& number )
+{
+  mPhoneNumbers.append( number );
+}
+
+QList<Contact::PhoneNumber>& Contact::phoneNumbers()
+{
+  return mPhoneNumbers;
+}
+
+const QList<Contact::PhoneNumber>& Contact::phoneNumbers() const
+{
+  return mPhoneNumbers;
+}
+
+void Contact::addEmail( const Email& email )
+{
+  mEmails.append( email );
+}
+
+QList<Contact::Email>& Contact::emails()
+{
+  return mEmails;
+}
+
+QString Contact::fullEmail() const
+{
+  return mFullEmail;
+}
+
+const QList<Contact::Email>& Contact::emails() const
+{
+  return mEmails;
+}
+
+void Contact::addAddress( const Contact::Address& address )
+{
+  mAddresses.append( address );
+}
+
+QList<Contact::Address>& Contact::addresses()
+{
+  return mAddresses;
+}
+
+const QList<Contact::Address>& Contact::addresses() const
+{
+  return mAddresses;
+}
+
+void Contact::setPreferredAddress( const QString& address )
+{
+  mPreferredAddress = address;
+}
+
+QString Contact::preferredAddress() const
+{
+  return mPreferredAddress;
+}
+
+bool Contact::loadNameAttribute( QDomElement& element )
+{
+  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      QString tagName = e.tagName();
+
+      if ( tagName == "given-name" )
+        setGivenName( e.text() );
+      else if ( tagName == "middle-names" )
+        setMiddleNames( e.text() );
+      else if ( tagName == "last-name" )
+        setLastName( e.text() );
+      else if ( tagName == "full-name" )
+        setFullName( e.text() );
+      else if ( tagName == "initials" )
+        setInitials( e.text() );
+      else if ( tagName == "prefix" )
+        setPrefix( e.text() );
+      else if ( tagName == "suffix" )
+        setSuffix( e.text() );
+      else
+        // TODO: Unhandled tag - save for later storage
+        kDebug() <<"Warning: Unhandled tag" << e.tagName();
+    } else
+      kDebug() <<"Node is not a comment or an element???";
+  }
+
+  return true;
+}
+
+void Contact::saveNameAttribute( QDomElement& element ) const
+{
+  QDomElement e = element.ownerDocument().createElement( "name" );
+  element.appendChild( e );
+
+  writeString( e, "given-name", givenName() );
+  writeString( e, "middle-names", middleNames() );
+  writeString( e, "last-name", lastName() );
+  writeString( e, "full-name", fullName() );
+  writeString( e, "initials", initials() );
+  writeString( e, "prefix", prefix() );
+  writeString( e, "suffix", suffix() );
+}
+
+bool Contact::loadPhoneAttribute( QDomElement& element )
+{
+  PhoneNumber number;
+  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      QString tagName = e.tagName();
+
+      if ( tagName == "type" )
+        number.type = e.text();
+      else if ( tagName == "number" )
+        number.number = e.text();
+      else
+        // TODO: Unhandled tag - save for later storage
+        kDebug() <<"Warning: Unhandled tag" << e.tagName();
+    } else
+      kDebug() <<"Node is not a comment or an element???";
+  }
+
+  addPhoneNumber( number );
+  return true;
+}
+
+void Contact::savePhoneAttributes( QDomElement& element ) const
+{
+  QList<PhoneNumber>::ConstIterator it = mPhoneNumbers.constBegin();
+  for ( ; it != mPhoneNumbers.constEnd(); ++it ) {
+    QDomElement e = element.ownerDocument().createElement( "phone" );
+    element.appendChild( e );
+    const PhoneNumber& p = *it;
+    writeString( e, "type", p.type );
+    writeString( e, "number", p.number );
+  }
+}
+
+void Contact::saveEmailAttributes( QDomElement& element ) const
+{
+  QList<Email>::ConstIterator it = mEmails.constBegin();
+  for ( ; it != mEmails.constEnd(); ++it )
+    saveEmailAttribute( element, *it );
+}
+
+void Contact::loadCustomAttributes( QDomElement& element )
+{
+  Custom custom;
+  custom.app = element.attribute( "app" );
+  custom.name = element.attribute( "name" );
+  custom.value = element.attribute( "value" );
+  mCustomList.append( custom );
+}
+
+void Contact::saveCustomAttributes( QDomElement& element ) const
+{
+  QList<Custom>::ConstIterator it = mCustomList.constBegin();
+  for ( ; it != mCustomList.constEnd(); ++it ) {
+    Q_ASSERT( !(*it).name.isEmpty() );
+    if ( (*it).app == s_unhandledTagAppName ) {
+      writeString( element, (*it).name, (*it).value );
+    } else {
+      // Let's use attributes so that other tag-preserving-code doesn't need sub-elements
+      QDomElement e = element.ownerDocument().createElement( "x-custom" );
+      element.appendChild( e );
+      e.setAttribute( "app", (*it).app );
+      e.setAttribute( "name", (*it).name );
+      e.setAttribute( "value", (*it).value );
+    }
+  }
+}
+
+bool Contact::loadAddressAttribute( QDomElement& element )
+{
+  Address address;
+
+  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      QString tagName = e.tagName();
+
+      if ( tagName == "type" )
+        address.type = e.text();
+      else if ( tagName == "x-kde-type" )
+        address.kdeAddressType = e.text().toInt();
+      else if ( tagName == "street" )
+        address.street = e.text();
+      else if ( tagName == "pobox" )
+        address.pobox = e.text();
+      else if ( tagName == "locality" )
+        address.locality = e.text();
+      else if ( tagName == "region" )
+        address.region = e.text();
+      else if ( tagName == "postal-code" )
+        address.postalCode = e.text();
+      else if ( tagName == "country" )
+        address.country = e.text();
+      else
+        // TODO: Unhandled tag - save for later storage
+        kDebug() <<"Warning: Unhandled tag" << e.tagName();
+    } else
+      kDebug() <<"Node is not a comment or an element???";
+  }
+
+  addAddress( address );
+  return true;
+}
+
+void Contact::saveAddressAttributes( QDomElement& element ) const
+{
+  QList<Address>::ConstIterator it = mAddresses.constBegin();
+  for ( ; it != mAddresses.constEnd(); ++it ) {
+    QDomElement e = element.ownerDocument().createElement( "address" );
+    element.appendChild( e );
+    const Address& a = *it;
+    writeString( e, "type", a.type );
+    writeString( e, "x-kde-type", QString::number( a.kdeAddressType ) );
+    if ( !a.street.isEmpty() )
+      writeString( e, "street", a.street );
+    if ( !a.pobox.isEmpty() )
+      writeString( e, "pobox", a.pobox );
+    if ( !a.locality.isEmpty() )
+    writeString( e, "locality", a.locality );
+    if ( !a.region.isEmpty() )
+      writeString( e, "region", a.region );
+    if ( !a.postalCode.isEmpty() )
+      writeString( e, "postal-code", a.postalCode );
+    if ( !a.country.isEmpty() )
+      writeString( e, "country", a.country );
+  }
+}
+
+bool Contact::loadAttribute( QDomElement& element )
+{
+  const QString tagName = element.tagName();
+  switch ( tagName[0].toLatin1() ) {
+  case 'a':
+    if ( tagName == "address" )
+      return loadAddressAttribute( element );
+    if ( tagName == "assistant" ) {
+      setAssistant( element.text() );
+      return true;
+    }
+    if ( tagName == "anniversary" ) {
+      if ( !element.text().isEmpty() )
+        setAnniversary( stringToDate( element.text() ) );
+      return true;
+    }
+    break;
+  case 'b':
+    if ( tagName == "birthday" ) {
+      if ( !element.text().isEmpty() )
+        setBirthday( stringToDate( element.text() ) );
+      return true;
+    }
+    break;
+  case 'c':
+    if ( tagName == "children" ) {
+      setChildren( element.text() );
+      return true;
+    }
+    break;
+  case 'd':
+    if ( tagName == "department" ) {
+      setDepartment( element.text() );
+      return true;
+    }
+    break;
+  case 'e':
+    if ( tagName == "email" ) {
+      Email email;
+      if ( loadEmailAttribute( element, email ) ) {
+        addEmail( email );
+        return true;
+      } else
+        return false;
+    }
+    break;
+  case 'f':
+    if ( tagName == "free-busy-url" ) {
+      setFreeBusyUrl( element.text() );
+      return true;
+    }
+    break;
+  case 'g':
+    if ( tagName == "gender" ) {
+      setGender( element.text() );
+      return true;
+    }
+    break;
+  case 'i':
+    if ( tagName == "im-address" ) {
+      setIMAddress( element.text() );
+      return true;
+    }
+    break;
+  case 'j':
+   if ( tagName == "job-title" ) {
+     // see saveAttributes: <job-title> is mapped to the Role field
+      setTitle( element.text() );
+      return true;
+    }
+    break;
+  case 'l':
+    if ( tagName == "language" ) {
+      setLanguage( element.text() );
+      return true;
+    }
+    if ( tagName == "latitude" ) {
+      setLatitude( element.text().toFloat() );
+      mHasGeo = true;
+      return true;
+    }
+    if ( tagName == "longitude" ) {
+      setLongitude( element.text().toFloat() );
+      mHasGeo = true;
+    }
+    break;
+  case 'm':
+    if ( tagName == "manager-name" ) {
+      setManagerName( element.text() );
+      return true;
+    }
+  case 'n':
+    if ( tagName == "name" )
+      return loadNameAttribute( element );
+    if ( tagName == "nick-name" ) {
+      setNickName( element.text() );
+      return true;
+    }
+    break;
+  case 'o':
+    if ( tagName == "organization" ) {
+      setOrganization( element.text() );
+      return true;
+    }
+    if ( tagName == "office-location" ) {
+      setOfficeLocation( element.text() );
+      return true;
+    }
+    break;
+  case 'p':
+    if ( tagName == "profession" ) {
+      setProfession( element.text() );
+      return true;
+    }
+    if ( tagName == "picture" ) {
+      mPictureAttachmentName = element.text();
+      return true;
+    }
+    if ( tagName == "phone" ) {
+      return loadPhoneAttribute( element );
+      return true;
+    }
+    if ( tagName == "preferred-address" ) {
+      setPreferredAddress( element.text() );
+      return true;
+    }
+    break;
+  case 'r':
+    if ( tagName == "role" ) {
+      setRole( element.text() );
+      return true;
+    }
+    break;
+  case 's':
+    if ( tagName == "spouse-name" ) {
+      setSpouseName( element.text() );
+      return true;
+    }
+    break;
+  case 'x':
+    if ( tagName == "x-logo" ) {
+      mLogoAttachmentName = element.text();
+      return true;
+    }
+    if ( tagName == "x-sound" ) {
+      mSoundAttachmentName = element.text();
+      return true;
+    }
+    if ( tagName == "x-custom" ) {
+      loadCustomAttributes( element );
+      return true;
+    }
+    if ( tagName == "x-title" ) {
+      setTitle( element.text() );
+      return true;
+    }
+    break;
+  case 'w':
+    if ( tagName == "web-page" ) {
+      setWebPage( element.text() );
+      return true;
+    }
+    break;
+  default:
+    break;
+  }
+  return KolabBase::loadAttribute( element );
+}
+
+bool Contact::saveAttributes( QDomElement& element ) const
+{
+  // Save the base class elements
+  KolabBase::saveAttributes( element );
+  saveNameAttribute( element );
+  writeString( element, "free-busy-url", freeBusyUrl() );
+  writeString( element, "organization", organization() );
+  writeString( element, "web-page", webPage() );
+  writeString( element, "im-address", imAddress() );
+  writeString( element, "department", department() );
+  writeString( element, "office-location", officeLocation() );
+  writeString( element, "profession", profession() );
+  writeString( element, "role", role() );
+  writeString( element, "job-title", title() );
+  writeString( element, "manager-name", managerName() );
+  writeString( element, "assistant", assistant() );
+  writeString( element, "nick-name", nickName() );
+  writeString( element, "spouse-name", spouseName() );
+  writeString( element, "birthday", dateToString( birthday() ) );
+  writeString( element, "anniversary", dateToString( anniversary() ) );
+  if ( !picture().isNull() )
+    writeString( element, "picture", mPictureAttachmentName );
+  if ( !logo().isNull() )
+    writeString( element, "x-logo", mLogoAttachmentName );
+  if ( !sound().isNull() )
+    writeString( element, "x-sound", mSoundAttachmentName );
+  writeString( element, "children", children() );
+  writeString( element, "gender", gender() );
+  writeString( element, "language", language() );
+  savePhoneAttributes( element );
+  saveEmailAttributes( element );
+  saveAddressAttributes( element );
+  writeString( element, "preferred-address", preferredAddress() );
+  if ( mHasGeo ) {
+    writeString( element, "latitude", QString::number( latitude(), 'g', DBL_DIG ) );
+    writeString( element, "longitude", QString::number( longitude(), 'g', DBL_DIG ) );
+  }
+  saveCustomAttributes( element );
+
+  return true;
+}
+
+bool Contact::loadXML( const QDomDocument& document )
+{
+  QDomElement top = document.documentElement();
+
+  if ( top.tagName() != "contact" ) {
+    qWarning( "XML error: Top tag was %s instead of the expected contact",
+              top.tagName().toAscii().data() );
+    return false;
+  }
+
+  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      if ( !loadAttribute( e ) ) {
+        // Unhandled tag - save for later storage
+        //kDebug() <<"Saving unhandled tag" << e.tagName();
+        Custom c;
+        c.app = s_unhandledTagAppName;
+        c.name = e.tagName();
+        c.value = e.text();
+        mCustomList.append( c );
+      }
+    } else
+      kDebug() <<"Node is not a comment or an element???";
+  }
+
+  return true;
+}
+
+QString Contact::saveXML() const
+{
+  QDomDocument document = domTree();
+  QDomElement element = document.createElement("contact" );
+  element.setAttribute( "version", "1.0" );
+  saveAttributes( element );
+  document.appendChild( element );
+  return document.toString();
+}
+
+static QString addressTypeToString( int /*KABC::Address::Type*/ type )
+{
+  if ( type & KABC::Address::Home )
+    return "home";
+  if ( type & KABC::Address::Work )
+    return "business";
+  return "other";
+}
+
+static int addressTypeFromString( const QString& type )
+{
+  if ( type == "home" )
+    return KABC::Address::Home;
+  if ( type == "business" )
+    return KABC::Address::Work;
+  // well, this shows "other" in the editor, which is what we want...
+  return KABC::Address::Dom | KABC::Address::Intl | KABC::Address::Postal | KABC::Address::Parcel;
+}
+
+static QStringList phoneTypeToString( KABC::PhoneNumber::Type type )
+{
+  // KABC has a bitfield, i.e. the same phone number can be used for work and home
+  // and fax and cellphone etc. etc.
+  // So when saving we need to create as many tags as bits that were set.
+  QStringList types;
+  if ( type & KABC::PhoneNumber::Fax ) {
+    if ( type & KABC::PhoneNumber::Home )
+      types << "homefax";
+    else // assume work -- if ( type & KABC::PhoneNumber::Work )
+      types << "businessfax";
+    type = type & ~KABC::PhoneNumber::Home;
+    type = type & ~KABC::PhoneNumber::Work;
+  }
+
+  // To support both "home1" and "home2", map Home+Pref to home1
+  if ( ( type & KABC::PhoneNumber::Home ) && ( type & KABC::PhoneNumber::Pref ) )
+  {
+      types << "home1";
+      type = type & ~KABC::PhoneNumber::Home;
+      type = type & ~KABC::PhoneNumber::Pref;
+  }
+  // To support both "business1" and "business2", map Work+Pref to business1
+  if ( ( type & KABC::PhoneNumber::Work ) && ( type & KABC::PhoneNumber::Pref ) )
+  {
+      types << "business1";
+      type = type & ~KABC::PhoneNumber::Work;
+      type = type & ~KABC::PhoneNumber::Pref;
+  }
+
+
+  if ( type & KABC::PhoneNumber::Home )
+    types << "home2";
+  if ( type & KABC::PhoneNumber::Msg ) // Msg==messaging
+    types << "company";
+  if ( type & KABC::PhoneNumber::Work )
+    types << "business2";
+  if ( type & KABC::PhoneNumber::Pref )
+    types << "primary";
+  if ( type & KABC::PhoneNumber::Voice )
+    types << "callback"; // ##
+  if ( type & KABC::PhoneNumber::Cell )
+    types << "mobile";
+  if ( type & KABC::PhoneNumber::Video )
+    types << "radio"; // ##
+  if ( type & KABC::PhoneNumber::Bbs )
+    types << "ttytdd";
+  if ( type & KABC::PhoneNumber::Modem )
+    types << "telex"; // #
+  if ( type & KABC::PhoneNumber::Car )
+    types << "car";
+  if ( type & KABC::PhoneNumber::Isdn )
+    types << "isdn";
+  if ( type & KABC::PhoneNumber::Pcs )
+    types << "assistant"; // ## Assistant is e.g. secretary
+  if ( type & KABC::PhoneNumber::Pager )
+    types << "pager";
+  return types;
+}
+
+static KABC::PhoneNumber::Type phoneTypeFromString( const QString& type )
+{
+  if ( type == "homefax" )
+    return KABC::PhoneNumber::Home | KABC::PhoneNumber::Fax;
+  if ( type == "businessfax" )
+    return KABC::PhoneNumber::Work | KABC::PhoneNumber::Fax;
+  if ( type == "business1" )
+    return KABC::PhoneNumber::Work | KABC::PhoneNumber::Pref;
+  if ( type == "business2" )
+    return KABC::PhoneNumber::Work;
+  if ( type == "home1" )
+    return KABC::PhoneNumber::Home | KABC::PhoneNumber::Pref;
+  if ( type == "home2" )
+    return KABC::PhoneNumber::Home;
+  if ( type == "company" )
+    return KABC::PhoneNumber::Msg;
+  if ( type == "primary" )
+    return KABC::PhoneNumber::Pref;
+  if ( type == "callback" )
+    return KABC::PhoneNumber::Voice;
+  if ( type == "mobile" )
+    return KABC::PhoneNumber::Cell;
+  if ( type == "radio" )
+    return KABC::PhoneNumber::Video;
+  if ( type == "ttytdd" )
+    return KABC::PhoneNumber::Bbs;
+  if ( type == "telex" )
+    return KABC::PhoneNumber::Modem;
+  if ( type == "car" )
+    return KABC::PhoneNumber::Car;
+  if ( type == "isdn" )
+    return KABC::PhoneNumber::Isdn;
+  if ( type == "assistant" )
+    return KABC::PhoneNumber::Pcs;
+  if ( type == "pager" )
+    return KABC::PhoneNumber::Pager;
+  return KABC::PhoneNumber::Home; // whatever
+}
+
+static const char* s_knownCustomFields[] = {
+  "X-IMAddress",
+  "X-Office",
+  "X-Profession",
+  "X-ManagersName",
+  "X-AssistantsName",
+  "X-SpousesName",
+  "X-Anniversary",
+  "DistributionList",
+  0
+};
+
+
+// The saving is addressee -> Contact -> xml, this is the first part
+void Contact::setFields( const KABC::Addressee* addressee )
+{
+  KolabBase::setFields( addressee );
+
+  setGivenName( addressee->givenName() );
+  setMiddleNames( addressee->additionalName() );
+  setLastName( addressee->familyName() );
+  setFullName( addressee->formattedName() );
+  setPrefix( addressee->prefix() );
+  setSuffix( addressee->suffix() );
+  setOrganization( addressee->organization() );
+  setWebPage( addressee->url().url() );
+  setIMAddress( addressee->custom( "KADDRESSBOOK", "X-IMAddress" ) );
+  setDepartment( addressee->department());
+  setOfficeLocation( addressee->custom( "KADDRESSBOOK", "X-Office" ) );
+  setProfession( addressee->custom( "KADDRESSBOOK", "X-Profession" ) );
+  setRole( addressee->role() );
+  setTitle( addressee->title() );
+  setManagerName( addressee->custom( "KADDRESSBOOK", "X-ManagersName" ) );
+  setAssistant( addressee->custom( "KADDRESSBOOK", "X-AssistantsName" ) );
+  setNickName( addressee->nickName() );
+  setSpouseName( addressee->custom( "KADDRESSBOOK", "X-SpousesName" ) );
+  if ( !addressee->birthday().isNull() )
+    setBirthday( addressee->birthday().date() );
+  const QString& anniversary = addressee->custom( "KADDRESSBOOK", "X-Anniversary" );
+  if ( !anniversary.isEmpty() )
+    setAnniversary( stringToDate( anniversary  ) );
+
+  const QStringList emails = addressee->emails();
+  // Conversion problem here:
+  // KABC::Addressee has only one full name and N addresses, but the XML format
+  // has N times (fullname+address). So we just copy the fullname over and ignore it on loading.
+  for ( QStringList::ConstIterator it = emails.constBegin(); it != emails.constEnd(); ++it ) {
+    Email email;
+    email.displayName = fullName();
+    email.smtpAddress = *it;
+    addEmail( email );
+  }
+
+  // save formatted full email for later usage
+  mFullEmail = addressee->fullEmail();
+
+  // Now the real-world addresses
+  QString preferredAddress = "home";
+  const KABC::Address::List addresses = addressee->addresses();
+  for ( KABC::Address::List::ConstIterator it = addresses.constBegin() ; it != addresses.constEnd(); ++it ) {
+    Address address;
+    address.kdeAddressType = (*it).type();
+    address.type = addressTypeToString( address.kdeAddressType );
+    address.street = (*it).street();
+    address.pobox = (*it).postOfficeBox();
+    address.locality = (*it).locality();
+    address.region = (*it).region();
+    address.postalCode = (*it).postalCode();
+    address.country = (*it).country();
+    // ## TODO not in the XML format: extended address info.
+    // ## KDE-specific tags? Or hiding those fields? Or adding a warning?
+    addAddress( address );
+    if ( address.kdeAddressType & KABC::Address::Pref ) {
+      preferredAddress = address.type; // home, business or other
+    }
+  }
+  setPreferredAddress( preferredAddress );
+
+  const KABC::PhoneNumber::List phones = addressee->phoneNumbers();
+  for ( KABC::PhoneNumber::List::ConstIterator it = phones.constBegin(); it != phones.constEnd(); ++it ) {
+    // Create a tag per phone type set in the bitfield
+    QStringList types = phoneTypeToString( (*it).type() );
+    for( QStringList::ConstIterator typit = types.constBegin(); typit != types.constEnd(); ++typit ) {
+      PhoneNumber phoneNumber;
+      phoneNumber.type = *typit;
+      phoneNumber.number = (*it).number();
+      addPhoneNumber( phoneNumber );
+    }
+  }
+
+  setPicture( loadPictureFromAddressee( addressee->photo() ), addressee->photo().type() );
+  mPictureAttachmentName = addressee->custom( "KOLAB", "PictureAttachmentName" );
+  if ( mPictureAttachmentName.isEmpty() )
+    mPictureAttachmentName = s_pictureAttachmentName;
+
+  setLogo( loadPictureFromAddressee( addressee->logo() ), addressee->logo().type() );
+  mLogoAttachmentName = addressee->custom( "KOLAB", "LogoAttachmentName" );
+  if ( mLogoAttachmentName.isEmpty() )
+    mLogoAttachmentName = s_logoAttachmentName;
+
+  setSound( loadSoundFromAddressee( addressee->sound() ) );
+  mSoundAttachmentName = addressee->custom( "KOLAB", "SoundAttachmentName" );
+  if ( mSoundAttachmentName.isEmpty() )
+    mSoundAttachmentName = s_soundAttachmentName;
+
+  if ( addressee->geo().isValid() ) {
+    setLatitude( addressee->geo().latitude() );
+    setLongitude( addressee->geo().longitude() );
+    mHasGeo = true;
+  }
+
+  // Other KADDRESSBOOK custom fields than those already handled
+  //    (includes e.g. crypto settings, and extra im addresses)
+  QStringList knownCustoms;
+  for ( const char** p = s_knownCustomFields; *p; ++p )
+    knownCustoms << QString::fromLatin1( *p );
+  QStringList customs = addressee->customs();
+  for( QStringList::ConstIterator it = customs.constBegin(); it != customs.constEnd(); ++it ) {
+    // KABC::Addressee doesn't offer a real way to iterate over customs, other than splitting strings ourselves
+    // The format is "app-name:value".
+    int pos = (*it).indexOf( '-' );
+    if ( pos == -1 ) continue;
+    QString app = (*it).left( pos );
+    if ( app == "KOLAB" ) continue;
+    QString name = (*it).mid( pos + 1 );
+    pos = name.indexOf( ':' );
+    if ( pos == -1 ) continue;
+    QString value = name.mid( pos + 1 );
+    name = name.left( pos );
+    if ( !knownCustoms.contains( name ) ) {
+      //kDebug() <<"app=" << app <<" name=" << name <<" value=" << value;
+      Custom c;
+      if ( app != "KADDRESSBOOK" ) // that's the default
+        c.app = app;
+      c.name = name;
+      c.value = value;
+      mCustomList.append( c );
+    }
+  }
+
+  const QString url = addressee->custom("KOLAB", "FreebusyUrl");
+  if ( !url.isEmpty() ) {
+    setFreeBusyUrl( url );
+  }
+
+  // Those fields, although defined in Addressee, are not used in KDE
+  // (e.g. not visible in kaddressbook/addresseeeditorwidget.cpp)
+  // So it doesn't matter much if we don't have them in the XML.
+  // mailer, timezone, productId, sortString, agent, rfc2426 name()
+
+  // Things KAddressBook can't handle, so they are saved as unhandled tags:
+  // initials, children, gender, language
+}
+
+
+// The loading is: xml -> Contact -> addressee, this is the second part
+void Contact::saveTo( KABC::Addressee* addressee )
+{
+  // TODO: This needs the same set of TODOs as the setFields method
+  KolabBase::saveTo( addressee );
+
+  addressee->setGivenName( givenName() );
+  addressee->setAdditionalName( middleNames() );
+  addressee->setFamilyName( lastName() );
+  addressee->setFormattedName( fullName() );
+  addressee->setPrefix( prefix() );
+  addressee->setSuffix( suffix() );
+  addressee->setOrganization( organization() );
+  addressee->setUrl( QUrl(webPage()) );
+  addressee->insertCustom( "KADDRESSBOOK", "X-IMAddress", imAddress() );
+  addressee->setDepartment( department() );
+  addressee->insertCustom( "KADDRESSBOOK", "X-Office", officeLocation() );
+  addressee->insertCustom( "KADDRESSBOOK", "X-Profession", profession() );
+  addressee->setRole( role() );
+  addressee->setTitle( title() );
+  addressee->insertCustom( "KADDRESSBOOK", "X-ManagersName", managerName() );
+  addressee->insertCustom( "KADDRESSBOOK", "X-AssistantsName", assistant() );
+  addressee->setNickName( nickName() );
+  addressee->insertCustom( "KADDRESSBOOK", "X-SpousesName", spouseName() );
+  if ( birthday().isValid() )
+    addressee->setBirthday( QDateTime( birthday() ) );
+
+  if ( anniversary().isValid() )
+    addressee->insertCustom( "KADDRESSBOOK", "X-Anniversary",
+                             dateToString( anniversary() ) );
+  else
+    addressee->removeCustom( "KADDRESSBOOK", "X-Anniversary" );
+  
+  addressee->insertCustom( "KOLAB", "FreebusyUrl", freeBusyUrl() );
+
+  // We need to store both the original attachment name and the picture data into the addressee.
+  // This is important, otherwise we would save the image under another attachment name w/o deleting the original one!
+  if ( !mPicture.isNull() ) {
+    KABC::Picture picture( mPicture );
+    addressee->setPhoto( picture );
+  }
+  // Note that we must save the filename in all cases, so that removing the picture
+  // actually deletes the attachment.
+  addressee->insertCustom( "KOLAB", "PictureAttachmentName", mPictureAttachmentName );
+  if ( !mLogo.isNull() ) {
+    KABC::Picture picture( mLogo );
+    addressee->setLogo( picture );
+  }
+  addressee->insertCustom( "KOLAB", "LogoAttachmentName", mLogoAttachmentName );
+  if ( !mSound.isNull() )
+    addressee->setSound( KABC::Sound( mSound ) );
+  addressee->insertCustom( "KOLAB", "SoundAttachmentName", mSoundAttachmentName );
+
+  if ( mHasGeo )
+    addressee->setGeo( KABC::Geo( mLatitude, mLongitude ) );
+
+  QStringList emailAddresses;
+  for ( QList<Email>::ConstIterator it = mEmails.constBegin(); it != mEmails.constEnd(); ++it ) {
+    // we can't do anything with (*it).displayName
+    emailAddresses.append( (*it).smtpAddress );
+  }
+  addressee->setEmails( emailAddresses );
+
+  for ( QList<Address>::ConstIterator it = mAddresses.constBegin(); it != mAddresses.constEnd(); ++it ) {
+    KABC::Address address;
+    int type = (*it).kdeAddressType;
+    if ( type == -1 ) { // no kde-specific type available
+      type = addressTypeFromString( (*it).type );
+      if ( (*it).type == mPreferredAddress )
+        type |= KABC::Address::Pref;
+    }
+    address.setType( static_cast<KABC::Address::Type>(type) );
+    address.setStreet( (*it).street );
+    address.setPostOfficeBox( (*it).pobox );
+    address.setLocality( (*it).locality );
+    address.setRegion( (*it).region );
+    address.setPostalCode( (*it).postalCode );
+    address.setCountry( (*it).country );
+    addressee->insertAddress( address );
+  }
+
+  for ( QList<PhoneNumber>::ConstIterator it = mPhoneNumbers.constBegin(); it != mPhoneNumbers.constEnd(); ++it ) {
+    KABC::PhoneNumber number;
+    number.setType( phoneTypeFromString( (*it).type ) );
+    number.setNumber( (*it).number );
+    addressee->insertPhoneNumber( number );
+  }
+
+  for( QList<Custom>::ConstIterator it = mCustomList.constBegin(); it != mCustomList.constEnd(); ++it ) {
+    QString app = (*it).app.isEmpty() ? QString::fromLatin1( "KADDRESSBOOK" ) : (*it).app;
+    addressee->insertCustom( app, (*it).name, (*it).value );
+  }
+  //kDebug() << addressee->customs();
+}
+
+QImage Contact::loadPictureFromAddressee( const KABC::Picture& picture )
+{
+  QImage img;
+  if ( !picture.isIntern() && !picture.url().isEmpty() ) {
+    QString tmpFile;
+    kWarning() << "external pictures are currently not supported";
+    //FIXME add kio support to libcalendaring or use libcurl
+//     if ( KIO::NetAccess::download( picture.url(), tmpFile, 0 /*no widget known*/ ) ) {
+//       img.load( tmpFile );
+//       KIO::NetAccess::removeTempFile( tmpFile );
+//     }
+  } else
+    img = picture.data();
+  return img;
+}
+
+QByteArray KolabV2::Contact::loadSoundFromAddressee( const KABC::Sound& sound )
+{
+  QByteArray data;
+  if ( !sound.isIntern() && !sound.url().isEmpty() ) {
+    QString tmpFile;
+//     if ( KIO::NetAccess::download( sound.url(), tmpFile, 0 /*no widget known*/ ) ) {
+//       QFile f( tmpFile );
+//       if ( f.open( QIODevice::ReadOnly ) ) {
+//         data = f.readAll();
+//         f.close();
+//       }
+//       KIO::NetAccess::removeTempFile( tmpFile );
+//     }
+  } else
+    data = sound.data();
+  return data;
+}
+
+QString KolabV2::Contact::productID() const
+{
+  // TODO: When KAB has the version number in a header file, don't hardcode (Bo)
+  // Or we could use Addressee::productID? (David)
+  return "KAddressBook 3.3, Kolab resource";
+}
diff --git a/src/kolabformatV2/contact.h b/src/kolabformatV2/contact.h
new file mode 100644
index 0000000..44ef26d
--- /dev/null
+++ b/src/kolabformatV2/contact.h
@@ -0,0 +1,278 @@
+/*
+    This file is part of libkabc and/or kaddressbook.
+    Copyright (c) 2002 - 2004 Klarlvdalens Datakonsult AB
+        <info@klaralvdalens-datakonsult.se>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#ifndef KOLABV2CONTACT_H
+#define KOLABV2CONTACT_H
+
+#include "kolabbase.h"
+#include <qimage.h>
+
+namespace KABC {
+  class Addressee;
+  class Picture;
+  class Sound;
+}
+
+namespace KolabV2 {
+
+class Contact : public KolabBase {
+public:
+  struct PhoneNumber {
+  public:
+    QString type;
+    QString number;
+  };
+
+  struct Address {
+  public:
+    Address() : kdeAddressType( -1 )
+    {
+    }
+    int kdeAddressType; // KABC::Address::Type
+    QString type;       // kolab-compliant address type: home, work or other
+    QString street;
+    QString pobox;
+    QString locality;
+    QString region;
+    QString postalCode;
+    QString country;
+  };
+
+  explicit Contact( const KABC::Addressee* address );
+  Contact( const QString& xml );
+  ~Contact();
+
+  void saveTo( KABC::Addressee* address );
+
+  QString type() const { return "Contact"; }
+
+  void setGivenName( const QString& name );
+  QString givenName() const;
+
+  void setMiddleNames( const QString& names );
+  QString middleNames() const;
+
+  void setLastName( const QString& name );
+  QString lastName() const;
+
+  void setFullName( const QString& name );
+  QString fullName() const;
+
+  void setInitials( const QString& initials );
+  QString initials() const;
+
+  void setPrefix( const QString& prefix );
+  QString prefix() const;
+
+  void setSuffix( const QString& suffix );
+  QString suffix() const;
+
+  void setRole( const QString& role );
+  QString role() const;
+
+  void setFreeBusyUrl( const QString& fbUrl );
+  QString freeBusyUrl() const;
+
+  void setOrganization( const QString& organization );
+  QString organization() const;
+
+  void setWebPage( const QString& url );
+  QString webPage() const;
+
+  void setIMAddress( const QString& imAddress );
+  QString imAddress() const;
+
+  void setDepartment( const QString& department );
+  QString department() const;
+
+  void setOfficeLocation( const QString& location );
+  QString officeLocation() const;
+
+  void setProfession( const QString& profession );
+  QString profession() const;
+
+  void setTitle( const QString& title );
+  QString title() const;
+
+  void setManagerName( const QString& name );
+  QString managerName() const;
+
+  void setAssistant( const QString& name );
+  QString assistant() const;
+
+  void setNickName( const QString& name );
+  QString nickName() const;
+
+  void setSpouseName( const QString& name );
+  QString spouseName() const;
+
+  void setBirthday( const QDate& date );
+  QDate birthday() const;
+
+  void setAnniversary( const QDate& date );
+  QDate anniversary() const;
+
+  void setPicture( const QImage& image, const QString &format) { mPicture = image; mPictureFormat = format; }
+  QString pictureAttachmentName() const { return mPictureAttachmentName; }
+  QString pictureFormat() const { return mPictureFormat; }
+  QImage picture() const { return mPicture; }
+
+  void setLogo( const QImage& image, const QString &format ) { mLogo = image; mLogoFormat = format; }
+  QString logoAttachmentName() const { return mLogoAttachmentName; }
+  QString logoFormat() const { return mLogoFormat; }
+  QImage logo() const { return mLogo; }
+
+  void setSound( const QByteArray& sound ) { mSound = sound; }
+  QString soundAttachmentName() const { return mSoundAttachmentName; }
+  QByteArray sound() const { return mSound; }
+
+  void setChildren( const QString& children );
+  QString children() const;
+
+  void setGender( const QString& gender );
+  QString gender() const;
+
+  void setLanguage( const QString& language );
+  QString language() const;
+
+  void addPhoneNumber( const PhoneNumber& number );
+  QList<PhoneNumber>& phoneNumbers();
+  const QList<PhoneNumber>& phoneNumbers() const;
+
+  void addEmail( const Email& email );
+  QList<Email>& emails();
+  const QList<Email>& emails() const;
+
+  QString fullEmail() const;
+
+  void addAddress( const Address& address );
+  QList<Address>& addresses();
+  const QList<Address>& addresses() const;
+
+  // which address is preferred: home or business or other
+  void setPreferredAddress( const QString& address );
+  QString preferredAddress() const;
+
+  float latitude() const { return mLatitude; }
+  void setLatitude( float latitude ) { mLatitude = latitude; }
+
+  float longitude() const { return mLongitude; }
+  void setLongitude( float longitude ) { mLongitude = longitude; }
+
+  // Load the attributes of this class
+  bool loadAttribute( QDomElement& );
+
+  // Save the attributes of this class
+  bool saveAttributes( QDomElement& ) const;
+
+  // Load this note by reading the XML file
+  bool loadXML( const QDomDocument& xml );
+
+  // Serialize this note to an XML string
+  QString saveXML() const;
+
+protected:
+  void setFields( const KABC::Addressee* );
+
+private:
+  bool loadNameAttribute( QDomElement& element );
+  void saveNameAttribute( QDomElement& element ) const;
+
+  bool loadPhoneAttribute( QDomElement& element );
+  void savePhoneAttributes( QDomElement& element ) const;
+
+  void saveEmailAttributes( QDomElement& element ) const;
+
+  bool loadAddressAttribute( QDomElement& element );
+  void saveAddressAttributes( QDomElement& element ) const;
+
+  void loadCustomAttributes( QDomElement& element );
+  void saveCustomAttributes( QDomElement& element ) const;
+
+  QImage loadPictureFromAddressee( const KABC::Picture& picture );
+
+  QByteArray loadSoundFromAddressee( const KABC::Sound& sound );
+
+  QString productID() const;
+
+  QString mGivenName;
+  QString mMiddleNames;
+  QString mLastName;
+  QString mFullName;
+  QString mInitials;
+  QString mPrefix;
+  QString mSuffix;
+  QString mRole;
+  QString mFreeBusyUrl;
+  QString mOrganization;
+  QString mWebPage;
+  QString mIMAddress;
+  QString mDepartment;
+  QString mOfficeLocation;
+  QString mProfession;
+  QString mTitle;
+  QString mManagerName;
+  QString mAssistant;
+  QString mNickName;
+  QString mSpouseName;
+  QDate mBirthday;
+  QDate mAnniversary;
+  QImage mPicture;
+  QString mPictureFormat;
+  QImage mLogo;
+  QString mLogoFormat;
+  QByteArray mSound;
+  QString mPictureAttachmentName;
+  QString mLogoAttachmentName;
+  QString mSoundAttachmentName;
+  QString mChildren;
+  QString mGender;
+  QString mLanguage;
+  QList<PhoneNumber> mPhoneNumbers;
+  QList<Email> mEmails;
+  QString mFullEmail;
+  QList<Address> mAddresses;
+  QString mPreferredAddress;
+  float mLatitude;
+  float mLongitude;
+  bool mHasGeo;
+  struct Custom {
+    QString app;
+    QString name;
+    QString value;
+  };
+  QList<Custom> mCustomList;
+};
+
+}
+
+#endif // KOLABCONTACT_H
diff --git a/src/kolabformatV2/distributionlist.cpp b/src/kolabformatV2/distributionlist.cpp
new file mode 100644
index 0000000..6fe6873
--- /dev/null
+++ b/src/kolabformatV2/distributionlist.cpp
@@ -0,0 +1,231 @@
+/*
+    This file is part of Akonadi KolabProxy.
+    Copyright (c) 2009 Kevin Krammer <kevin.krammer@gmx.at>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#include "distributionlist.h"
+
+#include <kabc/addressee.h>
+#include <kabc/contactgroup.h>
+#include <kdebug.h>
+
+using namespace KolabV2;
+
+static const char* s_unhandledTagAppName = "KOLABUNHANDLED"; // no hyphens in appnames!
+
+// saving (contactgroup->xml)
+DistributionList::DistributionList( const KABC::ContactGroup* contactGroup )
+{
+  setFields( contactGroup );
+}
+
+// loading (xml->contactgroup)
+DistributionList::DistributionList( const QString& xml )
+{
+  load( xml );
+}
+
+DistributionList::~DistributionList()
+{
+}
+
+void DistributionList::setName( const QString& name )
+{
+  mName = name;
+}
+
+QString DistributionList::name() const
+{
+  return mName;
+}
+
+void KolabV2::DistributionList::loadDistrListMember( const QDomElement& element )
+{
+  Member member;
+  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      QString tagName = e.tagName();
+      if ( tagName == "display-name" )
+        member.displayName = e.text();
+      else if ( tagName == "smtp-address" )
+        member.email = e.text();
+      else if ( tagName == "uid" )
+        member.uid = e.text();
+    }
+  }
+  mDistrListMembers.append( member );
+}
+
+void DistributionList::saveDistrListMembers( QDomElement& element ) const
+{
+  QList<Member>::ConstIterator it = mDistrListMembers.constBegin();
+  for( ; it != mDistrListMembers.constEnd(); ++it ) {
+    QDomElement e = element.ownerDocument().createElement( "member" );
+    element.appendChild( e );
+    const Member& m = *it;
+    if (!m.uid.isEmpty()) {
+      writeString( e, "uid", m.uid );
+    } else {
+      writeString( e, "display-name", m.displayName );
+      writeString( e, "smtp-address", m.email );
+    }
+  }
+}
+
+bool DistributionList::loadAttribute( QDomElement& element )
+{
+  const QString tagName = element.tagName();
+  switch ( tagName[0].toLatin1() ) {
+  case 'd':
+    if ( tagName == "display-name" ) {
+      setName( element.text() );
+      return true;
+    }
+    break;
+  case 'm':
+    if ( tagName == "member" ) {
+      loadDistrListMember( element );
+      return true;
+    }
+    break;
+  default:
+    break;
+  }
+  return KolabBase::loadAttribute( element );
+}
+
+bool DistributionList::saveAttributes( QDomElement& element ) const
+{
+  // Save the base class elements
+  KolabBase::saveAttributes( element );
+  writeString( element, "display-name", name() );
+  saveDistrListMembers( element );
+
+  return true;
+}
+
+bool DistributionList::loadXML( const QDomDocument& document )
+{
+  QDomElement top = document.documentElement();
+
+  if ( top.tagName() != "distribution-list" ) {
+    qWarning( "XML error: Top tag was %s instead of the expected distribution-list",
+              top.tagName().toAscii().data() );
+    return false;
+  }
+
+
+  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      if ( !loadAttribute( e ) ) {
+        // Unhandled tag - save for later storage
+        //kDebug() <<"Saving unhandled tag" << e.tagName();
+        Custom c;
+        c.app = s_unhandledTagAppName;
+        c.name = e.tagName();
+        c.value = e.text();
+        mCustomList.append( c );
+      }
+    } else
+      kDebug() <<"Node is not a comment or an element???";
+  }
+
+  return true;
+}
+
+QString DistributionList::saveXML() const
+{
+  QDomDocument document = domTree();
+  QDomElement element = document.createElement( "distribution-list" );
+  element.setAttribute( "version", "1.0" );
+  saveAttributes( element );
+  document.appendChild( element );
+  return document.toString();
+}
+
+QString DistributionList::productID() const
+{
+  // TODO should we get name/version from desktop file?
+  return QLatin1String( "Akonadi Kolab Proxy" );
+}
+
+// The saving is contactgroup -> DistributionList -> xml, this is the first part
+void DistributionList::setFields( const KABC::ContactGroup* contactGroup )
+{
+  KolabBase::setFields( contactGroup );
+
+  setName( contactGroup->name() );
+
+  // explicit contact data
+  for ( uint index = 0; index < contactGroup->dataCount(); ++index ) {
+    const KABC::ContactGroup::Data& data = contactGroup->data( index );
+
+    Member m;
+    m.displayName = data.name();
+    m.email = data.email();
+
+    mDistrListMembers.append( m );
+  }
+  for ( uint index = 0; index < contactGroup->contactReferenceCount(); ++index ) {
+    const KABC::ContactGroup::ContactReference& data = contactGroup->contactReference( index );
+
+    Member m;
+    m.uid = data.uid();
+
+    mDistrListMembers.append( m );
+  }
+  if (contactGroup->contactGroupReferenceCount() > 0) {
+    kWarning() << "Tried to save contact group references, which should have been resolved already";
+  }
+}
+
+// The loading is: xml -> DistributionList -> contactgroup, this is the second part
+void DistributionList::saveTo( KABC::ContactGroup* contactGroup )
+{
+  KolabBase::saveTo( contactGroup );
+
+  contactGroup->setName( name() );
+
+  QList<Member>::ConstIterator mit = mDistrListMembers.constBegin();
+  for ( ; mit != mDistrListMembers.constEnd(); ++mit ) {
+    if (!(*mit).uid.isEmpty()) {
+      contactGroup->append(KABC::ContactGroup::ContactReference( (*mit).uid ));
+    } else {
+      contactGroup->append(KABC::ContactGroup::Data( (*mit).displayName, (*mit).email ));
+    }
+  }
+}
+
+// kate: space-indent on; indent-width 2; replace-tabs on;
diff --git a/src/kolabformatV2/distributionlist.h b/src/kolabformatV2/distributionlist.h
new file mode 100644
index 0000000..f646540
--- /dev/null
+++ b/src/kolabformatV2/distributionlist.h
@@ -0,0 +1,97 @@
+/*
+    This file is part of Akonadi KolabProxy
+    Copyright (c) 2009 <kevin.krammer@gmx.at>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#ifndef KOLABV2DISTRIBUTIONLIST_H
+#define KOLABV2DISTRIBUTIONLIST_H
+
+#include "kolabbase.h"
+
+namespace KABC {
+  class ContactGroup;
+}
+
+namespace KolabV2 {
+
+class DistributionList : public KolabBase {
+public:
+  explicit DistributionList( const KABC::ContactGroup* contactGroup );
+  DistributionList( const QString& xml );
+  ~DistributionList();
+
+  void saveTo( KABC::ContactGroup* contactGroup );
+
+  QString type() const { return "DistributionList"; }
+
+  void setName( const QString& name );
+  QString name() const;
+
+  // Load the attributes of this class
+  bool loadAttribute( QDomElement& );
+
+  // Save the attributes of this class
+  bool saveAttributes( QDomElement& ) const;
+
+  // Load this note by reading the XML file
+  bool loadXML( const QDomDocument& xml );
+
+  // Serialize this note to an XML string
+  QString saveXML() const;
+
+  QString productID() const;
+
+protected:
+  void setFields( const KABC::ContactGroup* );
+
+private:
+  void loadDistrListMember( const QDomElement& element );
+  void saveDistrListMembers( QDomElement& element ) const;
+
+  QString mName;
+
+  struct Custom {
+    QString app;
+    QString name;
+    QString value;
+  };
+  QList<Custom> mCustomList;
+
+  struct Member {
+    QString displayName;
+    QString email;
+    QString uid;
+  };
+  QList<Member> mDistrListMembers;
+};
+
+}
+
+#endif // KOLABDISTRIBUTIONLIST_H
+// kate: space-indent on; indent-width 2; replace-tabs on;
diff --git a/src/kolabformatV2/event.cpp b/src/kolabformatV2/event.cpp
new file mode 100644
index 0000000..b09612d
--- /dev/null
+++ b/src/kolabformatV2/event.cpp
@@ -0,0 +1,221 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#include "event.h"
+
+#include <kcalcore/event.h>
+#include <kdebug.h>
+
+using namespace KolabV2;
+
+
+KCalCore::Event::Ptr Event::fromXml( const QDomDocument& xmlDoc, const QString& tz)
+{
+  Event event( tz );
+  event.loadXML( xmlDoc );
+  KCalCore::Event::Ptr kcalEvent( new KCalCore::Event() );
+  event.saveTo( kcalEvent );
+  return kcalEvent;
+}
+
+QString Event::eventToXML( const KCalCore::Event::Ptr &kcalEvent, const QString& tz  )
+{
+  Event event( tz, kcalEvent );
+  return event.saveXML();
+}
+
+Event::Event( const QString& tz, const KCalCore::Event::Ptr &event )
+  : Incidence( tz, event ),
+  mShowTimeAs( KCalCore::Event::Opaque ), mHasEndDate( false )
+{
+  if ( event ) {
+    setFields( event );
+  }
+}
+
+Event::~Event()
+{
+}
+
+void Event::setTransparency( KCalCore::Event::Transparency transparency )
+{
+  mShowTimeAs = transparency;
+}
+
+KCalCore::Event::Transparency Event::transparency() const
+{
+  return mShowTimeAs;
+}
+
+void Event::setEndDate( const KDateTime& date )
+{
+  mEndDate = date;
+  mHasEndDate = true;
+  if ( mFloatingStatus == AllDay )
+    kDebug() <<"ERROR: Time on end date but no time on the event";
+  mFloatingStatus = HasTime;
+}
+
+void Event::setEndDate( const QDate& date )
+{
+  mEndDate = KDateTime( date );
+  mHasEndDate = true;
+  if ( mFloatingStatus == HasTime )
+    kDebug() <<"ERROR: No time on end date but time on the event";
+  mFloatingStatus = AllDay;
+}
+
+void Event::setEndDate( const QString& endDate )
+{
+  if ( endDate.length() > 10 )
+    // This is a date + time
+    setEndDate( stringToDateTime( endDate ) );
+  else
+    // This is only a date
+    setEndDate( stringToDate( endDate ) );
+}
+
+KDateTime Event::endDate() const
+{
+  return mEndDate;
+}
+
+bool Event::loadAttribute( QDomElement& element )
+{
+  // This method doesn't handle the color-label tag yet
+  QString tagName = element.tagName();
+
+  if ( tagName == "show-time-as" ) {
+    // TODO: Support tentative and outofoffice
+    if ( element.text() == "free" )
+      setTransparency( KCalCore::Event::Transparent );
+    else
+      setTransparency( KCalCore::Event::Opaque );
+  } else if ( tagName == "end-date" )
+    setEndDate( element.text() );
+  else
+    return Incidence::loadAttribute( element );
+
+  // We handled this
+  return true;
+}
+
+bool Event::saveAttributes( QDomElement& element ) const
+{
+  // Save the base class elements
+  Incidence::saveAttributes( element );
+
+  // TODO: Support tentative and outofoffice
+  if ( transparency() == KCalCore::Event::Transparent )
+    writeString( element, "show-time-as", "free" );
+  else
+    writeString( element, "show-time-as", "busy" );
+  if ( mHasEndDate ) {
+    if ( mFloatingStatus == HasTime )
+      writeString( element, "end-date", dateTimeToString( endDate() ) );
+    else
+      writeString( element, "end-date", dateToString( endDate().date() ) );
+  }
+
+  return true;
+}
+
+
+bool Event::loadXML( const QDomDocument& document )
+{
+  QDomElement top = document.documentElement();
+
+  if ( top.tagName() != "event" ) {
+    qWarning( "XML error: Top tag was %s instead of the expected event",
+              top.tagName().toAscii().data() );
+    return false;
+  }
+
+  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      loadAttribute( e );
+    } else
+      kDebug() <<"Node is not a comment or an element???";
+  }
+
+  return true;
+}
+
+QString Event::saveXML() const
+{
+  QDomDocument document = domTree();
+  QDomElement element = document.createElement( "event" );
+  element.setAttribute( "version", "1.0" );
+  saveAttributes( element );
+  document.appendChild( element );
+  return document.toString();
+}
+
+void Event::setFields( const KCalCore::Event::Ptr &event )
+{
+  Incidence::setFields( event );
+
+  // note: if hasEndDate() is false and hasDuration() is true
+  // dtEnd() returns start+duration
+  if ( event->hasEndDate() || event->hasDuration() ) {
+    if ( event->allDay() ) {
+      // This is an all-day event. Don't timezone move this one
+      mFloatingStatus = AllDay;
+      setEndDate( event->dtEnd().date() );
+    } else {
+      mFloatingStatus = HasTime;
+      setEndDate( localToUTC( event->dtEnd() ) );
+    }
+  } else {
+    mHasEndDate = false;
+  }
+  setTransparency( event->transparency() );
+}
+
+void Event::saveTo( const KCalCore::Event::Ptr &event )
+{
+  Incidence::saveTo( event );
+
+  event->setHasEndDate( mHasEndDate );
+  if ( mHasEndDate ) {
+    if ( mFloatingStatus == AllDay )
+      // This is an all-day event. Don't timezone move this one
+      event->setDtEnd( endDate() );
+    else
+      event->setDtEnd( utcToLocal( endDate() ) );
+  }
+  event->setTransparency( transparency() );
+}
diff --git a/src/kolabformatV2/event.h b/src/kolabformatV2/event.h
new file mode 100644
index 0000000..be0d4bf
--- /dev/null
+++ b/src/kolabformatV2/event.h
@@ -0,0 +1,101 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#ifndef KOLABV2_EVENT_H
+#define KOLABV2_EVENT_H
+
+#include "incidence.h"
+
+#include <kcalcore/event.h>
+
+class QDomElement;
+
+
+namespace KolabV2 {
+
+/**
+ * This class represents an event, and knows how to load/save it
+ * from/to XML, and from/to a KCalCore::Event.
+ * The instances of this class are temporary, only used to convert
+ * one to the other.
+ */
+class Event : public Incidence {
+public:
+  /// Use this to parse an xml string to a event entry
+  /// The caller is responsible for deleting the returned event
+  static KCalCore::Event::Ptr fromXml( const QDomDocument& xmlDoc, const QString& tz);
+
+  /// Use this to get an xml string describing this event entry
+  static QString eventToXML( const KCalCore::Event::Ptr &, const QString& tz );
+
+  /// Create a event object and
+  explicit Event( const QString& tz,
+                  const KCalCore::Event::Ptr &event = KCalCore::Event::Ptr() );
+  virtual ~Event();
+
+  void saveTo( const KCalCore::Event::Ptr &event );
+
+  virtual QString type() const { return "Event"; }
+
+  virtual void setTransparency( KCalCore::Event::Transparency transparency );
+  virtual KCalCore::Event::Transparency transparency() const;
+
+  virtual void setEndDate( const KDateTime& date );
+  virtual void setEndDate( const QDate& date );
+  virtual void setEndDate( const QString& date );
+  virtual KDateTime endDate() const;
+
+  // Load the attributes of this class
+  virtual bool loadAttribute( QDomElement& );
+
+  // Save the attributes of this class
+  virtual bool saveAttributes( QDomElement& ) const;
+
+  // Load this event by reading the XML file
+  virtual bool loadXML( const QDomDocument& xml );
+
+  // Serialize this event to an XML string
+  virtual QString saveXML() const;
+
+protected:
+  // Read all known fields from this ical incidence
+  void setFields( const KCalCore::Event::Ptr & );
+
+  KCalCore::Event::Transparency mShowTimeAs;
+  KDateTime mEndDate;
+  bool mHasEndDate;
+};
+
+}
+
+#endif // KOLAB_EVENT_H
diff --git a/src/kolabformatV2/incidence.cpp b/src/kolabformatV2/incidence.cpp
new file mode 100644
index 0000000..d77f6da
--- /dev/null
+++ b/src/kolabformatV2/incidence.cpp
@@ -0,0 +1,1010 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#include "incidence.h"
+#include "kolab_version.h"
+
+#include <QList>
+
+#include <kcalcore/journal.h>
+#include <kdebug.h>
+#include <kurl.h>
+
+#include <QBitArray>
+
+using namespace KolabV2;
+
+Incidence::Incidence( const QString& tz, const KCalCore::Incidence::Ptr &incidence )
+  : KolabBase( tz ), mFloatingStatus( Unset ), mHasAlarm( false ), mPriority( 0 )
+{
+  Q_UNUSED( incidence );
+}
+
+Incidence::~Incidence()
+{
+}
+
+void Incidence::setPriority( int priority )
+{
+  mPriority = priority;
+}
+
+int Incidence::priority() const
+{
+  return mPriority;
+}
+
+void Incidence::setSummary( const QString& summary )
+{
+  mSummary = summary;
+}
+
+QString Incidence::summary() const
+{
+  return mSummary;
+}
+
+void Incidence::setLocation( const QString& location )
+{
+  mLocation = location;
+}
+
+QString Incidence::location() const
+{
+  return mLocation;
+}
+
+void Incidence::setOrganizer( const Email& organizer )
+{
+  mOrganizer = organizer;
+}
+
+KolabBase::Email Incidence::organizer() const
+{
+  return mOrganizer;
+}
+
+void Incidence::setStartDate( const KDateTime& startDate )
+{
+  mStartDate = startDate;
+  if ( mFloatingStatus == AllDay )
+    kDebug() <<"ERROR: Time on start date but no time on the event";
+  mFloatingStatus = HasTime;
+}
+
+void Incidence::setStartDate( const QDate& startDate )
+{
+  mStartDate = KDateTime( startDate );
+  if ( mFloatingStatus == HasTime )
+    kDebug() <<"ERROR: No time on start date but time on the event";
+  mFloatingStatus = AllDay;
+}
+
+void Incidence::setStartDate( const QString& startDate )
+{
+  if ( startDate.length() > 10 )
+    // This is a date + time
+    setStartDate( stringToDateTime( startDate ) );
+  else
+    // This is only a date
+    setStartDate( stringToDate( startDate ) );
+}
+
+KDateTime Incidence::startDate() const
+{
+  return mStartDate;
+}
+
+void Incidence::setAlarm( float alarm )
+{
+  mAlarm = alarm;
+  mHasAlarm = true;
+}
+
+float Incidence::alarm() const
+{
+  return mAlarm;
+}
+
+Incidence::Recurrence Incidence::recurrence() const
+{
+  return mRecurrence;
+}
+
+void Incidence::addAttendee( const Attendee& attendee )
+{
+  mAttendees.append( attendee );
+}
+
+QList<Incidence::Attendee>& Incidence::attendees()
+{
+  return mAttendees;
+}
+
+const QList<Incidence::Attendee>& Incidence::attendees() const
+{
+  return mAttendees;
+}
+
+void Incidence::setInternalUID( const QString& iuid )
+{
+  mInternalUID = iuid;
+}
+
+QString Incidence::internalUID() const
+{
+  return mInternalUID;
+}
+
+bool Incidence::loadAttendeeAttribute( QDomElement& element,
+                                       Attendee& attendee )
+{
+  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      QString tagName = e.tagName();
+
+      if ( tagName == "display-name" )
+        attendee.displayName = e.text();
+      else if ( tagName == "smtp-address" )
+        attendee.smtpAddress = e.text();
+      else if ( tagName == "status" )
+        attendee.status = e.text();
+      else if ( tagName == "request-response" )
+        // This sets reqResp to false, if the text is "false". Otherwise it
+        // sets it to true. This means the default setting is true.
+        attendee.requestResponse = ( e.text().toLower() != "false" );
+      else if ( tagName == "invitation-sent" )
+        // Like above, only this defaults to false
+        attendee.invitationSent = ( e.text().toLower() != "true" );
+      else if ( tagName == "role" )
+        attendee.role = e.text();
+      else if ( tagName == "delegated-to" )
+        attendee.delegate = e.text();
+      else if ( tagName == "delegated-from" )
+        attendee.delegator = e.text();
+      else
+        // TODO: Unhandled tag - save for later storage
+        kDebug() <<"Warning: Unhandled tag" << e.tagName();
+    } else
+      kDebug() <<"Node is not a comment or an element???";
+  }
+
+  return true;
+}
+
+void Incidence::saveAttendeeAttribute( QDomElement& element,
+                                       const Attendee& attendee ) const
+{
+  QDomElement e = element.ownerDocument().createElement( "attendee" );
+  element.appendChild( e );
+  writeString( e, "display-name", attendee.displayName );
+  writeString( e, "smtp-address", attendee.smtpAddress );
+  writeString( e, "status", attendee.status );
+  writeString( e, "request-response",
+               ( attendee.requestResponse ? "true" : "false" ) );
+  writeString( e, "invitation-sent",
+               ( attendee.invitationSent ? "true" : "false" ) );
+  writeString( e, "role", attendee.role );
+  writeString( e, "delegated-to", attendee.delegate );
+  writeString( e, "delegated-from", attendee.delegator );
+}
+
+void Incidence::saveAttendees( QDomElement& element ) const
+{
+  foreach ( const Attendee& attendee, mAttendees )
+    saveAttendeeAttribute( element, attendee );
+}
+
+void Incidence::saveAttachments( QDomElement& element ) const
+{
+  foreach ( KCalCore::Attachment::Ptr a, mAttachments ) {
+    if ( a->isUri() ) {
+      writeString( element, "link-attachment", a->uri() );
+    } else if ( a->isBinary() ) {
+      writeString( element, "inline-attachment", a->label() );
+    }
+  }
+}
+
+void Incidence::saveAlarms( QDomElement& element ) const
+{
+  if ( mAlarms.isEmpty() ) return;
+
+  QDomElement list = element.ownerDocument().createElement( "advanced-alarms" );
+  element.appendChild( list );
+  foreach ( KCalCore::Alarm::Ptr a, mAlarms ) {
+    QDomElement e = list.ownerDocument().createElement( "alarm" );
+    list.appendChild( e );
+
+    writeString( e, "enabled", a->enabled() ? "1" : "0" );
+    if ( a->hasStartOffset() ) {
+      writeString( e, "start-offset", QString::number( a->startOffset().asSeconds()/60 ) );
+    }
+    if ( a->hasEndOffset() ) {
+      writeString( e, "end-offset", QString::number( a->endOffset().asSeconds()/60 ) );
+    }
+    if ( a->repeatCount() ) {
+      writeString( e, "repeat-count", QString::number( a->repeatCount() ) );
+      writeString( e, "repeat-interval", QString::number( a->snoozeTime().asSeconds() ) );
+    }
+
+    switch ( a->type() ) {
+    case KCalCore::Alarm::Invalid:
+      break;
+    case KCalCore::Alarm::Display:
+      e.setAttribute( "type", "display" );
+      writeString( e, "text", a->text() );
+      break;
+    case KCalCore::Alarm::Procedure:
+      e.setAttribute( "type", "procedure" );
+      writeString( e, "program", a->programFile() );
+      writeString( e, "arguments", a->programArguments() );
+      break;
+    case KCalCore::Alarm::Email:
+    {
+      e.setAttribute( "type", "email" );
+      QDomElement addresses = e.ownerDocument().createElement( "addresses" );
+      e.appendChild( addresses );
+      foreach ( const KCalCore::Person::Ptr &person, a->mailAddresses() ) {
+        writeString( addresses, "address", person->fullName() );
+      }
+      writeString( e, "subject", a->mailSubject() );
+      writeString( e, "mail-text", a->mailText() );
+      QDomElement attachments = e.ownerDocument().createElement( "attachments" );
+      e.appendChild( attachments );
+      foreach ( const QString &attachment, a->mailAttachments() ) {
+        writeString( attachments, "attachment", attachment );
+      }
+      break;
+    }
+    case KCalCore::Alarm::Audio:
+      e.setAttribute( "type", "audio" );
+      writeString( e, "file", a->audioFile() );
+      break;
+    default:
+      kWarning() << "Unhandled alarm type:" << a->type();
+      break;
+    }
+  }
+}
+
+void Incidence::saveRecurrence( QDomElement& element ) const
+{
+  QDomElement e = element.ownerDocument().createElement( "recurrence" );
+  element.appendChild( e );
+  e.setAttribute( "cycle", mRecurrence.cycle );
+  if ( !mRecurrence.type.isEmpty() )
+    e.setAttribute( "type", mRecurrence.type );
+  writeString( e, "interval", QString::number( mRecurrence.interval ) );
+  foreach ( const QString& recurrence, mRecurrence.days ) {
+    writeString( e, "day", recurrence );
+  }
+  if ( !mRecurrence.dayNumber.isEmpty() )
+    writeString( e, "daynumber", mRecurrence.dayNumber );
+  if ( !mRecurrence.month.isEmpty() )
+    writeString( e, "month", mRecurrence.month );
+  if ( !mRecurrence.rangeType.isEmpty() ) {
+    QDomElement range = element.ownerDocument().createElement( "range" );
+    e.appendChild( range );
+    range.setAttribute( "type", mRecurrence.rangeType );
+    QDomText t = element.ownerDocument().createTextNode( mRecurrence.range );
+    range.appendChild( t );
+  }
+  foreach ( const QDate& date, mRecurrence.exclusions ) {
+    writeString( e, "exclusion", dateToString( date ) );
+  }
+}
+
+void Incidence::loadRecurrence( const QDomElement& element )
+{
+  mRecurrence.interval = 0;
+  mRecurrence.cycle = element.attribute( "cycle" );
+  mRecurrence.type = element.attribute( "type" );
+  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      QString tagName = e.tagName();
+      if ( tagName == "interval" ) {
+        //kolab/issue4229, sometimes  the interval value can be empty
+        if ( e.text().isEmpty() || e.text().toInt() <= 0 ) {
+          mRecurrence.interval = 1;
+        } else {
+          mRecurrence.interval = e.text().toInt();
+        }
+      }
+      else if ( tagName == "day" ) // can be present multiple times
+        mRecurrence.days.append( e.text() );
+      else if ( tagName == "daynumber" )
+        mRecurrence.dayNumber = e.text();
+      else if ( tagName == "month" )
+        mRecurrence.month = e.text();
+      else if ( tagName == "range" ) {
+        mRecurrence.rangeType = e.attribute( "type" );
+        mRecurrence.range = e.text();
+      } else if ( tagName == "exclusion" ) {
+        mRecurrence.exclusions.append( stringToDate( e.text() ) );
+      } else
+        // TODO: Unhandled tag - save for later storage
+        kDebug() <<"Warning: Unhandled tag" << e.tagName();
+    }
+  }
+}
+
+static void loadAddressesHelper( const QDomElement& element, const KCalCore::Alarm::Ptr &a )
+{
+  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      QString tagName = e.tagName();
+
+      if ( tagName == "address" ) {
+        a->addMailAddress( KCalCore::Person::fromFullName( e.text() ) );
+      } else {
+        kWarning() << "Unhandled tag" << tagName;
+      }
+    }
+  }
+}
+
+static void loadAttachmentsHelper( const QDomElement& element, const KCalCore::Alarm::Ptr &a )
+{
+  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      QString tagName = e.tagName();
+
+      if ( tagName == "attachment" ) {
+        a->addMailAttachment( e.text() );
+      } else {
+        kWarning() << "Unhandled tag" << tagName;
+      }
+    }
+  }
+}
+
+static void loadAlarmHelper( const QDomElement& element, const KCalCore::Alarm::Ptr &a )
+{
+  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      QString tagName = e.tagName();
+
+      if ( tagName == "start-offset" ) {
+        a->setStartOffset( e.text().toInt()*60 );
+      } else if ( tagName == "end-offset" ) {
+        a->setEndOffset( e.text().toInt()*60 );
+      } else if ( tagName == "repeat-count" ) {
+        a->setRepeatCount( e.text().toInt() );
+      } else if ( tagName == "repeat-interval" ) {
+        a->setSnoozeTime( e.text().toInt() );
+      } else if ( tagName == "text" ) {
+        a->setText( e.text() );
+      } else if ( tagName == "program" ) {
+        a->setProgramFile( e.text() );
+      } else if ( tagName == "arguments" ) {
+        a->setProgramArguments( e.text() );
+      } else if ( tagName == "addresses" ) {
+        loadAddressesHelper( e, a );
+      } else if ( tagName == "subject" ) {
+        a->setMailSubject( e.text() );
+      } else if ( tagName == "mail-text" ) {
+        a->setMailText( e.text() );
+      } else if ( tagName == "attachments" ) {
+        loadAttachmentsHelper( e, a );
+      } else if ( tagName == "file" ) {
+        a->setAudioFile( e.text() );
+      } else if ( tagName == "enabled" ) {
+        a->setEnabled( e.text().toInt() != 0 );
+      } else {
+        kWarning() << "Unhandled tag" << tagName;
+      }
+    }
+  }
+}
+
+void Incidence::loadAlarms( const QDomElement& element )
+{
+  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      QString tagName = e.tagName();
+
+      if ( tagName == "alarm" ) {
+        KCalCore::Alarm::Ptr a = KCalCore::Alarm::Ptr( new KCalCore::Alarm( 0 ) );
+        a->setEnabled( true ); // default to enabled, unless some XML attribute says otherwise.
+        QString type = e.attribute( "type" );
+        if ( type == "display" ) {
+          a->setType( KCalCore::Alarm::Display );
+        } else if ( type == "procedure" ) {
+          a->setType( KCalCore::Alarm::Procedure );
+        } else if ( type == "email" ) {
+          a->setType( KCalCore::Alarm::Email );
+        } else if ( type == "audio" ) {
+          a->setType( KCalCore::Alarm::Audio );
+        } else {
+          kWarning() << "Unhandled alarm type:" << type;
+        }
+
+        loadAlarmHelper( e, a );
+        mAlarms << a;
+      } else {
+        kWarning() << "Unhandled tag" << tagName;
+      }
+    }
+  }
+}
+
+bool Incidence::loadAttribute( QDomElement& element )
+{
+  QString tagName = element.tagName();
+
+  if ( tagName == "priority" ) {
+    bool ok;
+    int p = element.text().toInt( &ok );
+    if ( !ok || p < 1 || p > 9 ) {
+      kWarning() << "Invalid \"priority\" value:" << element.text();
+    } else {
+      setPriority( p );
+    }
+  } else if ( tagName == "x-kcal-priority" ) { //for backwards compat
+    bool ok;
+    int p = element.text().toInt( &ok );
+    if ( !ok || p < 0 || p > 9 ) {
+      kWarning() << "Invalid \"x-kcal-priority\" value:" << element.text();
+    } else {
+      if ( priority() == 0 ) {
+        setPriority(p);
+      }
+    }
+  } else if ( tagName == "summary" )
+    setSummary( element.text() );
+  else if ( tagName == "location" )
+    setLocation( element.text() );
+  else if ( tagName == "organizer" ) {
+    Email email;
+    if ( loadEmailAttribute( element, email ) ) {
+      setOrganizer( email );
+      return true;
+    } else
+      return false;
+  } else if ( tagName == "start-date" )
+    setStartDate( element.text() );
+  else if ( tagName == "recurrence" )
+    loadRecurrence( element );
+  else if ( tagName == "attendee" ) {
+    Attendee attendee;
+    if ( loadAttendeeAttribute( element, attendee ) ) {
+      addAttendee( attendee );
+      return true;
+    } else
+      return false;
+  } else if ( tagName == "link-attachment" ) {
+    mAttachments.push_back( KCalCore::Attachment::Ptr( new KCalCore::Attachment( element.text() ) ) );
+  } else if ( tagName == "alarm" )
+    // Alarms should be minutes before. Libkcal uses event time + alarm time
+    setAlarm( - element.text().toInt() );
+  else if ( tagName == "advanced-alarms" )
+    loadAlarms( element );
+  else if ( tagName == "x-kde-internaluid" )
+    setInternalUID( element.text() );
+  else if ( tagName == "x-custom" ) {
+    loadCustomAttributes( element );
+  } else if ( tagName == "inline-attachment"  ) {
+    // we handle that separately later on, so no need to create a KolabUnhandled entry for it
+  } else {
+    bool ok = KolabBase::loadAttribute( element );
+    if ( !ok ) {
+        // Unhandled tag - save for later storage
+        kDebug() <<"Saving unhandled tag" << element.tagName();
+        Custom c;
+        c.key = QByteArray( "X-KDE-KolabUnhandled-" ) + element.tagName().toLatin1();
+        c.value = element.text();
+        mCustomList.append( c );
+    }
+  }
+  // We handled this
+  return true;
+}
+
+bool Incidence::saveAttributes( QDomElement& element ) const
+{
+  // Save the base class elements
+  KolabBase::saveAttributes( element );
+
+  if (priority() != 0) {
+    writeString( element, "priority", QString::number( priority() ) );
+  }
+
+  if ( mFloatingStatus == HasTime )
+    writeString( element, "start-date", dateTimeToString( startDate() ) );
+  else
+    writeString( element, "start-date", dateToString( startDate().date() ) );
+  writeString( element, "summary", summary() );
+  writeString( element, "location", location() );
+  saveEmailAttribute( element, organizer(), "organizer" );
+  if ( !mRecurrence.cycle.isEmpty() )
+    saveRecurrence( element );
+  saveAttendees( element );
+  saveAttachments( element );
+  if ( mHasAlarm ) {
+    // Alarms should be minutes before. Libkcal uses event time + alarm time
+    int alarmTime = qRound( -alarm() );
+    writeString( element, "alarm", QString::number( alarmTime ) );
+  }
+  saveAlarms( element );
+  writeString( element, "x-kde-internaluid", internalUID() );
+  saveCustomAttributes( element );
+  return true;
+}
+
+void Incidence::saveCustomAttributes( QDomElement& element ) const
+{
+  foreach ( const Custom& custom, mCustomList ) {
+    QString key( custom.key );
+    Q_ASSERT( !key.isEmpty() );
+    if ( key.startsWith( QLatin1String( "X-KDE-KolabUnhandled-" ) ) ) {
+      key = key.mid( strlen( "X-KDE-KolabUnhandled-" ) );
+      writeString( element, key, custom.value );
+    } else {
+      // Let's use attributes so that other tag-preserving-code doesn't need sub-elements
+      QDomElement e = element.ownerDocument().createElement( "x-custom" );
+      element.appendChild( e );
+      e.setAttribute( "key", key );
+      e.setAttribute( "value", custom.value );
+    }
+  }
+}
+
+void Incidence::loadCustomAttributes( QDomElement& element )
+{
+  Custom custom;
+  custom.key = element.attribute( "key" ).toLatin1();
+  custom.value = element.attribute( "value" );
+  mCustomList.append( custom );
+}
+
+static KCalCore::Attendee::PartStat attendeeStringToStatus( const QString& s )
+{
+  if ( s == "none" )
+    return KCalCore::Attendee::NeedsAction;
+  if ( s == "tentative" )
+    return KCalCore::Attendee::Tentative;
+  if ( s == "declined" )
+    return KCalCore::Attendee::Declined;
+  if ( s == "delegated" )
+    return KCalCore::Attendee::Delegated;
+
+  // Default:
+  return KCalCore::Attendee::Accepted;
+}
+
+static QString attendeeStatusToString( KCalCore::Attendee::PartStat status )
+{
+  switch( status ) {
+  case KCalCore::Attendee::NeedsAction:
+    return "none";
+  case KCalCore::Attendee::Accepted:
+    return "accepted";
+  case KCalCore::Attendee::Declined:
+    return "declined";
+  case KCalCore::Attendee::Tentative:
+    return "tentative";
+  case KCalCore::Attendee::Delegated:
+    return "delegated";
+  case KCalCore::Attendee::Completed:
+  case KCalCore::Attendee::InProcess:
+    // These don't have any meaning in the Kolab format, so just use:
+    return "accepted";
+  default:
+    // Default for the case that there are more added later:
+    return "accepted";
+  }
+}
+
+static KCalCore::Attendee::Role attendeeStringToRole( const QString& s )
+{
+  if ( s == "optional" )
+    return KCalCore::Attendee::OptParticipant;
+  if ( s == "resource" )
+    return KCalCore::Attendee::NonParticipant;
+  return KCalCore::Attendee::ReqParticipant;
+}
+
+static QString attendeeRoleToString( KCalCore::Attendee::Role role )
+{
+  switch( role ) {
+  case KCalCore::Attendee::ReqParticipant:
+    return "required";
+  case KCalCore::Attendee::OptParticipant:
+    return "optional";
+  case KCalCore::Attendee::Chair:
+    // We don't have the notion of chair, so use
+    return "required";
+  case KCalCore::Attendee::NonParticipant:
+    // In Kolab, a non-participant is a resource
+    return "resource";
+  }
+
+  // Default for the case that there are more added later:
+  return "required";
+}
+
+static const char *s_weekDayName[] =
+{
+  "monday", "tuesday", "wednesday", "thursday", "friday", "saturday", "sunday"
+};
+
+static const char *s_monthName[] =
+{
+  "january", "february", "march", "april", "may", "june", "july",
+  "august", "september", "october", "november", "december"
+};
+
+void Incidence::setRecurrence( KCalCore::Recurrence* recur )
+{
+  mRecurrence.interval = recur->frequency();
+  switch ( recur->recurrenceType() ) {
+  case KCalCore::Recurrence::rMinutely: // Not handled by the kolab XML
+    mRecurrence.cycle = "minutely";
+    break;
+  case KCalCore::Recurrence::rHourly:  // Not handled by the kolab XML
+    mRecurrence.cycle = "hourly";
+    break;
+  case KCalCore::Recurrence::rDaily:
+    mRecurrence.cycle = "daily";
+    break;
+  case KCalCore::Recurrence::rWeekly: // every X weeks
+    mRecurrence.cycle = "weekly";
+    {
+      QBitArray arr = recur->days();
+      for ( uint idx = 0 ; idx < 7 ; ++idx )
+        if ( arr.testBit( idx ) )
+          mRecurrence.days.append( s_weekDayName[idx] );
+    }
+    break;
+  case KCalCore::Recurrence::rMonthlyPos: {
+    mRecurrence.cycle = "monthly";
+    mRecurrence.type = "weekday";
+    QList<KCalCore::RecurrenceRule::WDayPos> monthPositions = recur->monthPositions();
+    if ( !monthPositions.isEmpty() ) {
+      KCalCore::RecurrenceRule::WDayPos monthPos = monthPositions.first();
+      // TODO: Handle multiple days in the same week
+      mRecurrence.dayNumber = QString::number( monthPos.pos() );
+      mRecurrence.days.append( s_weekDayName[ monthPos.day()-1 ] );
+        // Not (properly) handled(?): monthPos.negative (nth days before end of month)
+    }
+    break;
+  }
+  case KCalCore::Recurrence::rMonthlyDay: {
+    mRecurrence.cycle = "monthly";
+    mRecurrence.type = "daynumber";
+    QList<int> monthDays = recur->monthDays();
+    // ####### Kolab XML limitation: only the first month day is used
+    if ( !monthDays.isEmpty() )
+      mRecurrence.dayNumber = QString::number( monthDays.first() );
+    break;
+  }
+  case KCalCore::Recurrence::rYearlyMonth: // (day n of Month Y)
+  {
+    mRecurrence.cycle = "yearly";
+    mRecurrence.type = "monthday";
+    QList<int> rmd = recur->yearDates();
+    int day = !rmd.isEmpty() ? rmd.first() : recur->startDate().day();
+    mRecurrence.dayNumber = QString::number( day );
+    QList<int> months = recur->yearMonths();
+    if ( !months.isEmpty() )
+      mRecurrence.month = s_monthName[ months.first() - 1 ]; // #### Kolab XML limitation: only one month specified
+    break;
+  }
+  case KCalCore::Recurrence::rYearlyDay: // YearlyDay (day N of the year). Not supported by Outlook
+    mRecurrence.cycle = "yearly";
+    mRecurrence.type = "yearday";
+    mRecurrence.dayNumber = QString::number( recur->yearDays().first() );
+    break;
+  case KCalCore::Recurrence::rYearlyPos: // (weekday X of week N of month Y)
+    mRecurrence.cycle = "yearly";
+    mRecurrence.type = "weekday";
+    QList<int> months = recur->yearMonths();
+    if ( !months.isEmpty() )
+      mRecurrence.month = s_monthName[ months.first() - 1 ]; // #### Kolab XML limitation: only one month specified
+    QList<KCalCore::RecurrenceRule::WDayPos> monthPositions = recur->yearPositions();
+    if ( !monthPositions.isEmpty() ) {
+      KCalCore::RecurrenceRule::WDayPos monthPos = monthPositions.first();
+      // TODO: Handle multiple days in the same week
+      mRecurrence.dayNumber = QString::number( monthPos.pos() );
+      mRecurrence.days.append( s_weekDayName[ monthPos.day()-1 ] );
+
+      //mRecurrence.dayNumber = QString::number( *recur->yearNums().getFirst() );
+      // Not handled: monthPos.negative (nth days before end of month)
+    }
+    break;
+  }
+  int howMany = recur->duration();
+  if ( howMany > 0 ) {
+    mRecurrence.rangeType = "number";
+    mRecurrence.range = QString::number( howMany );
+  } else if ( howMany == 0 ) {
+    mRecurrence.rangeType = "date";
+    mRecurrence.range = dateToString( recur->endDate() );
+  } else {
+    mRecurrence.rangeType = "none";
+  }
+}
+
+void Incidence::setFields( const KCalCore::Incidence::Ptr &incidence )
+{
+  KolabBase::setFields( incidence );
+
+  setPriority( incidence->priority() );
+  if ( incidence->allDay() ) {
+    // This is a all-day event. Don't timezone move this one
+    mFloatingStatus = AllDay;
+    setStartDate( incidence->dtStart().date() );
+  } else {
+    mFloatingStatus = HasTime;
+    setStartDate( localToUTC( incidence->dtStart() ) );
+  }
+
+  setSummary( incidence->summary() );
+  setLocation( incidence->location() );
+
+  // Alarm
+  mHasAlarm = false; // Will be set to true, if we actually have one
+  if ( incidence->hasEnabledAlarms() ) {
+    const KCalCore::Alarm::List& alarms = incidence->alarms();
+    if ( !alarms.isEmpty() ) {
+      const KCalCore::Alarm::Ptr alarm = alarms.first();
+      if ( alarm->hasStartOffset() ) {
+        int dur = alarm->startOffset().asSeconds();
+        setAlarm( (float)dur / 60.0 );
+      }
+    }
+  }
+
+  if (incidence->organizer()) {
+    Email org( incidence->organizer()->name(), incidence->organizer()->email() );
+    setOrganizer( org );
+  }
+
+  // Attendees:
+  KCalCore::Attendee::List attendees = incidence->attendees();
+  foreach ( KCalCore::Attendee::Ptr kcalAttendee, attendees ) {
+    Attendee attendee;
+
+    attendee.displayName = kcalAttendee->name();
+    attendee.smtpAddress = kcalAttendee->email();
+    attendee.status = attendeeStatusToString( kcalAttendee->status() );
+    attendee.requestResponse = kcalAttendee->RSVP();
+    // TODO: KCalCore::Attendee::mFlag is not accessible
+    // attendee.invitationSent = kcalAttendee->mFlag;
+    // DF: Hmm? mFlag is set to true and never used at all.... Did you mean another field?
+    attendee.role = attendeeRoleToString( kcalAttendee->role() );
+    attendee.delegate = kcalAttendee->delegate();
+    attendee.delegator = kcalAttendee->delegator();
+
+    addAttendee( attendee );
+  }
+
+  mAttachments.clear();
+
+  // Attachments
+  KCalCore::Attachment::List attachments = incidence->attachments();
+  foreach ( KCalCore::Attachment::Ptr a, attachments ) {
+    mAttachments.push_back( a );
+  }
+
+  mAlarms.clear();
+
+  // Alarms
+  KCalCore::Alarm::List alarms = incidence->alarms();
+  foreach ( KCalCore::Alarm::Ptr a, alarms ) {
+    mAlarms.push_back( a );
+  }
+
+  if ( incidence->recurs() ) {
+    setRecurrence( incidence->recurrence() );
+    mRecurrence.exclusions = incidence->recurrence()->exDates();
+  }
+
+  // Handle the scheduling ID
+  if ( incidence->schedulingID() == incidence->uid() ) {
+    // There is no scheduling ID
+    setInternalUID( QString::null );	//krazy:exclude=nullstrassign for old broken gcc
+  } else {
+    // We've internally been using a different uid, so save that as the
+    // temporary (internal) uid and restore the original uid, the one that
+    // is used in the folder and the outside world
+    setUid( incidence->schedulingID() );
+    setInternalUID( incidence->uid() );
+  }
+
+  // Unhandled tags and other custom properties (see libkcal/customproperties.h)
+  const QMap<QByteArray, QString> map = incidence->customProperties();
+  QMap<QByteArray, QString>::ConstIterator cit = map.begin();
+  for ( ; cit != map.end() ; ++cit ) {
+    Custom c;
+    c.key = cit.key();
+    c.value = cit.value();
+    mCustomList.append( c );
+  }
+}
+
+static QBitArray daysListToBitArray( const QStringList& days )
+{
+  QBitArray arr( 7 );
+  arr.fill( false );
+  foreach ( const QString& day, days ) {
+    for ( uint i = 0; i < 7 ; ++i )
+      if ( day == s_weekDayName[i] )
+        arr.setBit( i, true );
+  }
+  return arr;
+}
+
+
+void Incidence::saveTo( const KCalCore::Incidence::Ptr &incidence )
+{
+  KolabBase::saveTo( incidence );
+
+  incidence->setPriority( priority() );
+  if ( mFloatingStatus == AllDay ) {
+    // This is an all-day event. Don't timezone move this one
+    incidence->setDtStart( startDate() );
+    incidence->setAllDay( true );
+  } else {
+    incidence->setDtStart( utcToLocal( startDate() ) );
+    incidence->setAllDay( false );
+  }
+
+  incidence->setSummary( summary() );
+  incidence->setLocation( location() );
+
+  if ( mHasAlarm && mAlarms.isEmpty() ) {
+    KCalCore::Alarm::Ptr alarm = incidence->newAlarm();
+    alarm->setStartOffset( qRound( mAlarm * 60.0 ) );
+    alarm->setEnabled( true );
+    alarm->setType( KCalCore::Alarm::Display );
+  } else if ( !mAlarms.isEmpty() ) {
+    foreach ( KCalCore::Alarm::Ptr a, mAlarms ) {
+      a->setParent( incidence.data() );
+      incidence->addAlarm( a );
+    }
+  }
+
+  if ( organizer().displayName.isEmpty() )
+    incidence->setOrganizer( organizer().smtpAddress );
+  else
+    incidence->setOrganizer( organizer().displayName + '<'
+                             + organizer().smtpAddress + '>' );
+
+  incidence->clearAttendees();
+  foreach ( const Attendee& attendee, mAttendees ) {
+    KCalCore::Attendee::PartStat status = attendeeStringToStatus( attendee.status );
+    KCalCore::Attendee::Role role = attendeeStringToRole( attendee.role );
+    KCalCore::Attendee::Ptr a( new KCalCore::Attendee( attendee.displayName,
+                                            attendee.smtpAddress,
+                                            attendee.requestResponse,
+                                            status, role ) );
+    a->setDelegate( attendee.delegate );
+    a->setDelegator( attendee.delegator );
+    incidence->addAttendee( a );
+  }
+
+  incidence->clearAttachments();
+  foreach ( KCalCore::Attachment::Ptr a, mAttachments ) {
+    // TODO should we copy?
+    incidence->addAttachment( a );
+  }
+
+  if ( !mRecurrence.cycle.isEmpty() ) {
+    KCalCore::Recurrence* recur = incidence->recurrence(); // yeah, this creates it
+    // done below recur->setFrequency( mRecurrence.interval );
+    if ( mRecurrence.cycle == "minutely" ) {
+      recur->setMinutely( mRecurrence.interval );
+    } else if ( mRecurrence.cycle == "hourly" ) {
+      recur->setHourly( mRecurrence.interval );
+    } else if ( mRecurrence.cycle == "daily" ) {
+      recur->setDaily( mRecurrence.interval );
+    } else if ( mRecurrence.cycle == "weekly" ) {
+      QBitArray rDays = daysListToBitArray( mRecurrence.days );
+      recur->setWeekly( mRecurrence.interval, rDays );
+    } else if ( mRecurrence.cycle == "monthly" ) {
+      recur->setMonthly( mRecurrence.interval );
+      if ( mRecurrence.type == "weekday" ) {
+        recur->addMonthlyPos( mRecurrence.dayNumber.toInt(), daysListToBitArray( mRecurrence.days ) );
+      } else if ( mRecurrence.type == "daynumber" ) {
+        recur->addMonthlyDate( mRecurrence.dayNumber.toInt() );
+      } else kWarning() <<"Unhandled monthly recurrence type" << mRecurrence.type;
+    } else if ( mRecurrence.cycle == "yearly" ) {
+      recur->setYearly( mRecurrence.interval );
+      if ( mRecurrence.type == "monthday" ) {
+        recur->addYearlyDate( mRecurrence.dayNumber.toInt() );
+				for ( int i = 0; i < 12; ++i )
+          if ( s_monthName[ i ] == mRecurrence.month )
+            recur->addYearlyMonth( i+1 );
+      } else if ( mRecurrence.type == "yearday" ) {
+        recur->addYearlyDay( mRecurrence.dayNumber.toInt() );
+      } else if ( mRecurrence.type == "weekday" ) {
+			  for ( int i = 0; i < 12; ++i )
+          if ( s_monthName[ i ] == mRecurrence.month )
+            recur->addYearlyMonth( i+1 );
+        recur->addYearlyPos( mRecurrence.dayNumber.toInt(), daysListToBitArray( mRecurrence.days ) );
+      } else kWarning() <<"Unhandled yearly recurrence type" << mRecurrence.type;
+    } else kWarning() <<"Unhandled recurrence cycle" << mRecurrence.cycle;
+
+    if ( mRecurrence.rangeType == "number" ) {
+      recur->setDuration( mRecurrence.range.toInt() );
+    } else if ( mRecurrence.rangeType == "date" ) {
+      recur->setEndDate( stringToDate( mRecurrence.range ) );
+    } // "none" is default since tje set*ly methods set infinite recurrence
+
+    incidence->recurrence()->setExDates( mRecurrence.exclusions );
+
+  }
+  /* If we've stored a uid to be used internally instead of the real one
+   * (to deal with duplicates of events in different folders) before, then
+   * restore it, so it does not change. Keep the original uid around for
+   * scheduling purposes. */
+  if ( !internalUID().isEmpty() ) {
+    incidence->setUid( internalUID() );
+    incidence->setSchedulingID( uid() );
+  }
+
+  foreach ( const Custom& custom, mCustomList ) {
+    incidence->setNonKDECustomProperty( custom.key, custom.value );
+  }
+
+}
+
+QString Incidence::productID() const
+{
+  return QString( "%1, Kolab resource" ).arg( KOLAB_VERSION_STRING );
+}
+
+// Unhandled KCalCore::Incidence fields:
+// revision, status (unused), attendee.uid,
+// mComments, mReadOnly
+
diff --git a/src/kolabformatV2/incidence.h b/src/kolabformatV2/incidence.h
new file mode 100644
index 0000000..b918bd0
--- /dev/null
+++ b/src/kolabformatV2/incidence.h
@@ -0,0 +1,172 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#ifndef KOLABV2_INCIDENCE_H
+#define KOLABV2_INCIDENCE_H
+
+#include <kcalcore/incidence.h>
+
+#include "kolabbase.h"
+
+class QDomElement;
+
+namespace KolabV2 {
+
+/**
+ * This abstract class represents an incidence which has the shared
+ * fields, of events and tasks and knows how to load/save these
+ * from/to XML, and from/to a KCalCore::Incidence.
+ */
+class Incidence : public KolabBase {
+public:
+  struct Recurrence {
+    QString cycle;
+    QString type;
+    int interval;
+    QStringList days; // list of days-of-the-week
+    QString dayNumber;
+    QString month;
+    QString rangeType;
+    QString range; // date or number or nothing
+    QList<QDate> exclusions;
+  };
+
+  struct Attendee : Email {
+    Attendee() : requestResponse( true ), invitationSent( false ) {}
+    QString status;
+    bool requestResponse;
+    bool invitationSent;
+    QString role;
+    QString delegate;
+    QString delegator;
+  };
+
+  explicit Incidence( const QString& tz, const KCalCore::Incidence::Ptr &incidence = KCalCore::Incidence::Ptr() );
+
+public:
+  virtual ~Incidence();
+
+  void saveTo( const KCalCore::Incidence::Ptr &incidence );
+
+  virtual void setPriority( int priority );
+  virtual int priority() const;
+
+  virtual void setSummary( const QString& summary );
+  virtual QString summary() const;
+
+  virtual void setLocation( const QString& location );
+  virtual QString location() const;
+
+  virtual void setOrganizer( const Email& organizer );
+  virtual Email organizer() const;
+
+  virtual void setStartDate( const KDateTime& startDate );
+  virtual void setStartDate( const QDate& startDate );
+  virtual void setStartDate( const QString& startDate );
+  virtual KDateTime startDate() const;
+
+  virtual void setAlarm( float alarm );
+  virtual float alarm() const;
+
+  virtual void setRecurrence( KCalCore::Recurrence* recur );
+  virtual Recurrence recurrence() const;
+
+  virtual void addAttendee( const Attendee& attendee );
+  QList<Attendee>& attendees();
+  const QList<Attendee>& attendees() const;
+
+   virtual QString type() const { return "Incidence"; }
+ /**
+   * The internal uid is used as the uid inside KOrganizer whenever
+   * two or more events with the same uid appear, which KOrganizer
+   * can't handle. To avoid keep that interal uid from changing all the
+   * time, it is persisted in the XML between a save and the next load.
+   */
+  void setInternalUID( const QString& iuid );
+  QString internalUID() const;
+
+  // Load the attributes of this class
+  virtual bool loadAttribute( QDomElement& );
+
+  // Save the attributes of this class
+  virtual bool saveAttributes( QDomElement& ) const;
+
+protected:
+  enum FloatingStatus { Unset, AllDay, HasTime };
+
+  // Read all known fields from this ical incidence
+  void setFields( const KCalCore::Incidence::Ptr & );
+
+  bool loadAttendeeAttribute( QDomElement&, Attendee& );
+  void saveAttendeeAttribute( QDomElement& element,
+                              const Attendee& attendee ) const;
+  void saveAttendees( QDomElement& element ) const;
+  void saveAttachments( QDomElement& element ) const;
+
+  void loadAlarms( const QDomElement& element );
+  void saveAlarms( QDomElement& element ) const;
+
+  void loadRecurrence( const QDomElement& element );
+  void saveRecurrence( QDomElement& element ) const;
+  void saveCustomAttributes( QDomElement& element ) const;
+  void loadCustomAttributes( QDomElement& element );
+
+  QString productID() const;
+
+  QString mSummary;
+  QString mLocation;
+  Email mOrganizer;
+  KDateTime mStartDate;
+  FloatingStatus mFloatingStatus;
+  float mAlarm;
+  bool mHasAlarm;
+  Recurrence mRecurrence;
+  QList<Attendee> mAttendees;
+  QList<KCalCore::Alarm::Ptr> mAlarms;
+  QList<KCalCore::Attachment::Ptr> mAttachments;
+  QString mInternalUID;
+
+  struct Custom {
+    QByteArray key;
+    QString value;
+  };
+  QList<Custom> mCustomList;
+
+  // This is the KCal priority, not the Kolab priority.
+  // See kcalPriorityToKolab() and kolabPrioritytoKCal().
+  int mPriority;
+};
+
+}
+
+#endif // KOLAB_INCIDENCE_H
diff --git a/src/kolabformatV2/journal.cpp b/src/kolabformatV2/journal.cpp
new file mode 100644
index 0000000..15abadd
--- /dev/null
+++ b/src/kolabformatV2/journal.cpp
@@ -0,0 +1,184 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#include "journal.h"
+#include "kolab_version.h"
+
+#include <kdebug.h>
+
+using namespace KolabV2;
+
+
+KCalCore::Journal::Ptr Journal::fromXml( const QDomDocument& xmlDoc, const QString& tz )
+{
+  Journal journal( tz );
+  journal.loadXML( xmlDoc );
+  KCalCore::Journal::Ptr kcalJournal( new KCalCore::Journal() );
+  journal.saveTo( kcalJournal );
+  return kcalJournal;
+}
+
+QString Journal::journalToXML( const KCalCore::Journal::Ptr &kcalJournal, const QString& tz )
+{
+  Journal journal( tz, kcalJournal );
+  return journal.saveXML();
+}
+
+Journal::Journal( const QString& tz, const KCalCore::Journal::Ptr &journal )
+  : KolabBase( tz )
+{
+  if ( journal ) {
+    setFields( journal );
+  }
+}
+
+Journal::~Journal()
+{
+}
+
+void Journal::setSummary( const QString& summary )
+{
+  mSummary = summary;
+}
+
+QString Journal::summary() const
+{
+  return mSummary;
+}
+
+void Journal::setStartDate( const KDateTime& startDate )
+{
+  mStartDate = startDate;
+}
+
+KDateTime Journal::startDate() const
+{
+  return mStartDate;
+}
+
+void Journal::setEndDate( const KDateTime& endDate )
+{
+  mEndDate = endDate;
+}
+
+KDateTime Journal::endDate() const
+{
+  return mEndDate;
+}
+
+bool Journal::loadAttribute( QDomElement& element )
+{
+  QString tagName = element.tagName();
+
+  if ( tagName == "summary" )
+    setSummary( element.text() );
+  else if ( tagName == "start-date" )
+    setStartDate( stringToDateTime( element.text() ) );
+  else
+    // Not handled here
+    return KolabBase::loadAttribute( element );
+
+  // We handled this
+  return true;
+}
+
+bool Journal::saveAttributes( QDomElement& element ) const
+{
+  // Save the base class elements
+  KolabBase::saveAttributes( element );
+
+  writeString( element, "summary", summary() );
+  writeString( element, "start-date", dateTimeToString( startDate() ) );
+
+  return true;
+}
+
+
+bool Journal::loadXML( const QDomDocument& document )
+{
+  QDomElement top = document.documentElement();
+
+  if ( top.tagName() != "journal" ) {
+    qWarning( "XML error: Top tag was %s instead of the expected Journal",
+              top.tagName().toAscii().data() );
+    return false;
+  }
+
+  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      if ( !loadAttribute( e ) ) {
+        // Unhandled tag - save for later storage
+        //qDebug( "Unhandled tag: %s", e.toCString().data() );
+      }
+    } else
+      qDebug( "Node is not a comment or an element???" );
+  }
+
+  return true;
+}
+
+QString Journal::saveXML() const
+{
+  QDomDocument document = domTree();
+  QDomElement element = document.createElement( "journal" );
+  element.setAttribute( "version", "1.0" );
+  saveAttributes( element );
+  document.appendChild( element );
+  return document.toString();
+}
+
+void Journal::saveTo( const KCalCore::Journal::Ptr &journal )
+{
+  KolabBase::saveTo( journal );
+
+  journal->setSummary( summary() );
+  journal->setDtStart( utcToLocal( startDate() ) );
+}
+
+void Journal::setFields( const KCalCore::Journal::Ptr &journal )
+{
+  // Set baseclass fields
+  KolabBase::setFields( journal );
+
+  // Set our own fields
+  setSummary( journal->summary() );
+  setStartDate( localToUTC( journal->dtStart() ) );
+}
+
+QString Journal::productID() const
+{
+  return QString::fromLatin1(KOLAB_VERSION_STRING) + ", Kolab resource";
+}
diff --git a/src/kolabformatV2/journal.h b/src/kolabformatV2/journal.h
new file mode 100644
index 0000000..670c67a
--- /dev/null
+++ b/src/kolabformatV2/journal.h
@@ -0,0 +1,101 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#ifndef KOLABV2_JOURNAL_H
+#define KOLABV2_JOURNAL_H
+
+#include <kcalcore/journal.h>
+
+#include "kolabbase.h"
+
+class QDomElement;
+
+namespace KolabV2 {
+
+/**
+ * This class represents a journal entry, and knows how to load/save it
+ * from/to XML, and from/to a KCalCore::Journal.
+ * The instances of this class are temporary, only used to convert
+ * one to the other.
+ */
+class Journal : public KolabBase {
+public:
+  /// Use this to parse an xml string to a journal entry
+  /// The caller is responsible for deleting the returned journal
+  static KCalCore::Journal::Ptr fromXml( const QDomDocument& xmlDoc, const QString& tz );
+
+  /// Use this to get an xml string describing this journal entry
+  static QString journalToXML( const KCalCore::Journal::Ptr &, const QString& tz );
+
+  explicit Journal( const QString& tz, const KCalCore::Journal::Ptr &journal = KCalCore::Journal::Ptr() );
+  virtual ~Journal();
+
+  virtual QString type() const { return "Journal"; }
+
+  void saveTo( const KCalCore::Journal::Ptr &journal );
+
+  virtual void setSummary( const QString& summary );
+  virtual QString summary() const;
+
+  virtual void setStartDate( const KDateTime& startDate );
+  virtual KDateTime startDate() const;
+
+  virtual void setEndDate( const KDateTime& endDate );
+  virtual KDateTime endDate() const;
+
+  // Load the attributes of this class
+  virtual bool loadAttribute( QDomElement& );
+
+  // Save the attributes of this class
+  virtual bool saveAttributes( QDomElement& ) const;
+
+  // Load this journal by reading the XML file
+  virtual bool loadXML( const QDomDocument& xml );
+
+  // Serialize this journal to an XML string
+  virtual QString saveXML() const;
+
+protected:
+  // Read all known fields from this ical journal
+  void setFields( const KCalCore::Journal::Ptr & );
+
+  QString productID() const;
+
+  QString mSummary;
+  KDateTime mStartDate;
+  KDateTime mEndDate;
+};
+
+}
+
+#endif // KOLAB_JOURNAL_H
diff --git a/src/kolabformatV2/kolabbase.cpp b/src/kolabformatV2/kolabbase.cpp
new file mode 100644
index 0000000..a51d254
--- /dev/null
+++ b/src/kolabformatV2/kolabbase.cpp
@@ -0,0 +1,500 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#include "kolabbase.h"
+
+#include <kabc/addressee.h>
+#include <kabc/contactgroup.h>
+#include <kcalcore/incidence.h>
+#include <kcalcore/journal.h>
+#include <ksystemtimezone.h>
+#include <kdebug.h>
+
+using namespace KolabV2;
+
+KolabBase::KolabBase( const QString& tz )
+  : mCreationDate( QDateTime::currentDateTime() ),
+    mLastModified( KDateTime::currentUtcDateTime() ),
+    mSensitivity( Public ),
+    mTimeZone( KSystemTimeZones::zone( tz ) ),
+    mHasPilotSyncId( false ),  mHasPilotSyncStatus( false )
+{
+}
+
+KolabBase::~KolabBase()
+{
+}
+
+void KolabBase::setFields( const KCalCore::Incidence::Ptr &incidence )
+{
+  // So far unhandled KCalCore::IncidenceBase fields:
+  // mPilotID, mSyncStatus, mFloats
+
+  setUid( incidence->uid() );
+  setBody( incidence->description() );
+  setCategories( incidence->categoriesStr() );
+  setCreationDate( localToUTC( incidence->created() ) );
+  setLastModified( incidence->lastModified() );
+  setSensitivity( static_cast<Sensitivity>( incidence->secrecy() ) );
+  // TODO: Attachments
+}
+
+void KolabBase::saveTo( const KCalCore::Incidence::Ptr &incidence ) const
+{
+  incidence->setUid( uid() );
+  incidence->setDescription( body() );
+  incidence->setCategories( categories() );
+  incidence->setCreated( utcToLocal( creationDate() ) );
+  incidence->setLastModified( lastModified() );
+  switch( sensitivity() ) {
+  case 1:
+    incidence->setSecrecy( KCalCore::Incidence::SecrecyPrivate );
+    break;
+  case 2:
+    incidence->setSecrecy( KCalCore::Incidence::SecrecyConfidential );
+    break;
+  default:
+    incidence->setSecrecy( KCalCore::Incidence::SecrecyPublic );
+    break;
+  }
+
+  // TODO: Attachments
+}
+
+void KolabBase::setFields( const KABC::Addressee* addressee )
+{
+  // An addressee does not have a creation date, so somehow we should
+  // make one, if this is a new entry
+
+  setUid( addressee->uid() );
+  setBody( addressee->note() );
+  setCategories( addressee->categories().join( "," ) );
+
+  // Set creation-time and last-modification-time
+  const QString creationString = addressee->custom( "KOLAB", "CreationDate" );
+  kDebug() <<"Creation time string:" << creationString;
+  KDateTime creationDate;
+  if ( creationString.isEmpty() ) {
+    creationDate = KDateTime::currentDateTime(KDateTime::Spec( mTimeZone ) );
+    kDebug() <<"Creation date set to current time";
+  }
+  else {
+    creationDate = stringToDateTime( creationString );
+    kDebug() <<"Creation date loaded";
+  }
+  KDateTime modified = KDateTime( addressee->revision(), mTimeZone );
+  if ( !modified.isValid() )
+    modified = KDateTime::currentUtcDateTime();
+  setLastModified( modified );
+  if ( modified < creationDate ) {
+    // It's not possible that the modification date is earlier than creation
+    creationDate = modified;
+    kDebug() <<"Creation date set to modification date";
+  }
+  setCreationDate( creationDate );
+  const QString newCreationDate = dateTimeToString( creationDate );
+  if ( creationString != newCreationDate ) {
+    // We modified the creation date, so store it for future reference
+    const_cast<KABC::Addressee*>( addressee )
+      ->insertCustom( "KOLAB", "CreationDate", newCreationDate );
+    kDebug() <<"Creation date modified. New one:" << newCreationDate;
+  }
+
+  switch( addressee->secrecy().type() ) {
+  case KABC::Secrecy::Private:
+    setSensitivity( Private );
+    break;
+  case KABC::Secrecy::Confidential:
+    setSensitivity( Confidential );
+    break;
+  default:
+    setSensitivity( Public );
+  }
+
+  // TODO: Attachments
+}
+
+void KolabBase::saveTo( KABC::Addressee* addressee ) const
+{
+  addressee->setUid( uid() );
+  addressee->setNote( body() );
+  addressee->setCategories( categories().split( ',', QString::SkipEmptyParts ) );
+  addressee->setRevision( lastModified().toZone( mTimeZone ).dateTime() );
+  addressee->insertCustom( "KOLAB", "CreationDate",
+                           dateTimeToString( creationDate() ) );
+
+  switch( sensitivity() ) {
+  case Private:
+    addressee->setSecrecy( KABC::Secrecy( KABC::Secrecy::Private ) );
+    break;
+  case Confidential:
+    addressee->setSecrecy( KABC::Secrecy( KABC::Secrecy::Confidential ) );
+    break;
+  default:
+    addressee->setSecrecy( KABC::Secrecy( KABC::Secrecy::Public ) );
+    break;
+  }
+  // TODO: Attachments
+}
+
+void KolabBase::setFields( const KABC::ContactGroup* contactGroup )
+{
+  // A contactgroup does not have a creation date, so somehow we should
+  // make one, if this is a new entry
+
+  setUid( contactGroup->id() );
+
+  // Set creation-time and last-modification-time
+  KDateTime creationDate = KDateTime::currentDateTime( KDateTime::Spec( mTimeZone ) );
+  kDebug() <<"Creation date set to current time";
+
+  KDateTime modified = KDateTime::currentUtcDateTime();
+  setLastModified( modified );
+  if ( modified < creationDate ) {
+    // It's not possible that the modification date is earlier than creation
+    creationDate = modified;
+    kDebug() <<"Creation date set to modification date";
+  }
+  setCreationDate( creationDate );
+}
+
+void KolabBase::saveTo( KABC::ContactGroup* contactGroup ) const
+{
+  contactGroup->setId( uid() );
+}
+
+void KolabBase::setUid( const QString& uid )
+{
+  mUid = uid;
+}
+
+QString KolabBase::uid() const
+{
+  return mUid;
+}
+
+void KolabBase::setBody( const QString& body )
+{
+  mBody = body;
+}
+
+QString KolabBase::body() const
+{
+  return mBody;
+}
+
+void KolabBase::setCategories( const QString& categories )
+{
+  mCategories = categories;
+}
+
+QString KolabBase::categories() const
+{
+  return mCategories;
+}
+
+void KolabBase::setCreationDate( const KDateTime& date )
+{
+  mCreationDate = date;
+}
+
+KDateTime KolabBase::creationDate() const
+{
+  return mCreationDate;
+}
+
+void KolabBase::setLastModified( const KDateTime& date )
+{
+  mLastModified = date;
+}
+
+KDateTime KolabBase::lastModified() const
+{
+  return mLastModified;
+}
+
+void KolabBase::setSensitivity( Sensitivity sensitivity )
+{
+  mSensitivity = sensitivity;
+}
+
+KolabBase::Sensitivity KolabBase::sensitivity() const
+{
+  return mSensitivity;
+}
+
+void KolabBase::setPilotSyncId( unsigned long id )
+{
+  mHasPilotSyncId = true;
+  mPilotSyncId = id;
+}
+
+bool KolabBase::hasPilotSyncId() const
+{
+  return mHasPilotSyncId;
+}
+
+unsigned long KolabBase::pilotSyncId() const
+{
+  return mPilotSyncId;
+}
+
+void KolabBase::setPilotSyncStatus( int status )
+{
+  mHasPilotSyncStatus = true;
+  mPilotSyncStatus = status;
+}
+
+bool KolabBase::hasPilotSyncStatus() const
+{
+  return mHasPilotSyncStatus;
+}
+
+int KolabBase::pilotSyncStatus() const
+{
+  return mPilotSyncStatus;
+}
+
+bool KolabBase::loadEmailAttribute( QDomElement& element, Email& email )
+{
+  for ( QDomNode n = element.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      const QString tagName = e.tagName();
+
+      if ( tagName == "display-name" )
+        email.displayName = e.text();
+      else if ( tagName == "smtp-address" )
+        email.smtpAddress = e.text();
+      else
+        // TODO: Unhandled tag - save for later storage
+        kDebug() <<"Warning: Unhandled tag" << e.tagName();
+    } else
+      kDebug() <<"Node is not a comment or an element???";
+  }
+
+  return true;
+}
+
+void KolabBase::saveEmailAttribute( QDomElement& element, const Email& email,
+                                    const QString& tagName ) const
+{
+  QDomElement e = element.ownerDocument().createElement( tagName );
+  element.appendChild( e );
+  writeString( e, "display-name", email.displayName );
+  writeString( e, "smtp-address", email.smtpAddress );
+}
+
+bool KolabBase::loadAttribute( QDomElement& element )
+{
+  const QString tagName = element.tagName();
+  switch ( tagName[0].toLatin1() ) {
+  case 'u':
+    if ( tagName == "uid" ) {
+      setUid( element.text() );
+      return true;
+    }
+    break;
+  case 'b':
+    if ( tagName == "body" ) {
+      setBody( element.text() );
+      return true;
+    }
+    break;
+  case 'c':
+    if ( tagName == "categories" ) {
+      setCategories( element.text() );
+      return true;
+    }
+    if ( tagName == "creation-date" ) {
+      setCreationDate( stringToDateTime( element.text() ) );
+      return true;
+    }
+    break;
+  case 'l':
+    if ( tagName == "last-modification-date" ) {
+      setLastModified( stringToDateTime( element.text() ) );
+      return true;
+    }
+    break;
+  case 's':
+    if ( tagName == "sensitivity" ) {
+      setSensitivity( stringToSensitivity( element.text() ) );
+      return true;
+    }
+    break;
+  case 'p':
+    if ( tagName == "product-id" )
+      return true; // ignore this field
+    if ( tagName == "pilot-sync-id" ) {
+      setPilotSyncId( element.text().toULong() );
+      return true;
+    }
+    if ( tagName == "pilot-sync-status" ) {
+      setPilotSyncStatus( element.text().toInt() );
+      return true;
+    }
+    break;
+  default:
+    break;
+  }
+  return false;
+}
+
+bool KolabBase::saveAttributes( QDomElement& element ) const
+{
+  writeString( element, "product-id", productID() );
+  writeString( element, "uid", uid() );
+  writeString( element, "body", body() );
+  writeString( element, "categories", categories() );
+  writeString( element, "creation-date", dateTimeToString( creationDate().toUtc() ) );
+  writeString( element, "last-modification-date", dateTimeToString( lastModified().toUtc() ) );
+  writeString( element, "sensitivity", sensitivityToString( sensitivity() ) );
+  if ( hasPilotSyncId() )
+    writeString( element, "pilot-sync-id", QString::number( pilotSyncId() ) );
+  if ( hasPilotSyncStatus() )
+    writeString( element, "pilot-sync-status", QString::number( pilotSyncStatus() ) );
+  return true;
+}
+
+bool KolabBase::load( const QString& xml )
+{
+  const QDomDocument document = loadDocument( xml );
+  if ( document.isNull() )
+    return false;
+  // XML file loaded into tree. Now parse it
+  return loadXML( document );
+}
+
+QDomDocument KolabBase::loadDocument( const QString& xmlData )
+{
+  QString errorMsg;
+  int errorLine, errorColumn;
+  QDomDocument document;
+  bool ok = document.setContent( xmlData, &errorMsg, &errorLine, &errorColumn );
+
+  if ( !ok ) {
+    qWarning( "Error loading document: %s, line %d, column %d", qPrintable( errorMsg ), errorLine, errorColumn );
+    return QDomDocument();
+  }
+
+  return document;
+}
+
+QDomDocument KolabBase::domTree()
+{
+  QDomDocument document;
+
+  QString p = "version=\"1.0\" encoding=\"UTF-8\"";
+  document.appendChild(document.createProcessingInstruction( "xml", p ) );
+
+  return document;
+}
+
+
+QString KolabBase::dateTimeToString( const KDateTime& time )
+{
+  return time.toString( KDateTime::ISODate );
+}
+
+QString KolabBase::dateToString( const QDate& date )
+{
+  return date.toString( Qt::ISODate );
+}
+
+KDateTime KolabBase::stringToDateTime( const QString& _date )
+{
+  const QString date( _date );
+  return KDateTime::fromString( date, KDateTime::ISODate );
+}
+
+QDate KolabBase::stringToDate( const QString& date )
+{
+  return QDate::fromString( date, Qt::ISODate );
+}
+
+QString KolabBase::sensitivityToString( Sensitivity s )
+{
+  switch( s ) {
+  case Private: return "private";
+  case Confidential: return "confidential";
+  case Public: return "public";
+  }
+
+  return "What what what???";
+}
+
+KolabBase::Sensitivity KolabBase::stringToSensitivity( const QString& s )
+{
+  if ( s == "private" )
+    return Private;
+  if ( s == "confidential" )
+    return Confidential;
+  return Public;
+}
+
+QString KolabBase::colorToString( const QColor& color )
+{
+  // Color is in the format "#RRGGBB"
+  return color.name();
+}
+
+QColor KolabBase::stringToColor( const QString& s )
+{
+  return QColor( s );
+}
+
+void KolabBase::writeString( QDomElement& element, const QString& tag,
+                             const QString& tagString )
+{
+  if ( !tagString.isEmpty() ) {
+    QDomElement e = element.ownerDocument().createElement( tag );
+    QDomText t = element.ownerDocument().createTextNode( tagString );
+    e.appendChild( t );
+    element.appendChild( e );
+  }
+}
+
+KDateTime KolabBase::localToUTC( const KDateTime& time ) const
+{
+  return time.toUtc();
+}
+
+KDateTime KolabBase::utcToLocal( const KDateTime& time ) const
+{
+  KDateTime dt = time;
+  dt.setTimeSpec( KDateTime::UTC );
+  return dt;
+}
diff --git a/src/kolabformatV2/kolabbase.h b/src/kolabformatV2/kolabbase.h
new file mode 100644
index 0000000..5bdfdec
--- /dev/null
+++ b/src/kolabformatV2/kolabbase.h
@@ -0,0 +1,183 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#ifndef KOLABV2BASE_H
+#define KOLABV2BASE_H
+
+
+#include <kcalcore/incidence.h>
+
+#include <kdatetime.h>
+#include <ktimezone.h>
+
+#include <QColor>
+#include <qdom.h>
+
+namespace KABC {
+  class Addressee;
+  class ContactGroup;
+}
+
+namespace KolabV2 {
+
+class KolabBase {
+public:
+  struct Email {
+  public:
+    Email( const QString& name = QString(),
+           const QString& email = QString() )
+      : displayName( name ), smtpAddress( email )
+    {
+    }
+
+    QString displayName;
+    QString smtpAddress;
+  };
+
+  enum Sensitivity { Public = 0, Private = 1, Confidential = 2 };
+
+  explicit KolabBase( const QString& time_zone = QString() );
+  virtual ~KolabBase();
+
+  // Return a string identifying this type
+  virtual QString type() const = 0;
+
+  virtual void setUid( const QString& uid );
+  virtual QString uid() const;
+
+  virtual void setBody( const QString& body );
+  virtual QString body() const;
+
+  virtual void setCategories( const QString& categories );
+  virtual QString categories() const;
+
+  virtual void setCreationDate( const KDateTime& date );
+  virtual KDateTime creationDate() const;
+
+  virtual void setLastModified( const KDateTime& date );
+  virtual KDateTime lastModified() const;
+
+  virtual void setSensitivity( Sensitivity sensitivity );
+  virtual Sensitivity sensitivity() const;
+
+  virtual void setPilotSyncId( unsigned long id );
+  virtual bool hasPilotSyncId() const;
+  virtual unsigned long pilotSyncId() const;
+
+  virtual void setPilotSyncStatus( int status );
+  virtual bool hasPilotSyncStatus() const;
+  virtual int pilotSyncStatus() const;
+
+  // String - Date conversion methods
+  static QString dateTimeToString( const KDateTime& time );
+  static QString dateToString( const QDate& date );
+  static KDateTime stringToDateTime( const QString& time );
+  static QDate stringToDate( const QString& date );
+
+  // String - Sensitivity conversion methods
+  static QString sensitivityToString( Sensitivity );
+  static Sensitivity stringToSensitivity( const QString& );
+
+  // String - Color conversion methods
+  static QString colorToString( const QColor& );
+  static QColor stringToColor( const QString& );
+
+  // Load this object by reading the XML file
+  bool load( const QString& xml );
+  static QDomDocument loadDocument( const QString& xmlData );
+
+  // Load this QDomDocument
+  virtual bool loadXML( const QDomDocument& xml ) = 0;
+
+  // Serialize this object to an XML string
+  virtual QString saveXML() const = 0;
+
+protected:
+  /// Read all known fields from this ical incidence
+  void setFields( const KCalCore::Incidence::Ptr & );
+
+  /// Save all known fields into this ical incidence
+  void saveTo( const KCalCore::Incidence::Ptr & ) const;
+
+  /// Read all known fields from this contact
+  void setFields( const KABC::Addressee* );
+
+  /// Save all known fields into this contact
+  void saveTo( KABC::Addressee* ) const;
+
+  /// Read all known fields from this contact group
+  void setFields( const KABC::ContactGroup* );
+
+  /// Save all known fields into this contact groupd
+  void saveTo( KABC::ContactGroup* ) const;
+
+  // This just makes the initial dom tree with version and doctype
+  static QDomDocument domTree();
+
+  bool loadEmailAttribute( QDomElement& element, Email& email );
+
+  void saveEmailAttribute( QDomElement& element, const Email& email,
+                           const QString& tagName = "email" ) const;
+
+  // Load the attributes of this class
+  virtual bool loadAttribute( QDomElement& );
+
+  // Save the attributes of this class
+  virtual bool saveAttributes( QDomElement& ) const;
+
+  // Return the product ID
+  virtual QString productID() const = 0;
+
+  // Write a string tag
+  static void writeString( QDomElement&, const QString&, const QString& );
+
+  KDateTime localToUTC( const KDateTime& time ) const;
+  KDateTime utcToLocal( const KDateTime& time ) const;
+
+  QString mUid;
+  QString mBody;
+  QString mCategories;
+  KDateTime mCreationDate;
+  KDateTime mLastModified;
+  Sensitivity mSensitivity;
+  KTimeZone mTimeZone;
+
+  // KPilot synchronization stuff
+  bool mHasPilotSyncId,  mHasPilotSyncStatus;
+  unsigned long mPilotSyncId;
+  int mPilotSyncStatus;
+};
+
+}
+
+#endif // KOLABBASE_H
diff --git a/src/kolabformatV2/note.cpp b/src/kolabformatV2/note.cpp
new file mode 100644
index 0000000..431a420
--- /dev/null
+++ b/src/kolabformatV2/note.cpp
@@ -0,0 +1,230 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#include "note.h"
+#include "kolab_version.h"
+
+#include <kcalcore/journal.h>
+#include <kdebug.h>
+
+using namespace KolabV2;
+
+
+KCalCore::Journal::Ptr Note::xmlToJournal( const QString& xml )
+{
+  Note note;
+  note.load( xml );
+  KCalCore::Journal::Ptr journal( new KCalCore::Journal() );
+  note.saveTo( journal );
+  return journal;
+}
+
+QString Note::journalToXML( const KCalCore::Journal::Ptr &journal )
+{
+  Note note( journal );
+  return note.saveXML();
+}
+
+Note::Note( const KCalCore::Journal::Ptr &journal ) : mRichText( false )
+{
+  if ( journal )
+    setFields( journal );
+}
+
+Note::~Note()
+{
+}
+
+void Note::setSummary( const QString& summary )
+{
+  mSummary = summary;
+}
+
+QString Note::summary() const
+{
+  return mSummary;
+}
+
+void Note::setBackgroundColor( const QColor& bgColor )
+{
+  mBackgroundColor = bgColor;
+}
+
+QColor Note::backgroundColor() const
+{
+  return mBackgroundColor;
+}
+
+void Note::setForegroundColor( const QColor& fgColor )
+{
+  mForegroundColor = fgColor;
+}
+
+QColor Note::foregroundColor() const
+{
+  return mForegroundColor;
+}
+
+void Note::setRichText( bool richText )
+{
+  mRichText = richText;
+}
+
+bool Note::richText() const
+{
+  return mRichText;
+}
+
+bool Note::loadAttribute( QDomElement& element )
+{
+  QString tagName = element.tagName();
+  if ( tagName == "summary" )
+    setSummary( element.text() );
+  else if ( tagName == "foreground-color" )
+    setForegroundColor( stringToColor( element.text() ) );
+  else if ( tagName == "background-color" )
+    setBackgroundColor( stringToColor( element.text() ) );
+  else if ( tagName == "knotes-richtext" )
+    mRichText = ( element.text() == "true" );
+  else
+    return KolabBase::loadAttribute( element );
+
+  // We handled this
+  return true;
+}
+
+bool Note::saveAttributes( QDomElement& element ) const
+{
+  // Save the base class elements
+  KolabBase::saveAttributes( element );
+
+  // Save the elements
+#if 0
+  QDomComment c = element.ownerDocument().createComment( "Note specific attributes" );
+  element.appendChild( c );
+#endif
+
+  writeString( element, "summary", summary() );
+  if ( foregroundColor().isValid() )
+    writeString( element, "foreground-color", colorToString( foregroundColor() ) );
+  if ( backgroundColor().isValid() )
+    writeString( element, "background-color", colorToString( backgroundColor() ) );
+  writeString( element, "knotes-richtext", mRichText ? "true" : "false" );
+
+  return true;
+}
+
+
+bool Note::loadXML( const QDomDocument& document )
+{
+  QDomElement top = document.documentElement();
+
+  if ( top.tagName() != "note" ) {
+    qWarning( "XML error: Top tag was %s instead of the expected note",
+              top.tagName().toAscii().data() );
+    return false;
+  }
+
+  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      if ( !loadAttribute( e ) )
+        // TODO: Unhandled tag - save for later storage
+        kDebug() <<"Warning: Unhandled tag" << e.tagName();
+    } else
+      kDebug() <<"Node is not a comment or an element???";
+  }
+
+  return true;
+}
+
+QString Note::saveXML() const
+{
+  QDomDocument document = domTree();
+  QDomElement element = document.createElement( "note" );
+  element.setAttribute( "version", "1.0" );
+  saveAttributes( element );
+  document.appendChild( element );
+  return document.toString();
+}
+
+void Note::setFields( const KCalCore::Journal::Ptr &journal )
+{
+  KolabBase::setFields( journal );
+
+  setSummary( journal->summary() );
+
+  QString property = journal->customProperty( "KNotes", "BgColor" );
+  if ( !property.isEmpty() ) {
+    setBackgroundColor( property );
+  } else {
+    setBackgroundColor( "yellow" );
+  }
+
+  property = journal->customProperty( "KNotes", "FgColor" );
+  if ( !property.isEmpty() ) {
+    setForegroundColor( property );
+  } else {
+    setForegroundColor( "black" );
+  }
+
+  property = journal->customProperty( "KNotes", "RichText" );
+  if ( !property.isEmpty() ) {
+    setRichText( property == "true" ? true : false );
+  } else {
+    setRichText( "false" );
+  }
+}
+
+void Note::saveTo( const KCalCore::Journal::Ptr &journal )
+{
+  KolabBase::saveTo( journal );
+
+  // TODO: background and foreground
+  journal->setSummary( summary() );
+  if ( foregroundColor().isValid() )
+    journal->setCustomProperty( "KNotes", "FgColor",
+                                colorToString( foregroundColor() ) );
+  if ( backgroundColor().isValid() )
+    journal->setCustomProperty( "KNotes", "BgColor",
+                                colorToString( backgroundColor() ) );
+  journal->setCustomProperty( "KNotes", "RichText",
+                              richText() ? "true" : "false" );
+}
+
+QString Note::productID() const
+{
+  return QString( "KNotes %1, Kolab resource" ).arg( KOLAB_VERSION_STRING );
+}
diff --git a/src/kolabformatV2/note.h b/src/kolabformatV2/note.h
new file mode 100644
index 0000000..3406ecc
--- /dev/null
+++ b/src/kolabformatV2/note.h
@@ -0,0 +1,109 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#ifndef KOLABV2_NOTE_H
+#define KOLABV2_NOTE_H
+
+#include <kcalcore/journal.h>
+
+#include "kolabbase.h"
+
+class QDomElement;
+
+namespace KolabV2 {
+
+/**
+ * This class represents a note, and knows how to load/save it
+ * from/to XML, and from/to a KCalCore::Journal.
+ * The instances of this class are temporary, only used to convert
+ * one to the other.
+ */
+class Note : public KolabBase {
+public:
+  /// Use this to parse an xml string to a journal entry
+  /// The caller is responsible for deleting the returned journal
+    static KCalCore::Journal::Ptr xmlToJournal( const QString& xml );
+
+  /// Use this to get an xml string describing this journal entry
+    static QString journalToXML( const KCalCore::Journal::Ptr & );
+
+  /// Create a note object and
+  explicit Note( const KCalCore::Journal::Ptr &journal = KCalCore::Journal::Ptr() );
+  virtual ~Note();
+
+  void saveTo( const KCalCore::Journal::Ptr &journal );
+
+  virtual QString type() const { return "Note"; }
+
+  virtual void setSummary( const QString& summary );
+  virtual QString summary() const;
+
+  virtual void setBackgroundColor( const QColor& bgColor );
+  virtual QColor backgroundColor() const;
+
+  virtual void setForegroundColor( const QColor& fgColor );
+  virtual QColor foregroundColor() const;
+
+  virtual void setRichText( bool richText );
+  virtual bool richText() const;
+
+  // Load the attributes of this class
+  virtual bool loadAttribute( QDomElement& );
+
+  // Save the attributes of this class
+  virtual bool saveAttributes( QDomElement& ) const;
+
+  // Load this note by reading the XML file
+  virtual bool loadXML( const QDomDocument& xml );
+
+  // Serialize this note to an XML string
+  virtual QString saveXML() const;
+
+protected:
+  // Read all known fields from this ical incidence
+  void setFields( const KCalCore::Journal::Ptr & );
+
+  // Save all known fields into this ical incidence
+  void saveTo( const KCalCore::Incidence::Ptr & ) const;
+
+  QString productID() const;
+
+  QString mSummary;
+  QColor mBackgroundColor;
+  QColor mForegroundColor;
+  bool mRichText;
+};
+
+}
+
+#endif // KOLAB_NOTE_H
diff --git a/src/kolabformatV2/task.cpp b/src/kolabformatV2/task.cpp
new file mode 100644
index 0000000..0e6772f
--- /dev/null
+++ b/src/kolabformatV2/task.cpp
@@ -0,0 +1,349 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#include "task.h"
+
+#include <kcalcore/todo.h>
+#include <kdebug.h>
+
+using namespace KolabV2;
+
+KCalCore::Todo::Ptr Task::fromXml( const QDomDocument& xmlDoc, const QString& tz )
+{
+  Task task( tz );
+  task.loadXML( xmlDoc );
+  KCalCore::Todo::Ptr todo(  new KCalCore::Todo() );
+  task.saveTo( todo );
+  return todo;
+}
+
+QString Task::taskToXML( const KCalCore::Todo::Ptr &todo, const QString& tz )
+{
+  Task task( tz, todo );
+  return task.saveXML();
+}
+
+Task::Task( const QString& tz, const KCalCore::Todo::Ptr &task )
+  : Incidence( tz, task ),
+    mPercentCompleted( 0 ),
+    mStatus( KCalCore::Incidence::StatusNone ),
+    mHasStartDate( false ), mHasDueDate( false ),
+    mHasCompletedDate( false )
+{
+  if ( task ) {
+    setFields( task );
+  }
+}
+
+Task::~Task()
+{
+}
+
+void Task::setPercentCompleted( int percent )
+{
+  mPercentCompleted = percent;
+}
+
+int Task::percentCompleted() const
+{
+  return mPercentCompleted;
+}
+
+void Task::setStatus( KCalCore::Incidence::Status status )
+{
+  mStatus = status;
+}
+
+KCalCore::Incidence::Status Task::status() const
+{
+  return mStatus;
+}
+
+void Task::setParent( const QString& parentUid )
+{
+  mParent = parentUid;
+}
+
+QString Task::parent() const
+{
+  return mParent;
+}
+
+void Task::setDueDate( const KDateTime &date )
+{
+  mDueDate = date;
+  mHasDueDate = true;
+}
+
+void Task::setDueDate( const QDate &date )
+{
+  mDueDate = KDateTime( date );
+  mHasDueDate = true;
+  mFloatingStatus = AllDay;
+}
+
+void Task::setDueDate( const QString &date )
+{
+  if ( date.length() > 10 ) {
+    // This is a date + time
+     setDueDate( stringToDateTime( date ) );
+  } else {
+     // This is only a date
+    setDueDate( stringToDate( date ) );
+  }
+}
+
+KDateTime Task::dueDate() const
+{
+  return mDueDate;
+}
+
+void Task::setHasStartDate( bool v )
+{
+  mHasStartDate = v;
+}
+
+bool Task::hasStartDate() const
+{
+  return mHasStartDate;
+}
+
+bool Task::hasDueDate() const
+{
+  return mHasDueDate;
+}
+
+void Task::setCompletedDate( const KDateTime& date )
+{
+  mCompletedDate = date;
+  mHasCompletedDate = true;
+}
+
+KDateTime Task::completedDate() const
+{
+  return mCompletedDate;
+}
+
+bool Task::hasCompletedDate() const
+{
+  return mHasCompletedDate;
+}
+
+bool Task::loadAttribute( QDomElement& element )
+{
+  QString tagName = element.tagName();
+
+  if ( tagName == "completed" ) {
+    bool ok;
+    int percent = element.text().toInt( &ok );
+    if ( !ok || percent < 0 || percent > 100 )
+      percent = 0;
+    setPercentCompleted( percent );
+  } else if ( tagName == "status" ) {
+    if ( element.text() == "in-progress" )
+      setStatus( KCalCore::Incidence::StatusInProcess );
+    else if ( element.text() == "completed" )
+      setStatus( KCalCore::Incidence::StatusCompleted );
+    else if ( element.text() == "waiting-on-someone-else" )
+      setStatus( KCalCore::Incidence::StatusNeedsAction );
+    else if ( element.text() == "deferred" )
+      // Guessing a status here
+      setStatus( KCalCore::Incidence::StatusCanceled );
+    else
+      // Default
+      setStatus( KCalCore::Incidence::StatusNone );
+  } else if ( tagName == "due-date" ) {
+    setDueDate( element.text() );
+  } else if ( tagName == "parent" ) {
+    setParent( element.text() );
+  } else if ( tagName == "x-completed-date" ) {
+    setCompletedDate( stringToDateTime( element.text() ) );
+  } else if ( tagName == "start-date" ) {
+    setHasStartDate( true );
+    setStartDate( element.text() );
+  } else
+    return Incidence::loadAttribute( element );
+
+  // We handled this
+  return true;
+}
+
+bool Task::saveAttributes( QDomElement& element ) const
+{
+  // Save the base class elements
+  Incidence::saveAttributes( element );
+
+  writeString( element, "completed", QString::number( percentCompleted() ) );
+
+  switch( status() ) {
+  case KCalCore::Incidence::StatusInProcess:
+    writeString( element, "status", "in-progress" );
+    break;
+  case KCalCore::Incidence::StatusCompleted:
+    writeString( element, "status", "completed" );
+    break;
+  case KCalCore::Incidence::StatusNeedsAction:
+    writeString( element, "status", "waiting-on-someone-else" );
+    break;
+  case KCalCore::Incidence::StatusCanceled:
+    writeString( element, "status", "deferred" );
+    break;
+  case KCalCore::Incidence::StatusNone:
+    writeString( element, "status", "not-started" );
+    break;
+  case KCalCore::Incidence::StatusTentative:
+  case KCalCore::Incidence::StatusConfirmed:
+  case KCalCore::Incidence::StatusDraft:
+  case KCalCore::Incidence::StatusFinal:
+  case KCalCore::Incidence::StatusX:
+    // All of these are saved as StatusNone.
+    writeString( element, "status", "not-started" );
+    break;
+  }
+
+  if ( hasDueDate() ) {
+    if ( mFloatingStatus == HasTime ) {
+      writeString( element, "due-date", dateTimeToString( dueDate() ) );
+    } else {
+      writeString( element, "due-date", dateToString( dueDate().date() ) );
+    }
+  }
+
+  if ( !parent().isNull() ) {
+    writeString( element, "parent", parent() );
+  }
+
+  if ( hasCompletedDate() && percentCompleted() == 100 ) {
+    writeString( element, "x-completed-date", dateTimeToString( completedDate() ) );
+  }
+
+  return true;
+}
+
+
+bool Task::loadXML( const QDomDocument& document )
+{
+  QDomElement top = document.documentElement();
+
+  if ( top.tagName() != "task" ) {
+    qWarning( "XML error: Top tag was %s instead of the expected task",
+              top.tagName().toAscii().data() );
+    return false;
+  }
+  setHasStartDate( false ); // todo's don't necessarily have one
+
+  for ( QDomNode n = top.firstChild(); !n.isNull(); n = n.nextSibling() ) {
+    if ( n.isComment() )
+      continue;
+    if ( n.isElement() ) {
+      QDomElement e = n.toElement();
+      if ( !loadAttribute( e ) )
+        // TODO: Unhandled tag - save for later storage
+        kDebug() <<"Warning: Unhandled tag" << e.tagName();
+    } else
+      kDebug() <<"Node is not a comment or an element???";
+  }
+
+  return true;
+}
+
+QString Task::saveXML() const
+{
+  QDomDocument document = domTree();
+  QDomElement element = document.createElement( "task" );
+  element.setAttribute( "version", "1.0" );
+  saveAttributes( element );
+  if ( !hasStartDate() && startDate().isValid() ) {
+    // events and journals always have a start date, but tasks don't.
+    // Remove the entry done by the inherited save above, because we
+    // don't have one.
+    QDomNodeList l = element.elementsByTagName( "start-date" );
+    Q_ASSERT( l.count() == 1 );
+    element.removeChild( l.item( 0 ) );
+  }
+  document.appendChild( element );
+  return document.toString();
+}
+
+void Task::setFields( const KCalCore::Todo::Ptr &task )
+{
+  Incidence::setFields( task );
+
+  setPercentCompleted( task->percentComplete() );
+  setStatus( task->status() );
+  setHasStartDate( task->hasStartDate() );
+
+  if ( task->hasDueDate() ) {
+    if ( task->allDay() ) {
+      // This is a floating task. Don't timezone move this one
+      mFloatingStatus = AllDay;
+      setDueDate( KDateTime( task->dtDue().date() ) );
+    } else {
+      mFloatingStatus = HasTime;
+      setDueDate( localToUTC( task->dtDue() ) );
+    }
+  } else {
+    mHasDueDate = false;
+  }
+
+  if ( !task->relatedTo().isEmpty() ) {
+    setParent( task->relatedTo() );
+  } else{
+    setParent( QString() );
+  }
+
+  if ( task->hasCompletedDate() && task->percentComplete() == 100 ) {
+    setCompletedDate( localToUTC( task->completed() ) );
+  } else {
+    mHasCompletedDate = false;
+  }
+}
+
+void Task::saveTo( const KCalCore::Todo::Ptr &task )
+{
+  Incidence::saveTo( task );
+
+  task->setPercentComplete( percentCompleted() );
+  task->setStatus( status() );
+  task->setHasStartDate( hasStartDate() );
+  task->setHasDueDate( hasDueDate() );
+  if ( hasDueDate() )
+    task->setDtDue( utcToLocal( dueDate() ) );
+
+  if ( !parent().isEmpty() ) {
+    task->setRelatedTo( parent() );
+  }
+
+  if ( hasCompletedDate() && task->percentComplete() == 100 )
+    task->setCompleted( utcToLocal( mCompletedDate ) );
+}
diff --git a/src/kolabformatV2/task.h b/src/kolabformatV2/task.h
new file mode 100644
index 0000000..da45caf
--- /dev/null
+++ b/src/kolabformatV2/task.h
@@ -0,0 +1,127 @@
+/*
+    This file is part of the kolab resource - the implementation of the
+    Kolab storage format. See www.kolab.org for documentation on this.
+
+    Copyright (c) 2004 Bo Thorsen <bo@sonofthor.dk>
+
+    This library is free software; you can redistribute it and/or
+    modify it under the terms of the GNU Library General Public
+    License as published by the Free Software Foundation; either
+    version 2 of the License, or (at your option) any later version.
+
+    This library is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+    Library General Public License for more details.
+
+    You should have received a copy of the GNU Library General Public License
+    along with this library; see the file COPYING.LIB.  If not, write to
+    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+    Boston, MA 02110-1301, USA.
+
+    In addition, as a special exception, the copyright holders give
+    permission to link the code of this program with any edition of
+    the Qt library by Trolltech AS, Norway (or with modified versions
+    of Qt that use the same license as Qt), and distribute linked
+    combinations including the two.  You must obey the GNU General
+    Public License in all respects for all of the code used other than
+    Qt.  If you modify this file, you may extend this exception to
+    your version of the file, but you are not obligated to do so.  If
+    you do not wish to do so, delete this exception statement from
+    your version.
+*/
+
+#ifndef KOLABV2_TASK_H
+#define KOLABV2_TASK_H
+
+#include "incidence.h"
+
+#include <kcalcore/todo.h>
+#include <kcalcore/incidence.h>
+
+class QDomElement;
+
+namespace KCal {
+  class ResourceKolab;
+}
+
+namespace KolabV2 {
+
+/**
+ * This class represents a task, and knows how to load/save it
+ * from/to XML, and from/to a KCalCore::Todo.
+ * The instances of this class are temporary, only used to convert
+ * one to the other.
+ */
+class Task : public Incidence {
+public:
+  /// Use this to parse an xml string to a task entry
+  /// The caller is responsible for deleting the returned task
+  static KCalCore::Todo::Ptr fromXml( const QDomDocument& xmlDoc, const QString& tz/*, KCalCore::ResourceKolab *res = 0,
+                                const QString& subResource = QString(), quint32 sernum = 0 */);
+
+  /// Use this to get an xml string describing this task entry
+  static QString taskToXML( const KCalCore::Todo::Ptr &, const QString& tz );
+
+  explicit Task( /*KCalCore::ResourceKolab *res, const QString& subResource, quint32 sernum,*/
+    const QString& tz, const KCalCore::Todo::Ptr &todo = KCalCore::Todo::Ptr() );
+  virtual ~Task();
+
+  virtual QString type() const { return "Task"; }
+
+  void saveTo( const KCalCore::Todo::Ptr &todo );
+
+  virtual void setPercentCompleted( int percent );
+  virtual int percentCompleted() const;
+
+  virtual void setStatus( KCalCore::Incidence::Status status );
+  virtual KCalCore::Incidence::Status status() const;
+
+  virtual void setParent( const QString& parentUid );
+  virtual QString parent() const;
+
+  virtual void setHasStartDate( bool );
+  virtual bool hasStartDate() const;
+
+  virtual void setDueDate( const KDateTime& date );
+  virtual void setDueDate( const QString &date );
+  virtual void setDueDate( const QDate &date );
+  virtual KDateTime dueDate() const;
+  virtual bool hasDueDate() const;
+
+  virtual void setCompletedDate( const KDateTime& date );
+  virtual KDateTime completedDate() const;
+  virtual bool hasCompletedDate() const;
+
+  // Load the attributes of this class
+  virtual bool loadAttribute( QDomElement& );
+
+  // Save the attributes of this class
+  virtual bool saveAttributes( QDomElement& ) const;
+
+  // Load this task by reading the XML file
+  virtual bool loadXML( const QDomDocument& xml );
+
+  // Serialize this task to an XML string
+  virtual QString saveXML() const;
+
+protected:
+  // Read all known fields from this ical todo
+  void setFields( const KCalCore::Todo::Ptr & );
+
+  int mPercentCompleted;
+  KCalCore::Incidence::Status mStatus;
+  QString mParent;
+
+  bool mHasStartDate;
+
+  bool mHasDueDate;
+  KDateTime mDueDate;
+
+  bool mHasCompletedDate;
+  KDateTime mCompletedDate;
+};
+
+}
+
+#endif // KOLAB_TASK_H
diff --git a/src/mime/mimeutils.cpp b/src/mime/mimeutils.cpp
new file mode 100644
index 0000000..bc3e25c
--- /dev/null
+++ b/src/mime/mimeutils.cpp
@@ -0,0 +1,303 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "mimeutils.h"
+#include <quuid.h>
+#include <QtCore/qfile.h>
+#include <qdom.h>
+#include <kdebug.h>
+#include <kabc/addressee.h>
+#include "kolabformat/kolabdefinitions.h"
+#include "kolabformat/errorhandler.h"
+#include "kolab_version.h"
+
+namespace Kolab {
+    namespace Mime {
+
+KMime::Content* findContentByType(const KMime::Message::Ptr &data, const QByteArray &type)
+{
+    if (type.isEmpty()) {
+        Error() << "Empty type";
+        return 0;
+    }
+    Q_ASSERT(!data->contents().isEmpty());
+    Q_FOREACH(KMime::Content *c, data->contents()) {
+//         qDebug() << c->contentType()->mimeType() << type;
+        if (c->contentType()->mimeType() ==  type) {
+            return c;
+        }
+    }
+    return 0;
+}
+
+KMime::Content* findContentByName(const KMime::Message::Ptr &data, const QString &name, QByteArray &type)
+{
+    Q_ASSERT(!data->contents().isEmpty());
+    Q_FOREACH(KMime::Content *c, data->contents()) {
+//         qDebug() << "searching: " << c->contentType()->name().toUtf8();
+        if ( c->contentType()->name() == name ) {
+            type = c->contentType()->mimeType();
+            return c;
+        }
+    }
+    return 0;
+}
+
+KMime::Content* findContentById(const KMime::Message::Ptr &data, const QByteArray &id, QByteArray &type, QString &name)
+{
+    if (id.isEmpty()) {
+        Error() << "looking for empty cid";
+        return 0;
+    }
+    Q_ASSERT(!data->contents().isEmpty());
+    Q_FOREACH(KMime::Content *c, data->contents()) {
+//         kDebug() << "searching: " << c->contentID()->identifier();
+        if ( c->contentID()->identifier() == id ) {
+            type = c->contentType()->mimeType();
+            name = c->contentType()->name();
+            return c;
+        }
+    }
+    return 0;
+}
+
+QList<QByteArray> getContentMimeTypeList(const KMime::Message::Ptr& data)
+{
+    QList<QByteArray> typeList;
+    Q_ASSERT(!data->contents().isEmpty());
+    Q_FOREACH(KMime::Content *c, data->contents()) {
+        typeList.append(c->contentType()->mimeType());
+    }
+    return typeList;
+}
+
+QString fromCid(const QString &cid)
+{
+    if (cid.left(4) != QString::fromLatin1("cid:")) { //Don't set if not a cid, happens when serializing format v2
+        return QString();
+    }
+    return cid.right(cid.size()-4);
+}
+
+KMime::Message::Ptr createMessage(const KCalCore::Incidence::Ptr &incidencePtr, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &productId)
+{
+    KMime::Message::Ptr message = createMessage( xKolabType, v3, productId );
+    if (!incidencePtr) {
+        Error() << "invalid incidence passed  in";
+        message->assemble();
+        return message;
+    }
+    if ( incidencePtr->organizer() && !incidencePtr->organizer()->email().isEmpty()) {
+        message->from()->addAddress( incidencePtr->organizer()->email().toUtf8(), incidencePtr->organizer()->name() );
+    }
+    message->subject()->fromUnicodeString( incidencePtr->uid(), "utf-8" );
+    
+    KMime::Content *content = createMainPart( mimetype, xml );
+    message->addContent( content );
+    
+    Q_FOREACH (KCalCore::Attachment::Ptr attachment, incidencePtr->attachments()) {
+        //Serialize the attachment as attachment with uri, referencing the created mime-part
+        if (v3 && !attachment->uri().contains("cid:")) {
+            //onyl by url, skip
+            continue;
+        }
+        message->addContent( createAttachmentPart(fromCid(attachment->uri()).toLatin1(), attachment->mimeType(), attachment->label(), attachment->decodedData() ) );
+    }
+    
+    message->assemble();
+    return message;
+}
+
+KMime::Message::Ptr createMessage(const KABC::Addressee &contact, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &prodid)
+{
+    KMime::Message::Ptr message = Mime::createMessage( xKolabType, v3, prodid );
+    message->subject()->fromUnicodeString( contact.uid(), "utf-8" );
+    message->from()->fromUnicodeString( contact.fullEmail(), "utf-8" );
+    
+    KMime::Content* content = Mime::createMainPart( mimetype, xml );
+    message->addContent( content );
+
+// TODO add pictures as separate mimeparts
+//     if ( !contact.picture().isNull() ) {
+//         QByteArray pic;
+//         QBuffer buffer(&pic);
+//         buffer.open(QIODevice::WriteOnly);
+//         contact.picture().save(&buffer, "PNG");
+//         buffer.close();
+//         
+//         content = Mime::createAttachmentPart(QByteArray(), "image/png", "kolab-picture.png", pic );
+//         message->addContent(content);
+//     }
+//     
+//     if ( !contact.logo().isNull() ) {
+//         QByteArray pic;
+//         QBuffer buffer(&pic);
+//         buffer.open(QIODevice::WriteOnly);
+//         contact.logo().save(&buffer, "PNG");
+//         buffer.close();
+//         
+//         content = Mime::createAttachmentPart(QByteArray(), "image/png", "kolab-logo.png", pic );
+//         message->addContent(content);
+//     }
+//     
+//     if ( !contact.sound().isEmpty() ) {
+//         content = Mime::createAttachmentPart(QByteArray(), "audio/unknown", "sound", contact.sound() );
+//         message->addContent(content);
+//     }
+    
+    message->assemble();
+    return message;
+}
+
+KMime::Message::Ptr createMessage(const QString &subject, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &prodid)
+{
+    KMime::Message::Ptr message = createMessage( xKolabType, v3, prodid );
+    if (!subject.isEmpty()) {
+        message->subject()->fromUnicodeString( subject, "utf-8" );
+    }
+    
+    KMime::Content *content = createMainPart( mimetype, xml );
+    message->addContent( content );
+    
+    message->assemble();
+    return message;
+}
+
+KMime::Content* createExplanationPart(bool v3)
+{
+    KMime::Content *content = new KMime::Content();
+    content->contentType()->setMimeType( "text/plain" );
+    content->contentType()->setCharset( "us-ascii" );
+    content->contentTransferEncoding()->setEncoding( KMime::Headers::CE7Bit );
+    if (v3) {
+        content->setBody( "This is a Kolab Groupware object.\n"
+        "To view this object you will need an email client that can understand the Kolab Groupware format.\n"
+        "For a list of such email clients please visit\n"
+        "http://www.kolab.org/get-kolab\n" );
+    } else {
+        content->setBody( "This is a Kolab Groupware object.\n"
+        "To view this object you will need an email client that can understand the Kolab Groupware format.\n"
+        "For a list of such email clients please visit\n"
+        "http://www.kolab.org/get-kolab\n" );
+    }
+    return content;
+}
+
+
+KMime::Message::Ptr createMessage(const QString& xKolabType, bool v3, const QString &prodid)
+{
+    KMime::Message::Ptr message( new KMime::Message );
+    message->date()->setDateTime( KDateTime::currentUtcDateTime().dateTime() );
+    KMime::Headers::Generic *h = new KMime::Headers::Generic( X_KOLAB_TYPE_HEADER, message.get(), xKolabType, "utf-8" );
+    message->appendHeader( h );
+    if (v3) {
+        KMime::Headers::Generic *vh = new KMime::Headers::Generic( X_KOLAB_MIME_VERSION_HEADER, message.get(), KOLAB_VERSION_V3, "utf-8" );
+        message->appendHeader( vh );
+    }
+    message->userAgent()->from7BitString( prodid.toLatin1() );
+    message->contentType()->setMimeType( "multipart/mixed" );
+    message->contentType()->setBoundary( KMime::multiPartBoundary() );
+    
+    message->addContent( createExplanationPart(v3) );
+    return message;
+}
+
+
+KMime::Content* createMainPart(const QString& mimeType, const QByteArray& decodedContent)
+{
+    KMime::Content* content = new KMime::Content();
+    content->contentType()->setMimeType( mimeType.toLatin1() );
+    content->contentType()->setName( KOLAB_OBJECT_FILENAME, "us-ascii" );
+    content->contentTransferEncoding()->setEncoding( KMime::Headers::CEquPr );
+    content->contentDisposition()->setDisposition( KMime::Headers::CDattachment );
+    content->contentDisposition()->setFilename( KOLAB_OBJECT_FILENAME );
+    content->setBody( decodedContent );
+    return content;
+}
+
+KMime::Content* createAttachmentPart(const QByteArray& cid, const QString& mimeType, const QString& fileName, const QByteArray& decodedContent)
+{
+    KMime::Content* content = new KMime::Content();
+    if (!cid.isEmpty()) {
+        content->contentID()->setIdentifier( cid );
+    }
+    content->contentType()->setMimeType( mimeType.toLatin1() );
+    content->contentType()->setName( fileName, "utf-8" );
+    content->contentTransferEncoding()->setEncoding( KMime::Headers::CEbase64 );
+    content->contentDisposition()->setDisposition( KMime::Headers::CDattachment );
+    content->contentDisposition()->setFilename( fileName );
+    content->setBody( decodedContent );
+    return content;
+}
+
+void getAttachments(KCalCore::Incidence::Ptr incidence, const QStringList &attachments, const KMime::Message::Ptr &mimeData)
+{
+    if (!incidence) {
+        Error() << "Invalid incidence";
+        return;
+    }
+//     kDebug() << "getting " << attachments.size() << "attachments";
+//     kDebug() << mimeData->encodedContent();
+    foreach (const QString &name, attachments) {
+        QByteArray type;
+        KMime::Content *content = findContentByName(mimeData, name, type);
+        if (!content) { // guard against malformed events with non-existent attachments
+            Warning() << "could not find attachment: "<< name.toUtf8() << type;
+            continue;
+        }
+        const QByteArray c = content->decodedContent().toBase64();
+//         Debug() << c;
+        KCalCore::Attachment::Ptr attachment( new KCalCore::Attachment( c, QString::fromLatin1( type ) ) );
+        attachment->setLabel( name );
+        incidence->addAttachment(attachment);
+        Debug() << "ATTACHMENT NAME" << name << type;
+    }
+}
+
+void getAttachmentsById(KCalCore::Incidence::Ptr incidence, const KMime::Message::Ptr &mimeData)
+{
+    if (!incidence) {
+        Error() << "Invalid incidence";
+        return;
+    }
+//     kDebug() << "getting " << attachments.size() << "attachments";
+//     kDebug() << mimeData->encodedContent();
+
+    foreach(KCalCore::Attachment::Ptr attachment, incidence->attachments()) {
+        Debug() << attachment->uri();
+        if (!attachment->uri().contains("cid:")) {
+            continue;
+        }
+        //It's a referenced attachmant, extract it
+        QByteArray type;
+        QString name;
+        KMime::Content *content = findContentById(mimeData, fromCid(attachment->uri()).toLatin1(), type, name);
+        if (!content) { // guard against malformed events with non-existent attachments
+            Error() << "could not find attachment: "<< name << type;
+            continue;
+        }
+        attachment->setUri(QString());
+        attachment->setData(content->decodedContent().toBase64());
+        attachment->setMimeType(type);
+        attachment->setLabel(name);
+    }
+}
+
+
+
+}; //Namespace
+}; //Namespace
diff --git a/src/mime/mimeutils.h b/src/mime/mimeutils.h
new file mode 100644
index 0000000..c3053a9
--- /dev/null
+++ b/src/mime/mimeutils.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2012  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef KOLABMIMEUTILS_H
+#define KOLABMIMEUTILS_H
+
+#include "kolab_export.h"
+
+#include <kcalcore/incidence.h>
+#include <kcalcore/event.h>
+#include <kmime/kmime_message.h>
+#include <kabc/addressee.h>
+class QDomDocument;
+
+namespace Kolab {
+    namespace Mime {
+
+KMime::Content* findContentByName(const KMime::Message::Ptr &data, const QString &name, QByteArray &type);
+KMime::Content* findContentByType(const KMime::Message::Ptr &data, const QByteArray &type);
+QList<QByteArray> getContentMimeTypeList(const KMime::Message::Ptr &data);
+
+/**
+* Get Attachments from a Mime message
+* 
+* Set the attachments listed in @param attachments on @param incidence from @param mimeData
+*/
+//v2
+void getAttachments(KCalCore::Incidence::Ptr incidence, const QStringList &attachments, const KMime::Message::Ptr &mimeData);
+//v3
+void getAttachmentsById(KCalCore::Incidence::Ptr incidence, const KMime::Message::Ptr &mimeData);
+
+///Generic serializing functions
+KMime::Message::Ptr createMessage(const KCalCore::Incidence::Ptr &incidencePtr, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &prodid);
+KMime::Message::Ptr createMessage(const KABC::Addressee &contact, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &prodid);
+KMime::Message::Ptr createMessage(const QString &subject, const QString &mimetype, const QString &xKolabType, const QByteArray &xml, bool v3, const QString &prodid);
+
+KMime::Content* createExplanationPart();
+KMime::Message::Ptr createMessage(const QString& mimeType, bool v3, const QString &prodid);
+KMime::Content* createMainPart(const QString& mimeType, const QByteArray& decodedContent);
+KMime::Content* createAttachmentPart(const QByteArray &cid, const QString& mimeType, const QString& fileName, const QByteArray& decodedContent);
+
+    };
+}; //Namespace
+
+#endif
diff --git a/src/shared.i b/src/shared.i
new file mode 100644
index 0000000..1941daa
--- /dev/null
+++ b/src/shared.i
@@ -0,0 +1,13 @@
+
+%{
+    /* This macro ensures that return vectors remain a vector also in python and are not converted to tuples */
+    #define SWIG_PYTHON_EXTRA_NATIVE_CONTAINERS
+    #include <kolabevent.h>
+%}
+%include "std_vector.i"
+%import(module="kolabformat") <kolabevent.h>
+namespace std {
+/* vectorevent moved to libkolabxml, vectorevent2 breaks the pythonbindings without vectorevent in here (compile error) */
+/*    %template(vectorevent) vector<Kolab::Event>; */
+/*    %template(vectorevent2) vector< vector<Kolab::Event> >; */
+};
diff --git a/src/utils/CMakeLists.txt b/src/utils/CMakeLists.txt
new file mode 100644
index 0000000..50b76e9
--- /dev/null
+++ b/src/utils/CMakeLists.txt
@@ -0,0 +1,5 @@
+
+find_package(Boost REQUIRED COMPONENTS program_options)
+
+add_executable(kolabformatchecker kolabformatchecker.cpp)
+target_link_libraries(kolabformatchecker KF5::Kolab ${Boost_LIBRARIES} ${Libkolabxml_LIBRARIES})
diff --git a/src/utils/kolabformatchecker.cpp b/src/utils/kolabformatchecker.cpp
new file mode 100644
index 0000000..4fb8598
--- /dev/null
+++ b/src/utils/kolabformatchecker.cpp
@@ -0,0 +1,108 @@
+/*
+ * Copyright (C) 2012  Sofia Balicka <balicka@kolabsys.com>
+ * Copyright (C) 2013  Christian Mollekopf <mollekopf@kolabsys.com>
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <boost/program_options.hpp>
+#include <iostream>
+#include <string>
+#include <vector>
+#include <QFile>
+#include <kolabformat.h>
+#include "errorhandler.h"
+#include "kolabformat/kolabobject.h"
+
+namespace po = boost::program_options;
+using namespace std;
+
+KMime::Message::Ptr readMimeFile( const QString &fileName, bool &ok)
+{
+    QFile file( fileName );
+    ok = file.open( QFile::ReadOnly );
+    if (!ok) {
+        cout << "failed to open file: " << fileName.toStdString() << endl;;
+        return KMime::Message::Ptr();
+    }
+    const QByteArray data = file.readAll();
+    KMime::Message::Ptr msg = KMime::Message::Ptr(new KMime::Message);
+    msg->setContent( KMime::CRLFtoLF(data) );
+    msg->parse();
+    return msg;
+}
+
+int main(int argc, char *argv[])
+{
+    // Declare the supported options.
+    po::options_description desc("Allowed options");
+    desc.add_options()
+        ("help", "produce help message")
+        ("input-file", po::value<std::vector<std::string> >(), "input files")
+        ;
+
+    po::positional_options_description p;
+    p.add("input-file", -1);
+
+    po::variables_map vm;
+    po::store(po::command_line_parser(argc, argv).
+            options(desc).positional(p).run(), vm);
+    po::notify(vm);
+
+    if (vm.count("help")) {
+        cout << desc << "\n";
+        return 1;
+    }
+
+    vector<string> inputFiles;
+    if (vm.count("input-file")) {
+        inputFiles = vm["input-file"].as< vector<string> >();
+    } else {
+        cout << "Specify input-file\n";
+        return -1;
+    }
+
+    int returnValue = 0;
+
+    cout << endl;
+
+    for(vector<string>::const_iterator it = inputFiles.begin();
+            it != inputFiles.end(); it++){
+
+        cout << "File: " << *it << endl;
+
+        bool ok;
+        KMime::Message::Ptr message = readMimeFile( QString::fromStdString(*it), ok);
+
+        if(!ok){
+            returnValue = -1;
+            cout << endl;
+            continue;
+        }
+
+        Kolab::KolabObjectReader reader(message);
+
+        if (Kolab::ErrorHandler::errorOccured()){
+            cout << "Errors occured during parsing." << endl;
+            returnValue = -1;
+        } else {
+            cout << "Parsed message without error." << endl;
+        }
+
+        cout << endl;
+    }
+
+    return returnValue;
+}
+
diff --git a/tests/CMakeLists.txt b/tests/CMakeLists.txt
index ef7a37f..8fb9e7d 100644
--- a/tests/CMakeLists.txt
+++ b/tests/CMakeLists.txt
@@ -5,13 +5,13 @@ add_definitions(-DTEST_DATA_PATH="${CMAKE_CURRENT_SOURCE_DIR}")
 macro(addTest TEST_NAME)
     QT4_AUTOMOC(${TEST_NAME}.cpp)
     add_executable(${TEST_NAME} ${TEST_NAME}.cpp)
-    target_link_libraries(${TEST_NAME} ${QT_QTTEST_LIBRARY} kolab_static)
+    target_link_libraries(${TEST_NAME} Qt5::Test kolab_static)
     add_test(${TEST_NAME} ${CMAKE_CURRENT_BINARY_DIR}/${TEST_NAME})
 endmacro()
 
 QT4_AUTOMOC(benchmark.cpp)
 add_executable(benchmarktest benchmark.cpp)
-target_link_libraries(benchmarktest ${QT_QTTEST_LIBRARY} kolab_static)
+target_link_libraries(benchmarktest Qt5::Test kolab_static)
 
 addTest(formattest)
 addTest(upgradetest)
diff --git a/tests/testhelpers.h b/tests/testhelpers.h
index f0e3889..1a0a20f 100644
--- a/tests/testhelpers.h
+++ b/tests/testhelpers.h
@@ -45,13 +45,7 @@ Q_DECLARE_METATYPE(KCalCore::Event);
 Q_DECLARE_METATYPE(KCalCore::Todo);
 Q_DECLARE_METATYPE(KCalCore::Journal);
 
-#if KDEPIMLIBS_VERSION_MAJOR <= 4
-#if KDEPIMLIBS_VERSION_MINOR <= 11
-#if KDEPIMLIBS_VERSION_PATCH < 52
 Q_DECLARE_METATYPE(KCalCore::Duration);
-#endif
-#endif
-#endif
 
 namespace QTest {
     
diff --git a/utils/CMakeLists.txt b/utils/CMakeLists.txt
deleted file mode 100644
index 19d34d1..0000000
--- a/utils/CMakeLists.txt
+++ /dev/null
@@ -1,5 +0,0 @@
-
-find_package(Boost REQUIRED COMPONENTS program_options)
-
-add_executable(kolabformatchecker kolabformatchecker.cpp)
-target_link_libraries(kolabformatchecker kolab ${Boost_LIBRARIES})
diff --git a/utils/kolabformatchecker.cpp b/utils/kolabformatchecker.cpp
deleted file mode 100644
index 10dc6c2..0000000
--- a/utils/kolabformatchecker.cpp
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2012  Sofia Balicka <balicka@kolabsys.com>
- * Copyright (C) 2013  Christian Mollekopf <mollekopf@kolabsys.com>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-#include <boost/program_options.hpp>
-#include <iostream>
-#include <string>
-#include <vector>
-#include <QString>
-#include <QFile>
-#include <kolabformat.h>
-#include "kolabformat/errorhandler.h"
-#include "kolabformat/kolabobject.h"
-
-namespace po = boost::program_options;
-using namespace std;
-
-KMime::Message::Ptr readMimeFile( const QString &fileName, bool &ok)
-{
-    QFile file( fileName );
-    ok = file.open( QFile::ReadOnly );
-    if (!ok) {
-        cout << "failed to open file: " << fileName.toStdString() << endl;;
-        return KMime::Message::Ptr();
-    }
-    const QByteArray data = file.readAll();
-    KMime::Message::Ptr msg = KMime::Message::Ptr(new KMime::Message);
-    msg->setContent( KMime::CRLFtoLF(data) );
-    msg->parse();
-    return msg;
-}
-
-int main(int argc, char *argv[])
-{
-    // Declare the supported options.
-    po::options_description desc("Allowed options");
-    desc.add_options()
-        ("help", "produce help message")
-        ("input-file", po::value<std::vector<std::string> >(), "input files")
-        ;
-
-    po::positional_options_description p;
-    p.add("input-file", -1);
-
-    po::variables_map vm;
-    po::store(po::command_line_parser(argc, argv).
-            options(desc).positional(p).run(), vm);
-    po::notify(vm);
-
-    if (vm.count("help")) {
-        cout << desc << "\n";
-        return 1;
-    }
-
-    vector<string> inputFiles;
-    if (vm.count("input-file")) {
-        inputFiles = vm["input-file"].as< vector<string> >();
-    } else {
-        cout << "Specify input-file\n";
-        return -1;
-    }
-
-    int returnValue = 0;
-
-    cout << endl;
-
-    for(vector<string>::const_iterator it = inputFiles.begin();
-            it != inputFiles.end(); it++){
-
-        cout << "File: " << *it << endl;
-
-        bool ok;
-        KMime::Message::Ptr message = readMimeFile( QString::fromStdString(*it), ok);
-
-        if(!ok){
-            returnValue = -1;
-            cout << endl;
-            continue;
-        }
-
-        Kolab::KolabObjectReader reader(message);
-
-        if (Kolab::ErrorHandler::errorOccured()){
-            cout << "Errors occured during parsing." << endl;
-            returnValue = -1;
-        } else {
-            cout << "Parsed message without error." << endl;
-        }
-
-        cout << endl;
-    }
-
-    return returnValue;
-}
-
